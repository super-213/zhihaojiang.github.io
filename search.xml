<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/zhihaojiang.github.io/2025/01/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>广州旅游</title>
    <url>/zhihaojiang.github.io/2024/07/31/20240731%E5%B9%BF%E5%B7%9E%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/super-213/hexo-images/blob/main/articles/2024/07/31/2024-05811.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05829.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05837.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05840.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05883.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05884.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05904.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/001.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>嘉兴大学演出</title>
    <url>/zhihaojiang.github.io/2024/10/17/20241017%E5%98%89%E5%85%B4%E5%A4%A7%E5%AD%A6%E6%BC%94%E5%87%BA/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07355.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07363.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07436.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07465.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07470.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07494.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07495.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07496.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语句</title>
    <url>/zhihaojiang.github.io/2025/01/06/20250106MySQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>本位与2025-01-06在CSDN上发布 现将其转移至自己的博客</p>
<h2 id="引擎相关"><a href="#引擎相关" class="headerlink" title="引擎相关"></a>引擎相关</h2><h3 id="查看存储引擎："><a href="#查看存储引擎：" class="headerlink" title="查看存储引擎："></a>查看存储引擎：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure></div>
<h3 id="查看显示支持的存储引擎信息："><a href="#查看显示支持的存储引擎信息：" class="headerlink" title="查看显示支持的存储引擎信息："></a>查看显示支持的存储引擎信息：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;have%&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="查看默认的存储引擎："><a href="#查看默认的存储引擎：" class="headerlink" title="查看默认的存储引擎："></a>查看默认的存储引擎：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;storage_engine&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数据库相关操作-增-删-改"><a href="#数据库相关操作-增-删-改" class="headerlink" title="数据库相关操作(增 删 改)"></a>数据库相关操作(增 删 改)</h2><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create datbase [<span class="keyword">if</span> not exists] db_name</span><br><span class="line">[[DEFAULT] CHARACTER SET charset_name]</span><br><span class="line">[[DEFALUT] COLLATE collation_name]</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>“[ ]”中的是可选项 可写可不写<br>将db_name替换成你想给数据库取的名字</p>

    </div>
  </div>

<h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></div>

<h3 id="查看数据库的详细信息"><a href="#查看数据库的详细信息" class="headerlink" title="查看数据库的详细信息"></a>查看数据库的详细信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show create database db_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用某个数据库"><a href="#使用某个数据库" class="headerlink" title="使用某个数据库"></a>使用某个数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">use db_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter database [db_name]</span><br><span class="line">[DEFAULT CHARACTER SET charset_name]| [[DEFAULT]COLLATE collation_name]</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>例1：将schoolDB的编码方式有GBK修改为UTF8。</p>
<p>法1:ALTER DATABASE schoolDB CHARACTER SET UTF8;</p>
<p>法2:ALTER DATABASE schoolDB collate utf8_general_ci;</p>

    </div>
  </div>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop database [<span class="keyword">if</span> exists] db_name;</span><br></pre></td></tr></table></figure></div>
<h2 id="表的相关操作（增删改查）"><a href="#表的相关操作（增删改查）" class="headerlink" title="表的相关操作（增删改查）"></a>表的相关操作（增删改查）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table [<span class="keyword">if</span> exists] t_name(</span><br><span class="line">    name_1 int [primary key],</span><br><span class="line">    name_2 varchar(10)[...],</span><br><span class="line">    name_3 <span class="built_in">float</span>(5, 3)[...]</span><br><span class="line">)[engine = INNODB charset = UTF-8];</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>这里t_name是表名</p>
<p>name_1 name_2 name_3 是字段名</p>
<p>字段名后面[ ]中的是完整性约束(可选填)</p>
<p> 完整性约束条件：<br> PRIMARY KEY主键（唯一来标识的，每一个表都一个，自动非空）<br> AUTO_INCREMENT自增长<br> FOREIGN KEY外键<br> NOT NULL非空<br> UNIQUE KEY唯一<br> DEFAULT默认值<br>最下面的[ ] 中的是引擎和编码方式的选择</p>

    </div>
  </div>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="在name-3的（前面-后面）-增加新列name-4"><a href="#在name-3的（前面-后面）-增加新列name-4" class="headerlink" title="[在name_3的（前面|后面）] 增加新列name_4"></a>[在name_3的（前面|后面）] 增加新列name_4</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    add name_4 [first|after name_3];</span><br></pre></td></tr></table></figure></div>

<h4 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h4><p>将name_2的数据类型修改成float(4,3)</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    modify name_2 <span class="built_in">float</span>(4,3)</span><br></pre></td></tr></table></figure></div>

<h4 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h4><p>将表t_name中的name_1列的名字修改成new_name_1</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    change name_1 new_name_1;</span><br></pre></td></tr></table></figure></div>

<h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><p>将表t_name的名字修改成new_t_name</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    rename [to] new_t_name;</span><br></pre></td></tr></table></figure></div>

<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p>将表t_name中的name_1列删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">drop column name_1；</span><br></pre></td></tr></table></figure></div>

<h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">delete from t_name</span><br><span class="line"><span class="built_in">where</span> 条件表达式；</span><br></pre></td></tr></table></figure></div>

<h4 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h4><p>将表t_name的存储引擎修改成INNODB</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    engine = INNODB;</span><br></pre></td></tr></table></figure></div>

<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><p>查看表名</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></div>

<p>查看表的结构</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#法1</span></span><br><span class="line">show create table t_name；</span><br><span class="line"> </span><br><span class="line"><span class="comment">#法2</span></span><br><span class="line">describe t_name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#法3</span></span><br><span class="line">desc t_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table [<span class="keyword">if</span> not existe] t_name</span><br><span class="line">[like t_name_2]</span><br><span class="line">[as 表信息]</span><br><span class="line"> </span><br><span class="line"><span class="comment">#like可以复制表的结构 表中的信息不会被复制 复制出来的是个空表</span></span><br><span class="line"><span class="comment">#as 可以复制表中的信息 相当于CV大法</span></span><br></pre></td></tr></table></figure></div>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>将表t_name删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop table t_name；</span><br></pre></td></tr></table></figure></div>

<h2 id="数据相关操作"><a href="#数据相关操作" class="headerlink" title="数据相关操作"></a>数据相关操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">insert [into]</span><br><span class="line">    t_name(name_1, name_2, name_3)</span><br><span class="line">    values(12,<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;2025-01-04&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="查看插入信息"><a href="#查看插入信息" class="headerlink" title="查看插入信息"></a>查看插入信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from t_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">update t_name</span><br><span class="line"><span class="built_in">set</span> name_1 = x,</span><br><span class="line">    name_2 = y,</span><br><span class="line">    name_3 = z</span><br><span class="line">[<span class="built_in">where</span> 条件表达式];</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>若where不写<br>则更新全部记录</p>

    </div>
  </div>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">delate from t_name</span><br><span class="line">[<span class="built_in">where</span> 条件表达式];</span><br></pre></td></tr></table></figure></div>

<p>完全清除某个表<br>完全清除表t_name：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">truncate</span> [table] t_name;</span><br></pre></td></tr></table></figure></div>

<h2 id="单表查询（重点）"><a href="#单表查询（重点）" class="headerlink" title="单表查询（重点）"></a>单表查询（重点）</h2><p>先给出语法：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [distinct] name_1 [as new_name],</span><br><span class="line">       [distinct] name_2 [as new_name],</span><br><span class="line">from t_name</span><br><span class="line">[<span class="built_in">where</span> 条件表达式,]</span><br><span class="line">[group by name [ASC|DESC],]</span><br><span class="line">[order by name [ASC|DESC],]</span><br><span class="line">[<span class="built_in">limit</span> 条数]；</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>SELECT子句：<br>指定要查询的列名称，列与列之间用逗号隔开。<br>还可以为列指定新的别名，显示在输出的结果中。<br>ALL关键字表示显示所有的行，包括重复行，是系统默认的<br>DISTINCT表示显示的结果要消除重复的行。<br>FROM子句：指定要查询的表，可以指定两个以上的表，表与表之间用逗号隔开。<br>WHERE子句：指定要查询的条件。<br>如果有WHERE子句，就按照“条件表达式”指定的条件进行查询；<br>如果没有WHERE子句，就查询所有记录。</p>
<p>GROUP BY ：<br>子句用于对查询结构进行分组。<br>按照“列名1”指定的字段进行分组；<br>如果GROUP BY子句后带着HAVING关键字，那么只有满足“条件表达式2”中指定的条件的才能够输出。<br>GROUP BY子句通常和COUNT()、SUM()等聚合函数一起使用。</p>
<p>HAVING子句：<br>指定分组的条件，通常放Group by字句之后</p>
<p>ORDER BY子句：用于对查询结果的进行排序。<br>排序方式由ASC和DESC两个参数指出；<br>ASC参数表示按升序进行排序。默认情况下是ASC。<br>DESC参数表示按降序的顺序进行排序。升序表示值按从小到大的顺序排列。</p>
<p>LIMIT 子句：限制查询的输出结果的行数。</p>

    </div>
  </div>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>等值连接</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> x_name_1,</span><br><span class="line">       y_name_2</span><br><span class="line">from t_x </span><br><span class="line">inner <span class="built_in">join</span> t_y on t_x.id = t_y.id</span><br><span class="line"><span class="built_in">where</span>...;</span><br></pre></td></tr></table></figure></div>
<p>左连接、右连接和联合查询不过多赘述</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>带in关键词的子查询</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">from t_name_1</span><br><span class="line"><span class="built_in">where</span> name_1 <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> name_2 from t_name_2</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>带比较运算符的子查询</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">from t_name_1</span><br><span class="line"><span class="built_in">where</span> name = (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">id</span></span><br><span class="line">    from t_name_2</span><br><span class="line">    <span class="built_in">where</span> <span class="built_in">id</span> = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>引:<br>    面试题：select id,name,age from sd where name&#x3D;’张飞’<br>    怎么优化？最佳方案是什么？<br>    答：在name上创建索引：<br>    create index in name on sd(name);</p>
<h3 id="语法（已存在的表）："><a href="#语法（已存在的表）：" class="headerlink" title="语法（已存在的表）："></a>语法（已存在的表）：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create index in_id</span><br><span class="line">on t_name(<span class="built_in">id</span>);</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>in_id:索引名 （自己取）<br>t_name:表名<br>id:列名</p>

    </div>
  </div>

<h3 id="在创建表的时候创建索引"><a href="#在创建表的时候创建索引" class="headerlink" title="在创建表的时候创建索引"></a>在创建表的时候创建索引</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table t_name(</span><br><span class="line">...</span><br><span class="line">[unique|fulltext|spatial] index|key [in_id](name[长度])[ASC|DESC]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create view view_name as</span><br><span class="line"><span class="comment">#查询语句:</span></span><br><span class="line"><span class="keyword">select</span>...</span><br><span class="line">[with [cascaded|<span class="built_in">local</span>] check option];</span><br></pre></td></tr></table></figure></div>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop view view_name;</span><br></pre></td></tr></table></figure></div>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create user <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identifiednby <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from mysql.user;</span><br></pre></td></tr></table></figure></div>

<h3 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grant 权限 on 库.表 to <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#触发器设置</span></span><br><span class="line">CREATE TRIGGER before_position_update</span><br><span class="line">BEFORE UPDATE ON staff</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    IF OLD.position != NEW.position THEN</span><br><span class="line">        CASE NEW.position</span><br><span class="line">            WHEN <span class="string">&#x27;董事长&#x27;</span> THEN</span><br><span class="line">                SET NEW.role = 9;</span><br><span class="line">            WHEN <span class="string">&#x27;经理&#x27;</span> THEN</span><br><span class="line">                SET NEW.role = 6;</span><br><span class="line">            ELSE</span><br><span class="line">                SET NEW.role = 2;</span><br><span class="line">        END CASE;</span><br><span class="line">    END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>这里是当position设置为经理或董事长时 自动更改权限等级</p>

    </div>
  </div>

<h3 id="显示设置的触发器"><a href="#显示设置的触发器" class="headerlink" title="显示设置的触发器"></a>显示设置的触发器</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示设置的触发器</span></span><br><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure></div>

<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>备份数据库到文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p db_name &gt; backup.sql</span><br></pre></td></tr></table></figure></div>

<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>从文件恢复数据库。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u username -p db_name &lt; backup.sql</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>澳洲旅游</title>
    <url>/zhihaojiang.github.io/2025/01/25/20250125%E6%BE%B3%E6%B4%B2%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09682.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09718.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09763.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09941.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09945.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09946.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09958.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09967.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习作业笔记</title>
    <url>/zhihaojiang.github.io/2025/03/28/20250328%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>我们需要利用回归分析预测世界大学综合得分</p>
<p>#Jupyter notebook代码<br>基本库导入</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line">from sklearn.metrics import mean_squared_error,r2_score</span><br><span class="line">from scipy import stats</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.metrics import root_mean_squared_error</span><br><span class="line">from sklearn import linear_model</span><br><span class="line">from sklearn import metrics</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university = pd.read_csv(<span class="string">&#x27;cwurData.csv&#x27;</span>)</span><br><span class="line">university.head()</span><br></pre></td></tr></table></figure></div>
<p>此时可能会出现报错</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>报错信息</p>

    </div>
    <div class="notel-content">
      <p>File parsers.pyx:574, in pandas._libs.parsers.TextReader.<strong>cinit</strong>()</p>
<p>File parsers.pyx:663, in pandas._libs.parsers.TextReader._get_header()</p>
<p>File parsers.pyx:874, in pandas._libs.parsers.TextReader._tokenize_rows()</p>
<p>File parsers.pyx:891, in pandas._libs.parsers.TextReader._check_tokenize_status()</p>
<p>File parsers.pyx:2053, in pandas._libs.parsers.raise_parser_error()</p>
<p>File <frozen codecs>:322, in decode(self, input, final)</p>
<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode bytes in position 3864-3865: invalid continuation byte</p>

    </div>
  </div>
<p>不用担心，这是因为pd.read_csv()在不指明encoding时默认使用utf-8编码<br>这段报错是因为该文件不是使用utf-8进行编码。<br>我们可以写一段代码判断文件的编码格式</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import chardet</span><br><span class="line"></span><br><span class="line">with open(<span class="string">&#x27;cwurData.csv&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) as f:</span><br><span class="line">    university = f.read()</span><br><span class="line">    encoding = chardet.detect(university)</span><br><span class="line">    <span class="built_in">print</span>(encoding)</span><br></pre></td></tr></table></figure></div>
<p>之后将其输出的encoding写入pd.read_csv()即可</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university = pd.read_csv(<span class="string">&#x27;cwurData.csv&#x27;</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">university.head()</span><br></pre></td></tr></table></figure></div>
<p>输出结果为<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/001.png"
                      alt="photo"
                ><br>通过该数据可知其数字应该是越小越好<br>因此相关性应该是负数 且越小越好</p>
<p>之后我们查看文件的维度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university.shape</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:(2200, 14)<br>说明该文件总共有2200行数据，14个特征</p>
<p>接下来我们分析下文件是否有异常</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university.describe()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/002.png"
                      alt="photo"
                ><br>从第一行(count)看到 broad_impact数据与其他数据不同<br>上述从head()函数我猜测broad_impact列全是NA<br>仔细查看文件后可知:2012年和2013年的broad_impact存在缺失<br>其他数据看起来没什么问题 数据质量基本完整</p>
<p>先用相关性矩阵看看各个数据之间的关系</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = university[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">X = university.drop([<span class="string">&quot;score&quot;</span>,<span class="string">&quot;institution&quot;</span>,<span class="string">&quot;country&quot;</span>, <span class="string">&quot;year&quot;</span>,<span class="string">&quot;broad_impact&quot;</span>],axis=1)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">correlation_matrix = pd.concat([X_train, y_train], axis=1).corr()</span><br><span class="line"></span><br><span class="line">sns.heatmap(correlation_matrix, annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/003.png"
                      alt="photo"
                ><br>通过上图可以看到world_rank与publications、influence、citations有强相关性<br>我们用matplotlib.pyplot库做出这些图</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;publications&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;publications&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/004.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;influence&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;influence&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/005.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;citations&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;citations&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/006.png"
                      alt="photo"
                ></p>
<p>从上述三幅图可以看到world_rank与publications、influence有强相关性<br>world_rank与citations也有一定的相关性 但不是很明显<br>再继续做几张图看看其他数据之间的关系怎么样</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;publications&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;influence&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;influence&amp;publications&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/007.png"
                      alt="photo"
                ><br>从图中可以看出点近似集中在一条直线上<br>说明出版物与影响力成正比</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;broad_impact&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;score&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;score&amp;broad_impact&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/008.png"
                      alt="photo"
                ><br>从图中可以看出broad_impact与score成非线性关系 broad_impact的大小与score无关<br><br>用相关性进行检测</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;broad_impact&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;score&quot;</span>]</span><br><span class="line">correlation = x.corr(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r:&quot;</span>, correlation)</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:r: -0.5315904271503679</p>
<p>呈现负相关 因此确定 broad_impact的大小与score无关<br>并且broad_impact中存在缺失值<br>缺失值的处理一般会使用用众数填充、前或后一个数填充、删除缺失列来处理<br>这里broad_impact的大小与score无关<br>因此可以将此列删去<br>同时也可以降低维度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = university[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">X = university.drop([<span class="string">&quot;score&quot;</span>,<span class="string">&quot;institution&quot;</span>,<span class="string">&quot;country&quot;</span>, <span class="string">&quot;year&quot;</span>,<span class="string">&quot;broad_impact&quot;</span>],axis=1)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">lr.intercept_</span><br><span class="line"></span><br><span class="line">coefs_lr = pd.Series(lr.coef_).round()</span><br><span class="line">coefs_lr.index = X_train.columns</span><br><span class="line">coefs_lr</span><br></pre></td></tr></table></figure></div>

<p>其结果为:<br>63.60601390140695</p>
<p>world_rank              0.0<br>national_rank          -0.0<br>quality_of_education   -0.0<br>alumni_employment      -0.0<br>quality_of_faculty     -0.0<br>publications           -0.0<br>influence              -0.0<br>citations              -0.0<br>patents                -0.0<br>dtype: float64</p>
<p>说明模型拟合得不好<br>查看其均方根误差和决定系数</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lr_train_pred = lr.predict(X_train)</span><br><span class="line">lr_test_pred = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;训练集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(lr_train_pred,y_train), r2_score(lr_train_pred,y_train))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;测试集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(lr_test_pred,y_test), r2_score(lr_test_pred,y_test))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>训练集上的均方根误差和决定系数分别为: 5.441831802594455 0.079429595738992<br>测试集上的均方根误差和决定系数分别为: 5.369301125131177 0.06344204755145388</p>
<p>上述系数过小可能是数值之间差别过大导致拟合得不好<br>将其进行标准化</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train_scaled, y_train)</span><br><span class="line">coefs_lr = pd.Series(lr.coef_).round()</span><br><span class="line">coefs_lr.index = X_train.columns</span><br><span class="line">coefs_lr</span><br><span class="line"></span><br><span class="line">lr.intercept_</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>world_rank              0.0<br>national_rank          -0.0<br>quality_of_education   -0.0<br>alumni_employment      -1.0<br>quality_of_faculty     -4.0<br>publications           -0.0<br>influence              -0.0<br>citations              -0.0<br>patents                -0.0<br>dtype: float64</p>
<p>47.83457386363636</p>
<p>模型得到的结果很低 说明拟合得不好<br>更换其他线性回归模型试试</p>
<div class="tabs" id="tab-线性回归模型"><ul class="nav-tabs"><li class="tab active"><a class="#线性回归模型-1">岭回归</a></li><li class="tab"><a class="#线性回归模型-2">lasso回归</a></li><li class="tab"><a class="#线性回归模型-3">弹性网回归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="线性回归模型-1"><p><strong>岭回归</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ridge= linear_model.Ridge(alpha=0.05)</span><br><span class="line">ridge.fit(X_train,y_train)</span><br><span class="line">Y_hat = ridge.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>, ridge.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, ridge.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p> 输出结果为:<br> 截距为： 63.60601382257282<br>回归系数为： [ 0.00116895 -0.00608447 -0.00380894 -0.00592045 -0.06344228 -0.00045937<br> -0.0009899  -0.00046924 -0.00164281]<br> RMSE: 5.369301120766853</p></div><div class="tab-pane" id="线性回归模型-2"><p><strong>lasso回归</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lasso= linear_model.Lasso(alpha=0.05)</span><br><span class="line">lasso.fit(X_train,y_train)</span><br><span class="line">Y_hat=lasso.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>,lasso.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, lasso.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>截距为： 63.602800047243974<br>回归系数为： [ 0.00115484 -0.00606551 -0.00381082 -0.00591616 -0.06342471 -0.00045677<br> -0.00098495 -0.00046729 -0.00164163]<br> RMSE: 5.369181579518303</p></div><div class="tab-pane" id="线性回归模型-3"><p><strong>弹性网回归</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">elastic= linear_model.ElasticNet(alpha=0.1,l1_ratio=0.4)</span><br><span class="line">elastic.fit(X_train,y_train)</span><br><span class="line">y_hat = elastic.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>,elastic.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, elastic.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>截距为： 63.60327653271375<br>回归系数为： [ 0.00115777 -0.0060693  -0.00381124 -0.00591707 -0.06342543 -0.00045734<br> -0.00098603 -0.00046779 -0.00164194]<br> RMSE: 5.369181579518303</p></div></div></div>

<p>可以看到这些回归得到的结果都不好<br>说明这个不是呈线性关系</p>
<p>我们使用随机森林进行尝试</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rf = RandomForestRegressor()</span><br><span class="line">rf.fit(X_train, y_train)</span><br><span class="line">rf_train_pred = rf.predict(X_train)</span><br><span class="line">rf_test_pred = rf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;训练集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(rf_train_pred,y_train), r2_score(rf_train_pred,y_train))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;测试集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(rf_test_pred,y_test), r2_score(rf_test_pred,y_test))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>训练集上的均方根误差和决定系数分别为: 0.396126717281446 0.9974538720434839<br>测试集上的均方根误差和决定系数分别为: 1.0185613846393418 0.9808937922886296</p>
<p>可以看到 决定系数为0.99 0.98以上 说明模型拟合得很好</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>连续特征离散化的处理方法及其python实现</title>
    <url>/zhihaojiang.github.io/2025/03/29/20250329%E8%BF%9E%E7%BB%AD%E7%89%B9%E5%BE%81%E7%A6%BB%E6%95%A3%E5%8C%96%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="等距离散法"><a href="#等距离散法" class="headerlink" title="等距离散法"></a>等距离散法</h2><p>将连续数据的范围划分为几个宽度相等的区间。每个区间内的数值都有相同的范围。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分为 5 个等宽区间</span></span><br><span class="line">bins = pd.cut(data, bins=5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分箱结果</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="等频离散法"><a href="#等频离散法" class="headerlink" title="等频离散法"></a>等频离散法</h2><p>将数据分成几个区间，使得每个区间内的数据量相同。这样可以避免某些区间的数据过于集中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分为 5 个等频区间</span></span><br><span class="line">bins = pd.qcut(data, q=5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分箱结果</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="K-means-模型离散法"><a href="#K-means-模型离散法" class="headerlink" title="K-means 模型离散法"></a>K-means 模型离散法</h2><p>先从样本集中随机选取 k个样本作为簇中心，并计算所有样本与这 k个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.cluster import KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000).reshape(-1, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 K-means 聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=5)</span><br><span class="line">labels = kmeans.fit_predict(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看聚类标签</span></span><br><span class="line"><span class="built_in">print</span>(pd.Series(labels).value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="基于决策树的离散化"><a href="#基于决策树的离散化" class="headerlink" title="基于决策树的离散化"></a>基于决策树的离散化</h2><p>基于决策树的方法利用决策树的分割规则进行离散化，将连续特征分割成多个区间，通常用于有监督学习中的离散化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line">target = np.random.randint(0, 2, size=1000)  <span class="comment"># 假设目标变量是二分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将连续数据转化为二维数组</span></span><br><span class="line">X = data.reshape(-1, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用决策树进行离散化</span></span><br><span class="line">clf = DecisionTreeClassifier(max_leaf_nodes=5)</span><br><span class="line">clf.fit(X, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每个样本所属的区间</span></span><br><span class="line">labels = clf.apply(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看离散化结果</span></span><br><span class="line"><span class="built_in">print</span>(pd.Series(labels).value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="分位数离散法"><a href="#分位数离散法" class="headerlink" title="分位数离散法"></a>分位数离散法</h2><p>分位数离散化的核心思想是：<br>按照数据的累积分布函数 (CDF) 计算分位点。<br>根据分位数（如四分位数 (quartiles)、十分位数 (deciles)）划分数据，使得每个区间的样本数接近相等。<br>由于基于数据的分布进行划分，适用于非均匀分布的数据。</p>
<p>以下是不同的方法进行实现</p>
<div class="tabs" id="tab-分位数离散法实现方法"><ul class="nav-tabs"><li class="tab active"><a class="#分位数离散法实现方法-1">方法一</a></li><li class="tab"><a class="#分位数离散法实现方法-2">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="分位数离散法实现方法-1"><p><strong>使用pandas.qcut()</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 1000 个随机数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 qcut 进行分位数离散化（四分位）</span></span><br><span class="line">bins = pd.qcut(data, q=4, labels=[<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个分箱的数据量</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="分位数离散法实现方法-2"><p><strong>使用numpy.percentile()</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 1000 个随机数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 10 分位数（十分位数）</span></span><br><span class="line">percentiles = np.percentile(data, q=[10, 20, 30, 40, 50, 60, 70, 80, 90])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 np.digitize 进行分箱</span></span><br><span class="line">bins = np.digitize(data, percentiles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个分箱的数据量</span></span><br><span class="line"><span class="built_in">print</span>(np.bincount(bins))</span><br></pre></td></tr></table></figure></div></div></div></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>分位数离散化的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>适用于非均匀分布数据，相比于等宽离散化更合理。<br>避免某些区间数据过多或过少，能够更好地均衡数据。<br>能够减少异常值的影响，因为分箱是基于数据分布，而不是固定范围。</p>
<p>❌ 缺点<br>对极端值敏感，如果数据中有极端值，可能会影响分位数计算结果。<br>区间边界难以解释，不像等宽分箱那样有固定的区间宽度。<br>对新数据可能需要重新计算分位点，导致难以适用于流式数据。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用分位数离散化？</p>

    </div>
    <div class="notel-content">
      <p>数据分布不均匀（例如数据集中在某些范围）。<br>避免某些区间样本过多或过少，如在决策树、统计建模等场景中使用。<br>希望减少异常值的影响，避免极端值导致不均匀的划分。</p>

    </div>
  </div>

<h2 id="基于卡方分裂的离散法"><a href="#基于卡方分裂的离散法" class="headerlink" title="基于卡方分裂的离散法"></a>基于卡方分裂的离散法</h2><p>该分裂算法是把整个属性的取值区间当做一个离散的属性值，然后对该区间进行划分，一般是一分为二，即把一个区间分为两个相邻的区间，每个区间对应一个离散的属性值，该划分可以一直进行下去，直到满足某种停止条件，其关键是划分点的选取。</p>
<p><strong>方法一</strong><br><strong>手动实现</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy.stats import chi2_contingency</span><br><span class="line"></span><br><span class="line">def chi2_value(freq_table):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;计算卡方值&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    chi2, p, _, _ = chi2_contingency(freq_table)</span><br><span class="line">    <span class="built_in">return</span> chi2</span><br><span class="line"></span><br><span class="line">def chimerge(data, target, max_bins=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    基于卡方分裂的离散化方法（ChiMerge）</span></span><br><span class="line"><span class="string">    :param data: 连续特征（NumPy 数组或 Pandas Series）</span></span><br><span class="line"><span class="string">    :param target: 目标变量（分类变量）</span></span><br><span class="line"><span class="string">    :param max_bins: 期望的最大分箱数</span></span><br><span class="line"><span class="string">    :return: 分箱边界</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">df</span> = pd.DataFrame(&#123;<span class="string">&#x27;feature&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;)</span><br><span class="line">    <span class="built_in">df</span> = df.sort_values(by=<span class="string">&#x27;feature&#x27;</span>).reset_index(drop=True)  <span class="comment"># 按特征值排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每个特征值下的类别频次</span></span><br><span class="line">    freq_table = df.groupby(<span class="string">&#x27;feature&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].value_counts().unstack().fillna(0)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始边界（每个值单独作为一个区间）</span></span><br><span class="line">    bins = list(freq_table.index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(bins) &gt; max_bins:  <span class="comment"># 直到达到最大分箱数</span></span><br><span class="line">        min_chi2 = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        min_index = -1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有相邻区间，找到卡方值最小的区间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bins) - 1):</span><br><span class="line">            merged_table = freq_table.loc[[bins[i], bins[i + 1]]].<span class="built_in">sum</span>(axis=0).values.reshape(2, -1)</span><br><span class="line">            chi2 = chi2_value(merged_table)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> chi2 &lt; min_chi2:  <span class="comment"># 找到最小的卡方值</span></span><br><span class="line">                min_chi2 = chi2</span><br><span class="line">                min_index = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并卡方值最小的区间</span></span><br><span class="line">        bins[min_index] = (bins[min_index] + bins[min_index + 1]) / 2</span><br><span class="line">        bins.pop(min_index + 1)  <span class="comment"># 删除合并的区间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50  <span class="comment"># 生成随机数</span></span><br><span class="line">target = np.random.choice([0, 1], size=100)  <span class="comment"># 二分类目标变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分箱边界</span></span><br><span class="line">bin_edges = chimerge(data, target, max_bins=4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方分裂后的分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二</strong><br><strong>使用optbinning库</strong></p>
<p>如果不想手动实现，可以使用 optbinning 库，它可以进行最优分箱（Optimal Binning），内部使用 ChiMerge 或者 Decision Tree 进行离散化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from optbinning import OptimalBinning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50</span><br><span class="line">target = np.random.choice([0, 1], size=100)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 OptimalBinning 进行卡方离散化</span></span><br><span class="line">optb = OptimalBinning(name=<span class="string">&quot;feature&quot;</span>, dtype=<span class="string">&quot;numerical&quot;</span>, solver=<span class="string">&quot;cp&quot;</span>)</span><br><span class="line">optb.fit(data, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取分箱边界</span></span><br><span class="line">bin_edges = optb.splits</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;自动计算的分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>ChiMerge的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>保持类别信息：确保离散化后不同类别仍然可以区分，提高模型效果。<br>自动确定最优分箱：基于卡方值合并区间，减少信息损失。<br>避免过度离散化：不像等宽分箱或等频分箱可能导致信息丢失。</p>
<p>❌ 缺点<br>计算量较大：随着样本数增加，计算卡方统计量的复杂度会增加。<br>依赖类别变量：只能用于分类任务，如果目标变量是连续值，需要先离散化。<br>需要调整超参数：最大分箱数 max_bins 需要根据数据调优。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用ChiMerge</p>

    </div>
    <div class="notel-content">
      <p>分类任务：目标变量是离散类别（如二分类、多分类）。<br>决策树模型：离散化后可以提升决策树模型的可解释性。<br>数据量较大：对于大规模数据，可通过 optbinning 等库加速处理。</p>

    </div>
  </div>

<p>ChiMerge 离散化适用于分类任务，可以在决策树、朴素贝叶斯等模型中提升效果。对于回归任务，可以考虑 KMeans 或 等宽&#x2F;等频分箱。</p>
<h2 id="1R离散法"><a href="#1R离散法" class="headerlink" title="1R离散法"></a>1R离散法</h2><p>1R 就是 1-rule，称为1 规则，也就是产生一层的决策树，用一个规则集的形式，只在某个特定的属性上进行测试。1R是一个简单廉价的方法，但却常常能得到令人吃惊的准确率。<br>它的核心思想是：<br>将连续特征划分为多个区间，然后<br>寻找能够最好地预测目标变量（类别）的区间划分。</p>
<p>1R 方法的基本步骤如下：<br>对特征值排序。<br>尝试不同的分箱方法（等宽、等频、信息增益等），并计算分类错误率。<br>选择错误率最低的分箱方式作为最终的离散化方式。</p>
<p><strong>方法一</strong><br><strong>手动实现</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">def one_r_discretization(data, target, max_bins=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    基于 1R 规则的离散化方法</span></span><br><span class="line"><span class="string">    :param data: 连续特征 (NumPy 数组或 Pandas Series)</span></span><br><span class="line"><span class="string">    :param target: 目标变量 (分类变量)</span></span><br><span class="line"><span class="string">    :param max_bins: 期望的最大分箱数</span></span><br><span class="line"><span class="string">    :return: 最优分箱边界</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">df</span> = pd.DataFrame(&#123;<span class="string">&#x27;feature&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;)</span><br><span class="line">    <span class="built_in">df</span> = df.sort_values(by=<span class="string">&#x27;feature&#x27;</span>).reset_index(drop=True)  <span class="comment"># 按特征值排序</span></span><br><span class="line"></span><br><span class="line">    best_bins = None</span><br><span class="line">    best_error = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试不同分箱方式</span></span><br><span class="line">    <span class="keyword">for</span> bins <span class="keyword">in</span> range(2, max_bins + 1):</span><br><span class="line">        <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>] = pd.cut(<span class="built_in">df</span>[<span class="string">&#x27;feature&#x27;</span>], bins=bins, labels=False)  <span class="comment"># 进行分箱</span></span><br><span class="line">        bin_stats = df.groupby(<span class="string">&#x27;bin&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].agg(lambda x: x.value_counts().index[0])  <span class="comment"># 每个分箱内占比最高的类别</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算错误率</span></span><br><span class="line">        <span class="built_in">df</span>[<span class="string">&#x27;pred&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>].map(bin_stats)</span><br><span class="line">        error_rate = (<span class="built_in">df</span>[<span class="string">&#x27;pred&#x27;</span>] != <span class="built_in">df</span>[<span class="string">&#x27;target&#x27;</span>]).mean()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择错误率最低的分箱方案</span></span><br><span class="line">        <span class="keyword">if</span> error_rate &lt; best_error:</span><br><span class="line">            best_error = error_rate</span><br><span class="line">            best_bins = <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> best_bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50  <span class="comment"># 生成随机数</span></span><br><span class="line">target = np.random.choice([0, 1], size=100)  <span class="comment"># 目标变量（0 或 1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分箱边界</span></span><br><span class="line">bin_edges = one_r_discretization(data, target, max_bins=4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1R 规则下的最佳分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二</strong><br><strong>使用KBinsDiscretizer</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import KBinsDiscretizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">data = data.reshape(-1, 1)  <span class="comment"># 需要转换为 2D 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用监督式分箱</span></span><br><span class="line">discretizer = KBinsDiscretizer(n_bins=4, encode=<span class="string">&#x27;ordinal&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">binned_data = discretizer.fit_transform(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1R 近似分箱结果:&quot;</span>, np.unique(binned_data))</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>1R方法的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>监督式分箱：保留目标变量信息，减少信息损失。<br>简单易懂：规则明确，适合初步数据探索。<br>适用于分类任务：尤其适用于决策树、朴素贝叶斯等分类模型。</p>
<p>❌ 缺点<br>计算复杂度较高：需要尝试多个分箱方案，计算错误率。<br>可能过拟合：如果 max_bins 过大，可能导致分箱过多，导致模型过拟合。<br>仅适用于分类任务：如果目标变量是连续值，需要先进行离散化。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用1R离散化？</p>

    </div>
    <div class="notel-content">
      <p>分类任务（目标变量是离散类别，如 0&#x2F;1 或 A&#x2F;B&#x2F;C）。<br>数据探索：快速找到能够划分类别的最优分箱方式。<br>决策树建模：如 CART、ID3、C4.5 等模型。</p>

    </div>
  </div>

<h2 id="二值化离散法"><a href="#二值化离散法" class="headerlink" title="二值化离散法"></a>二值化离散法</h2><p>二值化离散法是一种简单且常用的离散化方法，它的基本思想是 将连续变量转换为两个类别（0 和 1），即：<br>小于某个阈值的设为 0<br>大于等于某个阈值的设为 1</p>
<p>这种方法特别适用于需要转换成 布尔值（Boolean） 的场景，如 信用评分、风险预测 或 神经网络中的二元特征输入。</p>
<p><strong>方法一</strong><br><strong>手动二值化</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(10) * 10 + 50  <span class="comment"># 生成 10 个均值为 50 的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定阈值（如50）</span></span><br><span class="line">threshold = 50</span><br><span class="line">binarized_data_fixed = (data &gt;= threshold).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值二值化</span></span><br><span class="line">threshold_mean = np.mean(data)</span><br><span class="line">binarized_data_mean = (data &gt;= threshold_mean).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中位数二值化</span></span><br><span class="line">threshold_median = np.median(data)</span><br><span class="line">binarized_data_median = (data &gt;= threshold_median).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 75% 分位数二值化</span></span><br><span class="line">threshold_percentile = np.percentile(data, 75)</span><br><span class="line">binarized_data_percentile = (data &gt;= threshold_percentile).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;Original Data&#x27;</span>: data,</span><br><span class="line">    <span class="string">&#x27;Fixed Threshold&#x27;</span>: binarized_data_fixed,</span><br><span class="line">    <span class="string">&#x27;Mean Threshold&#x27;</span>: binarized_data_mean,</span><br><span class="line">    <span class="string">&#x27;Median Threshold&#x27;</span>: binarized_data_median,</span><br><span class="line">    <span class="string">&#x27;Percentile Threshold&#x27;</span>: binarized_data_percentile</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>
<p><strong>方法二</strong><br><strong>使用 sklearn 进行二值化</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import Binarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定固定阈值</span></span><br><span class="line">binarizer = Binarizer(threshold=50)  <span class="comment"># 以50为阈值</span></span><br><span class="line">binarized_data = binarizer.fit_transform(data.reshape(-1, 1))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二值化后的数据:\n&quot;</span>, binarized_data.flatten())</span><br></pre></td></tr></table></figure></div>

<p><strong>方法三</strong><br><strong>监督式二值化（基于决策树）</strong></p>
<p>如果有分类标签 Y，可以使用决策树来学习最佳的二值化阈值：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设目标变量 Y</span></span><br><span class="line">target = np.random.choice([0, 1], size=len(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练决策树</span></span><br><span class="line">tree = DecisionTreeClassifier(max_depth=1)  <span class="comment"># 只允许一层分裂</span></span><br><span class="line">tree.fit(data.reshape(-1, 1), target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最优的分裂阈值</span></span><br><span class="line">optimal_threshold = tree.tree_.threshold[0]</span><br><span class="line">binarized_data_tree = (data &gt;= optimal_threshold).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;决策树选择的最优二值化阈值: &#123;optimal_threshold&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基于决策树的二值化结果:&quot;</span>, binarized_data_tree)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用二值化？</p>

    </div>
    <div class="notel-content">
      <p>✅ 适用场景<br>逻辑回归或朴素贝叶斯模型（需要布尔特征）。<br>信用评分、欺诈检测（例如：收入是否高于某个值？）。<br>生物信息学（例如：基因表达水平是否超过某个阈值？）。<br>特征筛选（减少噪声，提高模型可解释性）。<br>规则挖掘（如 Apriori 算法）（将数据转换为 0&#x2F;1 格式）。</p>
<p>❌ 不适用场景<br>信息损失严重：如果数据本身具有重要的连续性信息（如温度、房价），二值化可能会损失过多信息。<br>非布尔场景：如果数据有多个类别，建议使用多级离散化（如分箱）。</p>

    </div>
  </div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP介绍及其创建使用</title>
    <url>/zhihaojiang.github.io/2025/03/30/20250330MCP%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MCP是什么"><a href="#MCP是什么" class="headerlink" title="MCP是什么"></a>MCP是什么</h2><p>MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 于 2024 年 11 月推出的一种开放标准协议，旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信方式。​<br><strong>Model Context Protocol (MCP)</strong><br>MCP 是一个标准协议，就像给 AI 大模型装了一个 “万能接口”，让 AI 模型能够与不同的数据源和工具进行无缝交互。它就像 USB-C 接口一样，提供了一种标准化的方法，将 AI 模型连接到各种数据源和工具。<br>MCP 旨在替换碎片化的 Agent 代码集成，从而使 AI 系统更可靠，更有效。通过建立通用标准，服务商可以基于协议来推出它们自己服务的 AI 能力，从而支持开发者更快的构建更强大的 AI 应用。开发者也不需要重复造轮子，通过开源项目可以建立强大的 AI Agent 生态。<br>MCP 的核心概念包括：</p>
<ol>
<li>上下文共享：​应用程序可以通过 MCP 向模型提供所需的上下文信息，如文件内容、数据库记录等，增强模型的理解和生成能力。</li>
<li>工具暴露：​MCP 允许应用程序将功能（如文件读写、API 调用）暴露给模型，模型可以调用这些工具完成复杂任务。​</li>
<li>可组合的工作流：​开发者可以利用 MCP 集成多个服务和组件，构建灵活、可扩展的 AI 工作流。​</li>
<li>安全性：​通过本地服务器运行，MCP 避免将敏感数据上传至第三方平台，确保数据隐私。 ​</li>
</ol>
<p>MCP 的架构主要由以下组件组成：</p>
<ol>
<li>MCP 主机（Host）：​如 Claude Desktop、IDE 或其他 AI 工具，即大模型的应用。​</li>
<li>MCP 客户端（Client）：​在主机应用内的连接器，负责与 MCP 服务器建立连接。​</li>
<li>MCP 服务器（Server）：​实现 MCP 协议的程序，提供特定功能或数据资源，供客户端访问。​</li>
<li>远程服务：​如 Slack、GitHub API 等，MCP 服务器可以连接的外部服务。 ​</li>
</ol>
<p>通过 MCP，AI 模型可以直接与数据源建立标准化的连接，避免了为每个新数据源定制对接方案的繁琐过程，从而实现真正的互联互通。</p>
<p>MCP（Model Context Protocol）允许你定义和暴露自定义的函数（工具），让大模型调用这些工具来完成特定任务。例如，你可以构建一个函数，让模型查询数据库、读取文件、调用 API，甚至执行本地计算。</p>
<h2 id="MCP-让模型调用工具的方式"><a href="#MCP-让模型调用工具的方式" class="headerlink" title="MCP 让模型调用工具的方式"></a>MCP 让模型调用工具的方式</h2><p><strong>定义一个工具（函数）</strong><br>在本地或远程服务器上编写一个 API 或函数，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def get_weather(city):</span><br><span class="line">    <span class="comment"># 这里可以调用真实的天气 API</span></span><br><span class="line">    <span class="built_in">return</span> f<span class="string">&quot;&#123;city&#125; 当前气温 25°C，晴天&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>通过 MCP 暴露该工具</strong><br>通过 MCP 让大模型知道这个工具的存在，并允许它调用。例如，在 Claude 或其他支持 MCP 的环境中，模型可以动态调用你的 get_weather(city) 函数。<br><strong>模型调用工具</strong><br>当用户询问「北京的天气如何？」时，模型可以自动调用 get_weather(“北京”)，并将结果返回给用户，而不是依赖自身训练的数据。</p>
<h2 id="创建并使用的流程"><a href="#创建并使用的流程" class="headerlink" title="创建并使用的流程"></a>创建并使用的流程</h2><p>以get_weather为例<br>我们首先创建一个.py文件叫weather<br>在文件中输入下述代码</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from mcp import MCPServer, tool</span><br><span class="line"></span><br><span class="line">class WeatherServer(MCPServer):</span><br><span class="line">    @tool</span><br><span class="line">    def get_weather(self, city: str) -&gt; str:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取指定城市的天气信息。</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 调用天气 API 获取数据</span></span><br><span class="line">        api_key = <span class="string">&#x27;您的API密钥&#x27;</span></span><br><span class="line">        response = requests.get(f<span class="string">&#x27;http://api.weatherapi.com/v1/current.json?key=&#123;api_key&#125;&amp;q=&#123;city&#125;&amp;lang=zh&#x27;</span>)</span><br><span class="line">        data = response.json()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;error&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">            <span class="built_in">return</span> f<span class="string">&quot;无法获取&#123;city&#125;的天气信息。&quot;</span></span><br><span class="line">        weather = data[<span class="string">&#x27;current&#x27;</span>][<span class="string">&#x27;condition&#x27;</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">        temp_c = data[<span class="string">&#x27;current&#x27;</span>][<span class="string">&#x27;temp_c&#x27;</span>]</span><br><span class="line">        <span class="built_in">return</span> f<span class="string">&quot;&#123;city&#125;当前天气：&#123;weather&#125;，气温：&#123;temp_c&#125;°C。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    server = WeatherServer()</span><br><span class="line">    server.run()</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>记得安装必要的库</p>

    </div>
    <div class="notel-content">
      <p>pip install mcp-server</p>

    </div>
  </div>
<p>这样，MCP工具就做好了</p>
<p>之后，我们要将这个工具告诉AI<br>打开一个支持MCP的AI软件或网站 这里我使用vs code中的cline插件<br>在插件设置中找到MCP Servers -&gt; installed -&gt; Configure MCP Server 点击<br>会进入到一个叫cline_mcp_settings.json的文档<br>里面应该是这样的</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在mcpServers中插入你写的工具</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;weather&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;command&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;--directory&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/Volumes/HIKSEMI/mcp_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;run&quot;</span>,</span><br><span class="line">        <span class="string">&quot;weather.py&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>记得安装必要的库</p>

    </div>
    <div class="notel-content">
      <p>“weather”: { -&gt; 这个是你的MCP工具的名字 可以自己随便取</p>
<p>“command”: “python” -&gt;这个是告诉他使用 python 命令来运行 Python 解释器 启动服务器</p>
<p>“args”: [<br>        “–directory”, -&gt;这个选项通常用来告诉服务器在哪个路径下查找需要的资源 或者在该目录下运行服务器<br>        “&#x2F;Volumes&#x2F;HIKSEMI&#x2F;mcp_server”, -&gt;这是指定你weather.py的路径<br>        “run”, -&gt; 这个是告诉程序去执行接下来的操作 即运行指定的Python脚本<br>        “weather.py” -&gt; 这是要执行的 Python 脚本的名称</p>

    </div>
  </div>

<p>保存好后会在下面看见你的MCP工具已经启用了 在向大模型询问天气时 他会优先查询是否有可用的MCP工具 并按照对应的格式给出答复</p>
]]></content>
      <categories>
        <category>科技</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MCP</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>字母在字符串中的百分比</title>
    <url>/zhihaojiang.github.io/2025/03/31/20250331%E5%AD%97%E6%AF%8D%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “foobar”, letter &#x3D; “o”<br>输出：33<br>解释：<br>等于字母 ‘o’ 的字符在 s 中占到的百分比是 2 &#x2F; 6 * 100% &#x3D; 33% ，向下取整，所以返回 33 。<br>示例 2：</p>
<p>输入：s &#x3D; “jjjj”, letter &#x3D; “k”<br>输出：0<br>解释：<br>等于字母 ‘k’ 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 由小写英文字母组成<br>letter 是一个小写英文字母</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">方法一</a></li><li class="tab"><a class="#first-unique-name-2">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>正常思路</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def percentageLetter(self, s, letter):</span><br><span class="line">        n = len(s)  <span class="comment">#把长度赋值给n</span></span><br><span class="line">        count = 0   <span class="comment">#初始化统计个数变量</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> s: <span class="comment">#从字符串第一个字符开始循环</span></span><br><span class="line">            <span class="keyword">if</span> index == letter: <span class="comment">#如果s的下标index和我们要找的字符letter相同</span></span><br><span class="line">                count += 1  <span class="comment">#+1</span></span><br><span class="line">        <span class="built_in">return</span> 100 * count // n <span class="comment">#个数比总数在乘以100%就得到了其百分比</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-unique-name-2"><p><strong>python库实现</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> class Solution:</span><br><span class="line">    def percentageLetter(self, s: str, letter: str) -&gt; int:</span><br><span class="line">        <span class="built_in">return</span> s.count(letter) * 100 // len(s)  <span class="comment">#主要用到了count()函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#作者：灵茶山艾府</span></span><br><span class="line"><span class="comment">#链接：https://leetcode.cn/problems/percentage-of-letter-in-string/solutions/#1510439/ku-han-shu-mo-ni-by-endlesscheng-fqad/</span></span><br><span class="line"><span class="comment">#来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">#著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure></div></div></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>λ演算</title>
    <url>/zhihaojiang.github.io/2025/04/01/20250401%CE%BB%E6%BC%94%E7%AE%97/</url>
    <content><![CDATA[<p>在B站看到了有人讲解λ演算 很感兴趣 于是去了解了一下<br>原视频：<a class="link"   href="https://www.youtube.com/watch?v=RcVA8Nj6HEo&t=44s" >https://www.youtube.com/watch?v=RcVA8Nj6HEo&amp;t=44s<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>原视频很精彩 图文描述 我也是看了这个视频写的 推荐观看</p>
<h2 id="什么是λ演算"><a href="#什么是λ演算" class="headerlink" title="什么是λ演算"></a>什么是λ演算</h2><p>λ演算（Lambda Calculus）是一种用于研究函数定义、函数应用和递归的数学逻辑系统 由阿隆佐·丘奇（Alonzo Church）在 1930 年代提出。它是计算理论的基础之一 并在编程语言的设计中发挥了重要作用 特别是对函数式编程语言（如 Haskell、Lisp 和 ML）有深远的影响 </p>
<p>诶 这里学过python的人肯定想到了 python中有个lambda表达式 是不是和这个λ演算相关呢<br>没错 Python 中的 lambda 表达式确实与 λ（Lambda）演算有关系 但它只是 λ演算的一个简单应用 并没有完全实现 λ演算的全部概念 这里不过多叙述 只是告诉大家他们之间确实有关系</p>
<h2 id="λ演算的基本概念"><a href="#λ演算的基本概念" class="headerlink" title="λ演算的基本概念"></a>λ演算的基本概念</h2><p>λ演算由三种基本表达式组成：</p>
<ul>
<li>变量：例如 x、y，代表某个值。</li>
<li>λ抽象（Lambda Abstraction）：用于定义匿名函数，例如 λx.x+1 表示“输入 x，返回 x+1”</li>
<li>函数应用（Function Application）：用于调用函数，例如 (λx.x+1) 2，表示将 2 代入 λx.x+1，结果为 3</li>
</ul>
<h3 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h3><p>在λ演算中 主要有三类样式：</p>
<ul>
<li>括号：()</li>
<li>变量：x, y, z…</li>
<li>“λ”和”.”:λ和.总是成对出现</li>
</ul>
<p>这样 我们就有了三个模版：</p>
<ul>
<li>(_ _)</li>
<li>a</li>
<li>(λa._)</li>
</ul>
<p>这里的下划线可以填入上述任意模块 a是一个变量 我们可以像搭积木一样进行构造<br>例如：<br>((λa.y)(λx.(λc.e)))<br>并且 这些变量也可以是一个函数</p>
<h3 id="结合代码理解"><a href="#结合代码理解" class="headerlink" title="结合代码理解"></a>结合代码理解</h3><p>上述的a其实就是一个变量 并且他也可以看成一个函数<br>现在我们重点看看( _ _ ) 和 ( λa._ )</p>
<p>(_ _)可以理解为</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以(ab)为例</span></span><br><span class="line"><span class="comment">#将左边的a看成一个函数</span></span><br><span class="line"><span class="comment">#右边的b就是这个函数a的输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了方便理解 我们定义一个函数 叫a</span></span><br><span class="line">def a(x):</span><br><span class="line">    <span class="built_in">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment">#先别管变量output 右边的a(b)等价于λ演算中的(ab)</span></span><br><span class="line">output = a(b)</span><br></pre></td></tr></table></figure></div>

<p>(λa._)可以理解为</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以(λx.y)为例</span></span><br><span class="line">def fun(x):</span><br><span class="line">    <span class="built_in">return</span> y</span><br></pre></td></tr></table></figure></div>

<p>这些就是λ表达式的内容</p>
<h2 id="λ图"><a href="#λ图" class="headerlink" title="λ图"></a>λ图</h2><p>有很多种可视化λ图</p>
<ol>
<li>Tromp图表：<a class="link"   href="https://tromp.github.io/cl/diagrams.html" >https://tromp.github.io/cl/diagrams.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>David C Keenan的λ演算图形符号：<a class="link"   href="https://dkeenan.com/Lambda/" >https://dkeenan.com/Lambda/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>de Bruijn索引：<a class="link"   href="https://en.wikipedia.org/wiki/De_Bruijn_index" >https://en.wikipedia.org/wiki/De_Bruijn_index<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </li>
<li>Vex（Wayne Citrin，Richard Hall，Benjamin Zorn）：<a class="link"   href="https://www.researchgate.net/publication/2726047_Programming_with_Visual_Expressions" >https://www.researchgate.net/publication/2726047_Programming_with_Visual_Expressions<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </li>
<li>视觉λ演算（Viktor Massalõgin）：<a class="link"   href="https://github.com/bntre/visual-lambda" >https://github.com/bntre/visual-lambda<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
<h2 id="λ演算的计算规则"><a href="#λ演算的计算规则" class="headerlink" title="λ演算的计算规则"></a>λ演算的计算规则</h2><p>λ演算主要有三个计算规则：</p>
<ol>
<li>α-变换（Alpha Conversion）</li>
<li>β-规约（Beta Reduction）</li>
<li>η-变换（Eta Conversion）</li>
</ol>
<h3 id="α-变换（Alpha-Conversion）"><a href="#α-变换（Alpha-Conversion）" class="headerlink" title="α-变换（Alpha Conversion）"></a>α-变换（Alpha Conversion）</h3><p>简单来说就是变量重命名</p>
<blockquote>
<p>λx.x &#x3D; λy.y</p>
</blockquote>
<p>只要不影响表达式的意义 就可以更改变量名称 就像你可以随意地取变量名</p>
<h3 id="β-规约"><a href="#β-规约" class="headerlink" title="β-规约"></a>β-规约</h3><p>函数应用的计算<br>我们来看这样的一个式子：</p>
<blockquote>
<p>((λx.x+2)3)</p>
</blockquote>
<p>根据前文的理解<br>我们逐步进行分析<br>首先来看内层的(λx.x+2)<br>这个意思相当于是 我们定义个一个函数叫x 函数的返回值是x + 2</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#(λx.x+2)</span></span><br><span class="line">def x(x):</span><br><span class="line">    <span class="built_in">return</span> x + 2</span><br></pre></td></tr></table></figure></div>

<p>接下来我们看外层 还记得前面说的</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>引用</p>

    </div>
    <div class="notel-content">
      <p>以(ab)为例<br>将左边的a看成一个函数<br>右边的b就是这个函数a的输入</p>

    </div>
  </div>
<p>现在把刚才的(λx.x+2)看成a 把3看成b</p>
<p>于是 ((λx.x+2)3)就可以用python写成</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def x(x):</span><br><span class="line">    <span class="built_in">return</span> x + 2</span><br><span class="line">    </span><br><span class="line">output = x(3)</span><br></pre></td></tr></table></figure></div>
<p>其用数学符号就是</p>
<blockquote>
<p>3 + 2</p>
</blockquote>
<p>综上 ((λx.x+2)3)等价于 3 + 2</p>
<h3 id="η-变换"><a href="#η-变换" class="headerlink" title="η-变换"></a>η-变换</h3><p>函数等价转换<br>先给出定义</p>
<blockquote>
<p>λx.fx 等价于 f</p>
</blockquote>
<p>只要 f 在所有输入 x 上都保持不变 那么 λx. f x 和 f 是等价的<br>什么意思呢<br>以f(x) &#x3D; x + 3为例</p>
<p>假设有f(x) &#x3D; x + 3<br>在 λ 形式下 他可以表示为</p>
<blockquote>
<p>f &#x3D; λx. x + 1</p>
</blockquote>
<p>那么 λx.fx 等价于 f 即</p>
<blockquote>
<p>λx. (λx. x + 1) x  ≡  λx. x + 1</p>
</blockquote>
<h2 id="自由变量与束缚变量"><a href="#自由变量与束缚变量" class="headerlink" title="自由变量与束缚变量"></a>自由变量与束缚变量</h2><p>定义</p>
<ul>
<li><p>束缚变量（Bound Variable）<br>如果一个变量 x 出现在 λx.M 这样的函数定义中 并且 x 是由 λx 绑定的 则 x 是束缚变量<br>简单理解：变量被 λ 绑定 就称为束缚变量 </p>
</li>
<li><p>自由变量（Free Variable）<br>如果一个变量 x 在 λ 表达式中出现 但没有被任何 λ 绑定 则 x 是自由变量<br>简单理解：变量没有被 λ 绑定 它就是自由变量</p>
</li>
</ul>
<h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">λx. y  // 变量 y 是自由变量</span><br></pre></td></tr></table></figure></div>

<h3 id="束缚变量"><a href="#束缚变量" class="headerlink" title="束缚变量"></a>束缚变量</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">λx. x  // 变量 x 是束缚变量</span><br></pre></td></tr></table></figure></div>

<h2 id="组合子"><a href="#组合子" class="headerlink" title="组合子"></a>组合子</h2><p>在λ演算中，组合子（Combinator） 是指 没有自由变量 的 λ 表达式 也就是说 组合子是 只包含束缚变量 的 λ 表达式 它们是纯粹的函数抽象 不依赖于外部环境 因此它们可以被认为是“自给自足”的函数 </p>
<p>组合子 之所以叫这个名字 是因为它们不依赖外部的变量或环境 只能依赖自己定义的参数 并且可以通过组合多个组合子来构建复杂的计算 组合子本质上是 λ 演算中的基础构建模块 类似于函数式编程中的高阶函数</p>
<h3 id="恒等组合子"><a href="#恒等组合子" class="headerlink" title="恒等组合子"></a>恒等组合子</h3><p>恒等组合子就是一个接受一个参数并返回这个参数的组合子 它的定义非常简单：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">I = λx. x</span><br></pre></td></tr></table></figure></div>
<p>作用：恒等组合子返回输入参数本身 不做任何改变</p>
<blockquote>
<p>I 5 → 5</p>
</blockquote>
<h3 id="K-组合子"><a href="#K-组合子" class="headerlink" title="K 组合子"></a>K 组合子</h3><p>K 组合子（又叫 K 函数或常量函数）接受两个参数 但只返回第一个参数 它的定义是：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">K = λx. λy. x</span><br></pre></td></tr></table></figure></div>
<p>作用：返回第一个参数 忽略第二个参数</p>
<blockquote>
<p>K 5 10 → 5</p>
</blockquote>
<p>在这个例子中 K 5 返回的是一个函数 λy. 5 再与任何第二个参数（比如 10）结合时 结果依然是 5</p>
<h3 id="S-组合子"><a href="#S-组合子" class="headerlink" title="S 组合子"></a>S 组合子</h3><p>S 组合子（又叫 S 函数）比较复杂 接受三个参数 并执行一些组合操作 它的定义如下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">S = λx. λy. λz. (x z) (y z)</span><br></pre></td></tr></table></figure></div>
<p>作用：S 组合子将输入的两个函数 x 和 y 应用于相同的参数 z 并将结果作为两个函数的输出</p>
<blockquote>
<p>S (λx. x + 1) (λx. x * 2) 3 → (λx. x + 1) 3  (λx. x * 2) 3<br>                              → 3 + 1    3 * 2<br>                              → 4        6</p>
</blockquote>
<p>S 组合子可以用于组合多个函数，使得它们的输入可以共享。</p>
<h3 id="组合子的性质"><a href="#组合子的性质" class="headerlink" title="组合子的性质"></a>组合子的性质</h3><p>组合子通常具有一些有用的性质 它们可以与其他组合子进行组合 以实现更加复杂的计算 几个重要的性质包括：</p>
<ol>
<li><p>函数应用<br>组合子是纯粹的 λ 演算表达式 它们的行为仅依赖于传入的参数 可以通过函数应用来将它们的计算结果传递给其他组合子 进一步构建复杂的计算</p>
</li>
<li><p>无外部依赖<br>组合子是完全自足的 它们的定义仅依赖于它们自己内部的参数 不需要从外部环境引入其他变量 这使得它们在编程语言和计算机科学中非常重要 尤其是在函数式编程中</p>
</li>
<li><p>高阶函数<br>组合子本质上是高阶函数（Higher-Order Function）它们可以作为输入传递给其他函数 或者返回作为结果 例如，S 组合子通过两个输入函数生成新的函数 具有高度的抽象能力</p>
</li>
</ol>
<h2 id="λ演算的作用"><a href="#λ演算的作用" class="headerlink" title="λ演算的作用"></a>λ演算的作用</h2><p>说了这么多 大家应该会进行一些关于λ演算的计算了 可λ演算有什么用呢 感觉就是换个抽象的形式进行计算<br>其实λ演算本质上是换了一种抽象的方式来进行计算 但它的意义远不止于此</p>
<h3 id="计算理论的基础"><a href="#计算理论的基础" class="headerlink" title="计算理论的基础"></a>计算理论的基础</h3><p>λ演算与图灵机（Turing Machine）一样 是计算理论的两大核心模型之一 它们都能表达可计算函数 但λ演算采用的是纯粹的函数变换 而图灵机基于状态和存储</p>
<ul>
<li>通过 λ演算 可以定义所有可计算的函数 因此它是图灵完备的</li>
<li>计算机科学家用它来研究可计算性、算法复杂度等问题</li>
</ul>
<h3 id="影响现代编程语言"><a href="#影响现代编程语言" class="headerlink" title="影响现代编程语言"></a>影响现代编程语言</h3><p>λ演算是函数式编程的理论基础 影响了 Haskell、Lisp、ML、Scala、JavaScript（匿名函数、箭头函数）、Python（Lambda 表达式）等编程语言 例如</p>
<ul>
<li>匿名函数（Lambda 表达式）</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">add = lambda x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(2, 3))  <span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>高阶函数（函数可以作为参数传递）</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def apply_func(f, x):</span><br><span class="line">    <span class="built_in">return</span> f(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(apply_func(lambda x: x * 2, 10))  <span class="comment"># 输出 20</span></span><br></pre></td></tr></table></figure></div>

<p>现代语言的 闭包（Closure）、惰性求值、纯函数 等概念都源于 λ演算</p>
<h3 id="形式化数学-逻辑推理"><a href="#形式化数学-逻辑推理" class="headerlink" title="形式化数学 &amp; 逻辑推理"></a>形式化数学 &amp; 逻辑推理</h3><p>λ演算被用作数学逻辑的基础，特别是在构造主义数学和类型理论中。例如：</p>
<ul>
<li>Curry-Howard 对应：λ演算中的函数和逻辑推理中的证明之间存在对应关系 程序可以被视为数学证明</li>
<li>依赖类型（Dependent Types）：Coq、Agda 这些数学证明工具都基于λ演算的扩展形式</li>
</ul>
<h3 id="递归与无变量编程"><a href="#递归与无变量编程" class="headerlink" title="递归与无变量编程"></a>递归与无变量编程</h3><p>λ演算能够表示 递归，即使它本身没有显式的循环结构。例如，阶乘可以用 Y 组合子（Y Combinator）来实现：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">factorial = \f. \n. <span class="keyword">if</span> n == 0 <span class="keyword">then</span> 1 <span class="keyword">else</span> n * (f (n - 1))</span><br><span class="line">Y factorial 5   -- 计算 5!</span><br></pre></td></tr></table></figure></div>

<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p>λ演算提供了转换和简化代码的规则 例如：</p>
<ul>
<li>β-规约（函数应用） 可以减少计算步骤 优化执行效率</li>
<li>α-变换（变量重命名） 可避免变量名冲突</li>
<li>η-变换（函数简化） 可以减少不必要的函数包装 提高性能</li>
</ul>
<p>许多编译器（如 GHC Haskell、Scala、Lisp 解释器）都会用 λ演算作为中间表示（IR）帮助优化代码</p>
<h3 id="并发-分布式计算"><a href="#并发-分布式计算" class="headerlink" title="并发 &amp; 分布式计算"></a>并发 &amp; 分布式计算</h3><p>λ演算的无状态特性使其非常适用于并发计算和分布式系统 例如：</p>
<ul>
<li>MapReduce（Google 的大规模数据处理模型）依赖于 λ演算的映射与归约思想</li>
<li>Actor Model（Erlang、Akka）与函数式编程紧密相关 受λ演算启发</li>
</ul>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>解决智力问题</title>
    <url>/zhihaojiang.github.io/2025/04/01/20250401%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] &#x3D; [pointsi, brainpoweri] 。</p>
<p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p>
<p>比方说，给你 questions &#x3D; [[3, 2], [4, 3], [4, 4], [2, 5]] ：</p>
<ul>
<li>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</li>
<li>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。</li>
<li>请你返回这场考试里你能获得的 最高 分数。</li>
</ul>
<p>示例 1：</p>
<p>输入：questions &#x3D; [[3,2],[4,3],[4,4],[2,5]]<br>输出：5<br>解释：解决问题 0 和 3 得到最高分。</p>
<ul>
<li>解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</li>
<li>不能解决问题 1 和 2</li>
<li>解决问题 3 ：获得 2 分<br>总得分为：3 + 2 &#x3D; 5 。没有别的办法获得 5 分或者多于 5 分。<br>示例 2：</li>
</ul>
<p>输入：questions &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]]<br>输出：7<br>解释：解决问题 1 和 4 得到最高分。</p>
<ul>
<li>跳过问题 0</li>
<li>解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</li>
<li>不能解决问题 2 和 3</li>
<li>解决问题 4 ：获得 5 分<br>总得分为：2 + 5 &#x3D; 7 。没有别的办法获得 7 分或者多于 7 分。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这题需要决定在每个问题上是“解决”还是“跳过” 如果选择解决问题 i 我们将会获得 pointsi 的分数 但接下来的 brainpoweri 个问题会被跳过 如果我们选择跳过问题 i 则直接考虑下一个问题<br>目标是找到能获得的最高分数</p>
<p>使用动态规划<br>设dp[i]是从第i个问题开始 能获得最高分<br>对于每个问题 i 有两种选择</p>
<div class="tabs" id="tab-choice"><ul class="nav-tabs"><li class="tab active"><a class="#choice-1">选择一</a></li><li class="tab"><a class="#choice-2">选择二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="choice-1"><p><strong>解决问题i</strong></p>
<p>可以获得 pointsi 的分数 但需要跳过接下来的 brainpoweri 个问题 因此，总分数为：</p>
<blockquote>
<p>pointsi + dp[i + brainpoweri + 1]</p>
</blockquote>
<p>其中  i + brainpoweri + 1 是下一个可以解决的问题索引 如果其超出了数组范围 则 dp[i + brainpoweri + 1] &#x3D; 0</p></div><div class="tab-pane" id="choice-2"><p><strong>跳过问题i</strong></p>
<p> 不解决问题 i 直接考虑下一个问题 i+1 总分数为：<br> dp[i + 1]</p></div></div></div>

<p>因此 我们要选择两者的最大值</p>
<blockquote>
<p>dp[i] &#x3D; max(pointsi + dp[i + brainpoweri + 1],  dp[i + 1])</p>
</blockquote>
<p>当 i &gt;&#x3D; n（超出数组范围时）dp[i] &#x3D; 0<br>当 i + brainpoweri + 1 &gt;&#x3D; n dp[i + brainpoweri + 1] &#x3D; 0<br>因此最终结果为dp[0] 我们永远要从第一个问题开始才能能获得最高分</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def mostPoints(questions):</span><br><span class="line">    n = len(questions)</span><br><span class="line">    dp = [0] * (n + 1)  <span class="comment"># 初始化 dp 数组，长度为 n+1，dp[n] = 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从后往前填充 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - 1, -1, -1):</span><br><span class="line">        points, brainpower = questions[i]</span><br><span class="line">        j = i + brainpower + 1  <span class="comment"># 下一个可以解决的问题索引</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; n:</span><br><span class="line">            solved = points + dp[j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            solved = points  <span class="comment"># 如果 j 超出范围，则没有后续问题</span></span><br><span class="line">        </span><br><span class="line">        skipped = dp[i + 1]  <span class="comment"># 跳过当前问题的分数</span></span><br><span class="line">        </span><br><span class="line">        dp[i] = max(solved, skipped)  <span class="comment"># 取最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> dp[0]  <span class="comment"># 返回从第一个问题开始的最大分数</span></span><br></pre></td></tr></table></figure></div>

<p>怎么样 解决了你的智力问题吗^_^</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>有序三元组中的最大值 I</title>
    <url>/zhihaojiang.github.io/2025/04/02/20250402%E6%9C%89%E5%BA%8F%E4%B8%89%E5%85%83%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的整数数组 nums 。</p>
<p>请你从所有满足 i &lt; j &lt; k 的下标三元组 (i, j, k) 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 0 。</p>
<p>下标三元组 (i, j, k) 的值等于 (nums[i] - nums[j]) * nums[k] 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums &#x3D; [12,6,1,2,7]<br>输出：77<br>解释：下标三元组 (0, 2, 4) 的值是 (nums[0] - nums[2]) * nums[4] &#x3D; 77 。<br>可以证明不存在值大于 77 的有序下标三元组。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums &#x3D; [1,10,3,4,19]<br>输出：133<br>解释：下标三元组 (1, 2, 4) 的值是 (nums[1] - nums[2]) * nums[4] &#x3D; 133 。<br>可以证明不存在值大于 133 的有序下标三元组。 </p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums &#x3D; [1,2,3]<br>输出：0<br>解释：唯一的下标三元组 (0, 1, 2) 的值是一个负数，(nums[0] - nums[1]) * nums[2] &#x3D; -3 。因此，答案是 0 。</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">方法一</a></li><li class="tab"><a class="#first-unique-name-2">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>暴力枚举</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maximumTripletValue(self, nums):</span><br><span class="line">        n = len(nums)   <span class="comment">#把数组长度赋值给n</span></span><br><span class="line">        result = 0  <span class="comment">#初始化result</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment">#暴力枚举 3层for循环</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + 1,n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j + 1,n):</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] - nums[j]) * nums[k] &gt; result:</span><br><span class="line">                        result = (nums[i] - nums[j]) * nums[k]  <span class="comment">#找出最大值</span></span><br><span class="line">        <span class="keyword">if</span> result &lt; 0:  <span class="comment">#判断结果是否都为负数</span></span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> result</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-unique-name-2"><p><strong>贪心</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximumTripletValue(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res, imax, dmax = 0, 0, 0</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(res, dmax * nums[k])</span><br><span class="line">            dmax = max(dmax, imax - nums[k])</span><br><span class="line">            imax = max(imax, nums[k])</span><br><span class="line">        <span class="built_in">return</span> res</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/solutions/3610891/you-xu-san-yuan-zu-zhong-de-zui-da-zhi-i-y6zb/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></div></div></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习数据分析helper</title>
    <url>/zhihaojiang.github.io/2025/04/07/20250407%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90helper/</url>
    <content><![CDATA[<p>数据分析是一个循环迭代的过程，主要步骤如下：</p>
<ol>
<li>明确问题 ：定义目标和需求。</li>
<li>数据收集 ：获取相关数据。</li>
<li>数据清洗 ：处理缺失值、异常值等问题。</li>
<li>数据探索 ：理解数据特性。</li>
<li>特征工程 ：提取和优化特征。</li>
<li>模型选择与训练 ：构建和训练模型。</li>
<li>模型评估 ：验证模型性能。</li>
<li>结果解释与可视化 ：呈现分析结果。</li>
<li>部署与监控 ：应用到实际场景。</li>
<li>反馈与迭代 ：持续改进。</li>
</ol>
<h2 id="基本库"><a href="#基本库" class="headerlink" title="基本库"></a>基本库</h2><h3 id="最基础的库"><a href="#最基础的库" class="headerlink" title="最基础的库"></a>最基础的库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br></pre></td></tr></table></figure></div>

<h3 id="MacOS中文显示库"><a href="#MacOS中文显示库" class="headerlink" title="MacOS中文显示库"></a>MacOS中文显示库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">MacOS专用字体设置</span></span><br><span class="line"><span class="string">MacOS 系统中使用的中文字体路径</span></span><br><span class="line"><span class="string">适用于MacOS15版本</span></span><br><span class="line"><span class="string">可直接复制到代码中使用</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"><span class="comment"># 设置字体路径</span></span><br><span class="line">font_path = <span class="string">&#x27;/System/Library/Fonts/STHeiti Medium.ttc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载字体</span></span><br><span class="line">my_font = font_manager.FontProperties(fname=font_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = my_font.get_name()</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = False  <span class="comment"># 正确显示负号</span></span><br></pre></td></tr></table></figure></div>
<h3 id="画图库"><a href="#画图库" class="headerlink" title="画图库"></a>画图库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></div>

<h3 id="机器学习库"><a href="#机器学习库" class="headerlink" title="机器学习库"></a>机器学习库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line">from sklearn.metrics import mean_squared_error,r2_score</span><br></pre></td></tr></table></figure></div>
<p>sklearn库有很多 需要什么就import什么<br>不要直接import整个库</p>
<h2 id="浏览数据"><a href="#浏览数据" class="headerlink" title="浏览数据"></a>浏览数据</h2><h3 id="阅读数据"><a href="#阅读数据" class="headerlink" title="阅读数据"></a>阅读数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)  <span class="comment">#打开data.csv文件</span></span><br><span class="line">data.head   <span class="comment">#浏览前5行</span></span><br></pre></td></tr></table></figure></div>

<h3 id="查看数据信息"><a href="#查看数据信息" class="headerlink" title="查看数据信息"></a>查看数据信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">diabetes.describe() <span class="comment">#查看数据的统计信息 如最大值 最小值 均值等</span></span><br><span class="line">diabetes.info() <span class="comment">#查看数据信息 如字段名 字段类型</span></span><br></pre></td></tr></table></figure></div>

<h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><h3 id="通用-subplot-模板（可自定义图表类型）："><a href="#通用-subplot-模板（可自定义图表类型）：" class="headerlink" title="通用 subplot 模板（可自定义图表类型）："></a>通用 subplot 模板（可自定义图表类型）：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选出要绘图的列（比如数值型列，或你指定的一组列）</span></span><br><span class="line">plot_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> df.columns <span class="keyword">if</span> <span class="built_in">df</span>[col].dtype <span class="keyword">in</span> [<span class="string">&#x27;float64&#x27;</span>, <span class="string">&#x27;int64&#x27;</span>]]</span><br><span class="line"><span class="comment"># plot_cols = [&#x27;col1&#x27;, &#x27;col2&#x27;, &#x27;col3&#x27;]  # 或者你手动指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 subplot 的行列数（每行几个图）</span></span><br><span class="line">n_cols = 2</span><br><span class="line">n_rows = math.ceil(len(plot_cols) / n_cols)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子图网格</span></span><br><span class="line">fig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 5 * n_rows))</span><br><span class="line">axes = axes.flatten()  <span class="comment"># 保证是 1D，方便遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个列，绘制你想要的图</span></span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> enumerate(plot_cols):</span><br><span class="line">    ax = axes[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以自定义图表类型的部分（替换这里）</span></span><br><span class="line">    <span class="comment"># 示例：绘制箱线图</span></span><br><span class="line">    sns.boxplot(data=<span class="built_in">df</span>, x=<span class="string">&#x27;Country&#x27;</span>, y=col, ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 示例：绘制散点图（替换上面一行即可）</span></span><br><span class="line">    <span class="comment"># sns.scatterplot(data=df, x=&#x27;Country&#x27;, y=col, ax=ax)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 示例：绘制折线图（如果是时间序列）</span></span><br><span class="line">    <span class="comment"># sns.lineplot(data=df, x=&#x27;Date&#x27;, y=col, ax=ax)</span></span><br><span class="line"></span><br><span class="line">    ax.set_title(col)</span><br><span class="line">    ax.tick_params(axis=<span class="string">&#x27;x&#x27;</span>, rotation=45)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多余的子图</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+1, len(axes)):</span><br><span class="line">    fig.delaxes(axes[j])</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<h3 id="subplot-模板"><a href="#subplot-模板" class="headerlink" title="subplot 模板"></a>subplot 模板</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 2x2 的画布，共4个子图</span></span><br><span class="line">fig, axes = plt.subplots(2, 2, figsize=(12, 8))  <span class="comment"># 2行2列，画布大小可调</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第1个子图（左上）</span></span><br><span class="line">ax1 = axes[0, 0]</span><br><span class="line"><span class="comment"># TODO: 在这里画图，例如：ax1.plot(...) / sns.violinplot(ax=ax1, ...)</span></span><br><span class="line">ax1.set_title(<span class="string">&quot;子图 1：图的说明&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2个子图（右上）</span></span><br><span class="line">ax2 = axes[0, 1]</span><br><span class="line"><span class="comment"># TODO: 在这里画图</span></span><br><span class="line">ax2.set_title(<span class="string">&quot;子图 2：图的说明&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3个子图（左下）</span></span><br><span class="line">ax3 = axes[1, 0]</span><br><span class="line"><span class="comment"># TODO: 在这里画图</span></span><br><span class="line">ax3.set_title(<span class="string">&quot;子图 3：图的说明&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4个子图（右下）</span></span><br><span class="line">ax4 = axes[1, 1]</span><br><span class="line"><span class="comment"># TODO: 在这里画图</span></span><br><span class="line">ax4.set_title(<span class="string">&quot;子图 4：图的说明&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动调整子图间距，防止标题/坐标轴重叠</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>matlab库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = data[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">y = data[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<h3 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h3><p>相关性矩阵</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = data[<span class="string">&#x27;target&#x27;</span>]  <span class="comment">#填入要进行分析的结果列 通常为最后一列</span></span><br><span class="line">X = diabetes.drop([<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;others&#x27;</span>], axis=1) <span class="comment">#去除结果列和字符列（如果有）</span></span><br><span class="line"><span class="comment">#通常string类型的列（离散的特性）进行调整成int类型（连续化）即离散特征连续化</span></span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">correlation_matrix = pd.concat([X_train, y_train], axis=1).corr()</span><br><span class="line"></span><br><span class="line">sns.heatmap(correlation_matrix, annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h3><div class="tabs" id="tab-001"><ul class="nav-tabs"><li class="tab active"><a class="#001-1">删除含有缺失值的行</a></li><li class="tab"><a class="#001-2">使用均值填充缺失值</a></li><li class="tab"><a class="#001-3">使用众数填充缺失值</a></li><li class="tab"><a class="#001-4">使用分位数填充缺失值</a></li></ul><div class="tab-content"><div class="tab-pane active" id="001-1"><p><strong>删除含有缺失值的行</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">data_cleaned = df.dropna()</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="001-2"><p><strong>使用均值填充缺失值</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df_filled = df.fillna(df.mean())</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="001-3"><p><strong>使用众数填充缺失值</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [1, 2, 2, None, 4, 2], <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, None, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]&#125;</span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到每列的众数</span></span><br><span class="line">mode_A = <span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>].mode()[0]  <span class="comment"># 数值型列</span></span><br><span class="line">mode_B = <span class="built_in">df</span>[<span class="string">&#x27;B&#x27;</span>].mode()[0]  <span class="comment"># 类别型列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用众数填充缺失值</span></span><br><span class="line">df_filled_mode = df.fillna(&#123;<span class="string">&#x27;A&#x27;</span>: mode_A, <span class="string">&#x27;B&#x27;</span>: mode_B&#125;)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="001-4"><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;<span class="string">&#x27;C&#x27;</span>: [1, 2, 3, None, 5, 6, None]&#125;</span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算指定分位数</span></span><br><span class="line">quantile_25 = <span class="built_in">df</span>[<span class="string">&#x27;C&#x27;</span>].quantile(0.25)  <span class="comment"># 第一四分位数 (25%)</span></span><br><span class="line">quantile_50 = <span class="built_in">df</span>[<span class="string">&#x27;C&#x27;</span>].quantile(0.50)  <span class="comment"># 中位数 (50%)</span></span><br><span class="line">quantile_75 = <span class="built_in">df</span>[<span class="string">&#x27;C&#x27;</span>].quantile(0.75)  <span class="comment"># 第三四分位数 (75%)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用分位数填充缺失值</span></span><br><span class="line">df_filled_quantile_25 = df.fillna(&#123;<span class="string">&#x27;C&#x27;</span>: quantile_25&#125;)</span><br><span class="line">df_filled_quantile_50 = df.fillna(&#123;<span class="string">&#x27;C&#x27;</span>: quantile_50&#125;)</span><br><span class="line">df_filled_quantile_75 = df.fillna(&#123;<span class="string">&#x27;C&#x27;</span>: quantile_75&#125;)</span><br></pre></td></tr></table></figure></div></div></div></div>


<h3 id="处理异常值"><a href="#处理异常值" class="headerlink" title="处理异常值"></a>处理异常值</h3><h4 id="异常值检测"><a href="#异常值检测" class="headerlink" title="异常值检测"></a>异常值检测</h4><div class="tabs" id="tab-异常值检测"><ul class="nav-tabs"><li class="tab active"><a class="#异常值检测-1">使用 Z-Score 检测</a></li><li class="tab"><a class="#异常值检测-2">使用 IQR 方法检测</a></li><li class="tab"><a class="#异常值检测-3">使用可视化方法检测</a></li></ul><div class="tab-content"><div class="tab-pane active" id="异常值检测-1"><p><strong>使用 Z-Score 检测</strong></p>
<p> Z-Score 衡量某个值距离均值的标准差数量。通常，绝对 Z-Score 大于 3 的值被认为是异常值。<br> <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [1, 2, 3, 4, 5, 100]&#125;</span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 Z-Score</span></span><br><span class="line">mean = <span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>].mean()</span><br><span class="line">std = <span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>].std()</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Z-Score&#x27;</span>] = (<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>] - mean) / std</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测异常值（Z-Score &gt; 3 或 &lt; -3）</span></span><br><span class="line">outliers = <span class="built_in">df</span>[abs(<span class="built_in">df</span>[<span class="string">&#x27;Z-Score&#x27;</span>]) &gt; 3]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异常值：\n&quot;</span>, outliers)</span><br></pre></td></tr></table></figure></div></p></div><div class="tab-pane" id="异常值检测-2"><p><strong>使用 IQR 方法检测</strong></p>
<p>IQR（四分位距）是第三四分位数（Q3）与第一四分位数（Q1）的差值。通常，低于 Q1−1.5×IQR 或高于 Q3+1.5×IQR 的值被认为是异常值。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [1, 2, 3, 4, 5, 100]&#125;</span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 IQR</span></span><br><span class="line">Q1 = <span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>].quantile(0.25)</span><br><span class="line">Q3 = <span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>].quantile(0.75)</span><br><span class="line">IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义上下界</span></span><br><span class="line">lower_bound = Q1 - 1.5 * IQR</span><br><span class="line">upper_bound = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测异常值</span></span><br><span class="line">outliers = <span class="built_in">df</span>[(<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>] &lt; lower_bound) | (<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>] &gt; upper_bound)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异常值：\n&quot;</span>, outliers)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="异常值检测-3"><p><strong>This is Tab 3.</strong></p>
<p>箱线图（Box Plot）是一种直观的异常值检测工具。<br>箱线图中的点位于箱子外部的上界或下界之外，这些点即为异常值。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制箱线图</span></span><br><span class="line">plt.boxplot(<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Box Plot of Data&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div></div></div></div>

<h4 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h4><div class="tabs" id="tab-异常值处理方法"><ul class="nav-tabs"><li class="tab active"><a class="#异常值处理方法-1">删除异常值</a></li><li class="tab"><a class="#异常值处理方法-2">替换异常值</a></li><li class="tab"><a class="#异常值处理方法-3">胜率变换</a></li></ul><div class="tab-content"><div class="tab-pane active" id="异常值处理方法-1"><p><strong>删除异常值</strong><br>直接从数据集中移除异常值。<br> <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 删除基于 IQR 方法检测到的异常值</span></span><br><span class="line">filtered_df = <span class="built_in">df</span>[(<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>] &gt;= lower_bound) &amp; (<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>] &lt;= upper_bound)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除异常值后的数据：\n&quot;</span>, filtered_df)</span><br></pre></td></tr></table></figure></div></p></div><div class="tab-pane" id="异常值处理方法-2"><p><strong>替换异常值</strong></p>
<p>将异常值替换为合理的值，例如均值、中位数或边界值。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将异常值替换为中位数</span></span><br><span class="line">median = <span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>].median()</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>] = np.where((df[&#x27;A&#x27;] &lt; lower_bound) | (df[&#x27;A&#x27;] &gt; upper_bound), median, df[&#x27;A&#x27;])</span><br><span class="line"></span><br><span class="line">print(&quot;替换异常值后的数据：\n&quot;, df)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="异常值处理方法-3"><p><strong>胜率变换</strong></p>
<p>将异常值限制在一定范围内，而不是完全删除或替换。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from scipy.stats import mstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 胜率变换：将异常值限制在 5% 和 95% 分位数之间</span></span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;A_winsorized&#x27;</span>] = mstats.winsorize(<span class="built_in">df</span>[<span class="string">&#x27;A&#x27;</span>], limits=[0.05, 0.05])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;胜率变换后的数据：\n&quot;</span>, <span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div></div></div></div>

<h3 id="数据标准化与归一化"><a href="#数据标准化与归一化" class="headerlink" title="数据标准化与归一化"></a>数据标准化与归一化</h3><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>将数据转换为零均值（Mean &#x3D; 0）和单位方差（Variance &#x3D; 1）</p>
<ul>
<li>适用于数据分布接近正态分布的情况 ：标准化假设数据服从正态分布，因此在数据分布大致对称时效果更好。</li>
<li>适用于对距离敏感的算法 ：例如 K-Means、KNN、SVM 和神经网络等。这些算法对特征的尺度非常敏感，标准化可以确保每个特征对结果的贡献是均衡的。</li>
<li>适用于梯度下降优化的模型 ：如线性回归、逻辑回归等。标准化可以使梯度下降更快收敛。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import StandardScaler, MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = [[1, 2], [3, 4], [5, 6]]</span><br><span class="line">X = pd.DataFrame(data, columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_standardized = scaler.fit_transform(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;标准化后的数据：\n&quot;</span>, X_standardized)</span><br></pre></td></tr></table></figure></div>

<h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p>将数据缩放到指定范围（通常是 [0, 1] 或 [-1, 1]）</p>
<ul>
<li>适用于数据分布未知或非正态分布的情况 ：归一化不要求数据服从正态分布，因此适用于分布不规则的数据。</li>
<li>适用于最大值和最小值明确的场景 ：例如图像像素值通常在 [0, 255] 范围内，归一化可以将其缩放到 [0, 1]。</li>
<li>适用于距离计算或相似性度量的算法 ：例如余弦相似度、基于距离的聚类算法等。归一化可以避免大值特征主导结果。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import StandardScaler, MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = [[1, 2], [3, 4], [5, 6]]</span><br><span class="line">X = pd.DataFrame(data, columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">minmax_scaler = MinMaxScaler()</span><br><span class="line">X_normalized = minmax_scaler.fit_transform(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;归一化后的数据：\n&quot;</span>, X_normalized)</span><br></pre></td></tr></table></figure></div>

<h3 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h3><p>特征编码（Feature Encoding）是将非数值型特征（如类别型、文本型数据）转换为数值型表示的过程。它是机器学习中数据预处理的重要步骤，因为大多数机器学习算法只能处理数值型数据。</p>
<div class="tabs" id="tab-常见的特征编码方法"><ul class="nav-tabs"><li class="tab active"><a class="#常见的特征编码方法-1">标签编码</a></li><li class="tab"><a class="#常见的特征编码方法-2">独热编码</a></li><li class="tab"><a class="#常见的特征编码方法-3">目标编码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="常见的特征编码方法-1"><p>将类别型变量映射为整数（如 “red” → 0, “blue” → 1, “green” → 2）。<br>适用场景 ：类别之间具有顺序关系（如 “low”, “medium”, “high”）。<br>优点 ：简单高效，适用于少量类别的情况。<br>缺点 ：可能导致模型误以为类别之间有数值上的大小关系。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import LabelEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">encoded_data = le.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;标签编码结果：&quot;</span>, encoded_data)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="常见的特征编码方法-2"><p>将每个类别值转换为一个二进制向量。<br>适用场景 ：类别之间没有顺序关系（如 “red”, “blue”, “green”）。<br>优点 ：消除了类别间的数值关系，适合无序类别。<br>缺点 ：可能会导致维度爆炸（类别数量过多时生成的特征维度过大）。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">ohe = OneHotEncoder(sparse=False)</span><br><span class="line">encoded_data = ohe.fit_transform(pd.DataFrame(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;独热编码结果：\n&quot;</span>, encoded_data)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="常见的特征编码方法-3"><p>使用目标变量的统计信息（如均值）对类别变量进行编码。<br>适用场景 ：类别数量较多且数据量较大时，避免维度爆炸问题。<br>优点 ：保留了类别与目标变量的关系。<br>缺点 ：可能导致过拟合，需注意平滑处理。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;<span class="string">&#x27;category&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>], <span class="string">&#x27;target&#x27;</span>: [1, 0, 1, 1, 0]&#125;</span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个类别的目标均值</span></span><br><span class="line">target_mean = df.groupby(<span class="string">&#x27;category&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;target_encoded&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;category&#x27;</span>].map(target_mean)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;目标编码结果：\n&quot;</span>, <span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div></div></div></div>

<h3 id="特征选择与降维"><a href="#特征选择与降维" class="headerlink" title="特征选择与降维"></a>特征选择与降维</h3><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>特征选择是从原始特征集中选择最重要的子集，从而减少无关或冗余特征对模型的影响。</p>
<p>减少过拟合 ：通过去除无关特征，降低模型复杂度。<br>提高训练效率 ：减少特征数量可以加速模型训练。<br>增强可解释性 ：保留关键特征有助于理解模型的工作机制。</p>
<p>根据特征选择的方式，可分为以下三类：</p>
<div class="tabs" id="tab-特征选择"><ul class="nav-tabs"><li class="tab active"><a class="#特征选择-1">过滤法</a></li><li class="tab"><a class="#特征选择-2">包装法</a></li><li class="tab"><a class="#特征选择-3">嵌入法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="特征选择-1"><p>根据统计指标（如相关性、互信息等）独立评估每个特征的重要性。<br>不依赖于具体模型。<br>优点 ：计算简单，速度快。<br>缺点 ：可能忽略特征之间的交互关系。</p>
<blockquote>
<p>示例 ：<br>相关系数（Pearson、Spearman）<br>卡方检验<br>互信息</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_selection import SelectKBest, chi2</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">X, y = load_iris(return_X_y=True)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用卡方检验选择前 2 个最佳特征</span></span><br><span class="line">selector = SelectKBest(chi2, k=2)</span><br><span class="line">X_new = selector.fit_transform(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择后的特征形状：&quot;</span>, X_new.shape)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="特征选择-2"><p>通过反复训练模型来评估特征子集的表现。<br>常用算法：递归特征消除（RFE）。<br>优点 ：考虑特征之间的交互关系。<br>缺点 ：计算成本高。</p>
<blockquote>
<p>示例 ：<br>RFE（Recursive Feature Elimination）</p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> from sklearn.feature_selection import RFE</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">rfe = RFE(model, n_features_to_select=2)</span><br><span class="line">X_new = rfe.fit_transform(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择后的特征形状：&quot;</span>, X_new.shape)</span><br></pre></td></tr></table></figure></div></blockquote></div><div class="tab-pane" id="特征选择-3"><p>在模型训练过程中自动选择重要特征。<br>常用算法：Lasso 回归、树模型（如随机森林、XGBoost）。<br>优点 ：结合了模型训练和特征选择。<br>缺点 ：依赖于具体模型。</p>
<blockquote>
<p>示例 ：<br>Lasso 回归（基于 L1 正则化） </p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model import Lasso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Lasso 回归进行特征选择</span></span><br><span class="line">lasso = Lasso(alpha=0.1)</span><br><span class="line">lasso.fit(X, y)</span><br><span class="line">selected_features = [i <span class="keyword">for</span> i, coef <span class="keyword">in</span> enumerate(lasso.coef_) <span class="keyword">if</span> coef != 0]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择的特征索引：&quot;</span>, selected_features)</span><br></pre></td></tr></table></figure></div></div></div></div>
<h4 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h4><p>将数据投影到方差最大的方向上。<br>优点 ：线性变换，计算高效。<br>缺点 ：仅适用于线性可分的数据。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.decomposition import PCA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 PCA 降维到 2 维</span></span><br><span class="line">pca = PCA(n_components=2)</span><br><span class="line">X_pca = pca.fit_transform(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;降维后的数据形状：&quot;</span>, X_pca.shape)</span><br></pre></td></tr></table></figure></div>


<h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><h3 id="分离特征和目标变量"><a href="#分离特征和目标变量" class="headerlink" title="分离特征和目标变量"></a>分离特征和目标变量</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设 &#x27;target&#x27; 是目标变量列名</span></span><br><span class="line">X = data.drop(columns=[<span class="string">&#x27;target&#x27;</span>])  <span class="comment"># 特征</span></span><br><span class="line">y = data[<span class="string">&#x27;target&#x27;</span>]  <span class="comment"># 目标变量</span></span><br></pre></td></tr></table></figure></div>
<h3 id="数据划分-1"><a href="#数据划分-1" class="headerlink" title="数据划分"></a>数据划分</h3><p>将数据划分为训练集和测试集</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练集大小：&quot;</span>, X_train.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试集大小：&quot;</span>, X_test.shape)</span><br></pre></td></tr></table></figure></div>

<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="sklearn-中的常用二分类模型代码示例"><a href="#sklearn-中的常用二分类模型代码示例" class="headerlink" title="sklearn 中的常用二分类模型代码示例"></a>sklearn 中的常用二分类模型代码示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.svm import SVC</span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line">from sklearn.naive_bayes import GaussianNB</span><br><span class="line">from sklearn.neural_network import MLPClassifier</span><br><span class="line"></span><br><span class="line">models = &#123;</span><br><span class="line">    <span class="string">&quot;Logistic Regression&quot;</span>: LogisticRegression(),</span><br><span class="line">    <span class="string">&quot;SVM&quot;</span>: SVC(),</span><br><span class="line">    <span class="string">&quot;Random Forest&quot;</span>: RandomForestClassifier(),</span><br><span class="line">    <span class="string">&quot;KNN&quot;</span>: KNeighborsClassifier(),</span><br><span class="line">    <span class="string">&quot;Naive Bayes&quot;</span>: GaussianNB(),</span><br><span class="line">    <span class="string">&quot;MLP Neural Net&quot;</span>: MLPClassifier()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="模型标准化-训练-优化模版"><a href="#模型标准化-训练-优化模版" class="headerlink" title="模型标准化+训练+优化模版"></a>模型标准化+训练+优化模版</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.preprocessing import StandardScaler            <span class="comment"># ✅ 可换成 MinMaxScaler、RobustScaler 等</span></span><br><span class="line">from sklearn.svm import SVC                                  <span class="comment"># ✅ 可换成 LogisticRegression, RandomForestClassifier, etc.</span></span><br><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 第1处：构建Pipeline步骤</span></span><br><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;scaler&#x27;</span>, StandardScaler()),                           <span class="comment"># 标准化步骤（可删、可换）</span></span><br><span class="line">    (<span class="string">&#x27;svm&#x27;</span>, SVC())                                           <span class="comment"># 模型步骤（可换）</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 第2处：定义参数网格</span></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;svm__C&#x27;</span>: [0.1, 1, 10],                                  <span class="comment"># 可调SVM的 C 值范围</span></span><br><span class="line">    <span class="string">&#x27;svm__kernel&#x27;</span>: [<span class="string">&#x27;linear&#x27;</span>, <span class="string">&#x27;rbf&#x27;</span>],                        <span class="comment"># 可选 kernel 类型</span></span><br><span class="line">    <span class="string">&#x27;svm__gamma&#x27;</span>: [<span class="string">&#x27;scale&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>]                          <span class="comment"># 适用于 rbf kernel</span></span><br><span class="line">    <span class="comment"># 替换模型时需要换成对应模型参数名，例如：</span></span><br><span class="line">    <span class="comment"># &#x27;logreg__penalty&#x27;: [&#x27;l2&#x27;], </span></span><br><span class="line">    <span class="comment"># &#x27;logreg__C&#x27;: [0.01, 0.1, 1, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 第3处：GridSearchCV 封装 Pipeline</span></span><br><span class="line">grid_search = GridSearchCV(pipeline, param_grid, cv=5)       <span class="comment"># cv 可改为 3/10 或 StratifiedKFold 等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 第4处：训练</span></span><br><span class="line">grid_search.fit(X_train, y_train)                            <span class="comment"># 训练数据输入（确保已经分好训练集）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 第5处：结果查看</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优参数:&quot;</span>, grid_search.best_params_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优交叉验证得分:&quot;</span>, grid_search.best_score_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 第6处：在测试集上做预测</span></span><br><span class="line">y_pred = grid_search.predict(X_test)</span><br></pre></td></tr></table></figure></div>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h3><p>准确率是指模型预测正确的样本占总样本的比例。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [0, 1, 1, 0, 1]</span><br><span class="line">y_pred = [0, 1, 0, 0, 1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率：&quot;</span>, accuracy)</span><br></pre></td></tr></table></figure></div>
<h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>混淆矩阵是一个表格，用于总结分类模型的预测结果。</p>
<blockquote>
<p>常见术语：<br>TP（True Positive）：正类正确预测为正类。<br>TN（True Negative）：负类正确预测为负类。<br>FP（False Positive）：负类错误预测为正类。<br>FN（False Negative）：正类错误预测为负类。</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [0, 1, 1, 0, 1]</span><br><span class="line">y_pred = [0, 1, 0, 0, 1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算混淆矩阵</span></span><br><span class="line">cm = confusion_matrix(y_true, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化混淆矩阵</span></span><br><span class="line">sns.heatmap(cm, annot=True, <span class="built_in">fmt</span>=<span class="string">&#x27;d&#x27;</span>, cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Predicted Labels&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;True Labels&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Confusion Matrix&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<h3 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h3><p>召回率（也称灵敏度或 True Positive Rate）是指模型正确预测为正类的样本占实际正类的比例。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import recall_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [0, 1, 1, 0, 1]</span><br><span class="line">y_pred = [0, 1, 0, 0, 1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算召回率</span></span><br><span class="line">recall = recall_score(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;召回率：&quot;</span>, recall)</span><br></pre></td></tr></table></figure></div>

<h3 id="精确率"><a href="#精确率" class="headerlink" title="精确率"></a>精确率</h3><p>精确率是指模型预测为正类的样本中实际为正类的比例。</p>
<blockquote>
<p>适用场景<br>关注减少误报时使用（如推荐系统）。</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import precision_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [0, 1, 1, 0, 1]</span><br><span class="line">y_pred = [0, 1, 0, 0, 1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算精确率</span></span><br><span class="line">precision = precision_score(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;精确率：&quot;</span>, precision)</span><br></pre></td></tr></table></figure></div>

<h3 id="F1-分数"><a href="#F1-分数" class="headerlink" title="F1 分数"></a>F1 分数</h3><p>F1 分数是精确率和召回率的调和平均值，用于综合衡量模型性能。</p>
<blockquote>
<p>适用场景<br>类别不平衡时使用。</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [0, 1, 1, 0, 1]</span><br><span class="line">y_pred = [0, 1, 0, 0, 1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 F1 分数</span></span><br><span class="line">f1 = f1_score(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;F1 分数：&quot;</span>, f1)</span><br></pre></td></tr></table></figure></div>

<h3 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h3><p>AUC 是 ROC 曲线下的面积，用于衡量模型区分正负类的能力。<br>范围：[0, 1]，值越大表示模型性能越好。</p>
<blockquote>
<p>适用场景<br>需要评估模型整体性能时使用。</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import roc_auc_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [0, 1, 1, 0, 1]</span><br><span class="line">y_scores = [0.1, 0.9, 0.8, 0.2, 0.7]  <span class="comment"># 模型预测的概率值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 AUC</span></span><br><span class="line">auc = roc_auc_score(y_true, y_scores)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AUC：&quot;</span>, auc)</span><br></pre></td></tr></table></figure></div>

<h3 id="均方误差-均方根误差-R²-决定系数"><a href="#均方误差-均方根误差-R²-决定系数" class="headerlink" title="均方误差 均方根误差 R² 决定系数"></a>均方误差 均方根误差 R² 决定系数</h3><p>均方误差是预测值与真实值之间差值平方的平均值。</p>
<p>均方根误差是均方误差的平方根，用于将误差恢复到原始单位。</p>
<p>R² 决定系数衡量模型对数据的拟合程度，取值范围为 (−∞,1]。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">y_true = [3.0, -0.5, 2.0, 7.0]  <span class="comment"># 真实值</span></span><br><span class="line">y_pred = [2.5, 0.0, 2.0, 8.0]  <span class="comment"># 预测值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 MSE</span></span><br><span class="line">mse = mean_squared_error(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;均方误差（MSE）：&quot;</span>, mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 RMSE</span></span><br><span class="line">rmse = np.sqrt(mse)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;均方根误差（RMSE）：&quot;</span>, rmse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 MAE</span></span><br><span class="line">mae = mean_absolute_error(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均绝对误差（MAE）：&quot;</span>, mae)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 R²</span></span><br><span class="line">r2 = r2_score(y_true, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;R² 决定系数：&quot;</span>, r2)</span><br></pre></td></tr></table></figure></div>

<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line">from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV</span><br><span class="line">from sklearn.linear_model import LinearRegression, Ridge, Lasso</span><br><span class="line">from sklearn.preprocessing import StandardScaler, OneHotEncoder</span><br><span class="line">from sklearn.compose import ColumnTransformer</span><br><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.metrics import mean_squared_error, r2_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 data 是一个 Pandas DataFrame</span></span><br><span class="line"><span class="comment"># data = pd.read_csv(&#x27;data.csv&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">X = data.drop(columns=[<span class="string">&#x27;target&#x27;</span>])</span><br><span class="line">y = data[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line"></span><br><span class="line">numeric_features = X.select_dtypes(include=[<span class="string">&#x27;int64&#x27;</span>, <span class="string">&#x27;float64&#x27;</span>]).columns</span><br><span class="line">categorical_features = X.select_dtypes(include=[<span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;category&#x27;</span>]).columns</span><br><span class="line"></span><br><span class="line">preprocessor = ColumnTransformer(</span><br><span class="line">    transformers=[</span><br><span class="line">        (<span class="string">&#x27;num&#x27;</span>, StandardScaler(), numeric_features),</span><br><span class="line">        (<span class="string">&#x27;cat&#x27;</span>, OneHotEncoder(), categorical_features)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">plt.figure(figsize=(8, 5))</span><br><span class="line">sns.histplot(y, kde=True, bins=30, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Target Variable Distribution&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型选择</span></span><br><span class="line">models = &#123;</span><br><span class="line">    <span class="string">&quot;Linear Regression&quot;</span>: Pipeline(steps=[(<span class="string">&#x27;preprocessor&#x27;</span>, preprocessor), (<span class="string">&#x27;regressor&#x27;</span>, LinearRegression())]),</span><br><span class="line">    <span class="string">&quot;Ridge Regression&quot;</span>: Pipeline(steps=[(<span class="string">&#x27;preprocessor&#x27;</span>, preprocessor), (<span class="string">&#x27;regressor&#x27;</span>, Ridge())]),</span><br><span class="line">    <span class="string">&quot;Lasso Regression&quot;</span>: Pipeline(steps=[(<span class="string">&#x27;preprocessor&#x27;</span>, preprocessor), (<span class="string">&#x27;regressor&#x27;</span>, Lasso())])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;regressor__alpha&#x27;</span>: [0.01, 0.1, 1, 10, 100]&#125;</span><br><span class="line"><span class="keyword">for</span> model_name, model <span class="keyword">in</span> list(models.items())[1:]:</span><br><span class="line">    grid_search = GridSearchCV(model, param_grid, cv=5, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line">    grid_search.fit(X_train, y_train)</span><br><span class="line">    models[model_name] = grid_search.best_estimator_</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;&#123;model_name&#125; 最佳参数：&quot;</span>, grid_search.best_params_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型验证</span></span><br><span class="line">results = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> model_name, model <span class="keyword">in</span> models.items():</span><br><span class="line">    scores = cross_val_score(model, X_train, y_train, cv=5, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line">    results[model_name] = -scores.mean()</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;&#123;model_name&#125; 的平均 MSE：&quot;</span>, results[model_name])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集评估</span></span><br><span class="line">best_model_name = min(results, key=results.get)</span><br><span class="line">best_model = models[best_model_name]</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;最佳模型：&#123;best_model_name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">best_model.fit(X_train, y_train)</span><br><span class="line">y_pred = best_model.predict(X_test)</span><br><span class="line"></span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;测试集 MSE：&#123;mse&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;测试集 R²：&#123;r2&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line">plt.figure(figsize=(8, 6))</span><br><span class="line">plt.scatter(y_test, y_pred, alpha=0.7, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot([y.min(), y.max()], [y.min(), y.max()], <span class="string">&#x27;r--&#x27;</span>, lw=2)</span><br><span class="line">plt.title(<span class="string">&#x27;True vs Predicted Values&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">residuals = y_test - y_pred</span><br><span class="line">plt.figure(figsize=(8, 6))</span><br><span class="line">sns.histplot(residuals, kde=True, bins=30, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Residuals Distribution&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>使数组元素互不相同所需的最少操作次数</title>
    <url>/zhihaojiang.github.io/2025/04/08/20250408%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums，你需要确保数组中的元素 互不相同 。为此，你可以执行以下操作任意次：</p>
<p>从数组的开头移除 3 个元素。如果数组中元素少于 3 个，则移除所有剩余元素。<br>注意：空数组也视作为数组元素互不相同。返回使数组元素互不相同所需的 最少操作次数 。</p>
<blockquote>
<p>示例 1：</p>
<p>输入： nums &#x3D; [1,2,3,4,2,3,3,5,7]</p>
<p>输出： 2</p>
<p>解释：</p>
<p>第一次操作：移除前 3 个元素，数组变为 [4, 2, 3, 3, 5, 7]。<br>第二次操作：再次移除前 3 个元素，数组变为 [3, 5, 7]，此时数组中的元素互不相同。<br>因此，答案是 2。</p>
<p>示例 2：</p>
<p>输入： nums &#x3D; [4,5,6,4,4]</p>
<p>输出： 2</p>
<p>解释：</p>
<p>第一次操作：移除前 3 个元素，数组变为 [4, 4]。<br>第二次操作：移除所有剩余元素，数组变为空。<br>因此，答案是 2。</p>
<p>示例 3：</p>
<p>输入： nums &#x3D; [6,7,8,9]</p>
<p>输出： 0</p>
<p>解释：</p>
<p>数组中的元素已经互不相同，因此不需要进行任何操作，答案是 0。</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>采用倒序判断 arr为一个布尔数组 用于判断数字是否重复出现 是O(n)的时间复杂度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minimumOperations(self, nums):</span><br><span class="line">        n = len(nums)</span><br><span class="line">        arr = [False] * 128</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - 1,-1 , -1):</span><br><span class="line">            <span class="keyword">if</span> arr[nums[i]]:</span><br><span class="line">                <span class="built_in">return</span> i // 3 + 1</span><br><span class="line">            arr[nums[i]] = True</span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>使数组的值全部为 K 的最少操作次数</title>
    <url>/zhihaojiang.github.io/2025/04/09/20250409%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E5%85%A8%E9%83%A8%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个整数 k 。</p>
<p>如果一个数组中所有 严格大于 h 的整数值都 相等 ，那么我们称整数 h 是 合法的 。</p>
<p>比方说，如果 nums &#x3D; [10, 8, 10, 8] ，那么 h &#x3D; 9 是一个 合法 整数，因为所有满足 nums[i] &gt; 9 的数都等于 10 ，但是 5 不是 合法 整数。</p>
<p>你可以对 nums 执行以下操作：</p>
<p>选择一个整数 h ，它对于 当前 nums 中的值是合法的。<br>对于每个下标 i ，如果它满足 nums[i] &gt; h ，那么将 nums[i] 变为 h 。<br>你的目标是将 nums 中的所有元素都变为 k ，请你返回 最少 操作次数。如果无法将所有元素都变 k ，那么返回 -1 。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,2,5,4,5], k &#x3D; 2</p>
<p>输出：2</p>
<p>解释：</p>
<p>依次选择合法整数 4 和 2 ，将数组全部变为 2 。</p>
<p>示例 2：</p>
<p>输入：nums &#x3D; [2,1,2], k &#x3D; 2</p>
<p>输出：-1</p>
<p>解释：</p>
<p>没法将所有值变为 2 。</p>
<p>示例 3：</p>
<p>输入：nums &#x3D; [9,7,5,3], k &#x3D; 1</p>
<p>输出：4</p>
<p>解释：</p>
<p>依次选择合法整数 7 ，5 ，3 和 1 ，将数组全部变为 1 。</p>
</blockquote>
<h2 id="解释题目"><a href="#解释题目" class="headerlink" title="解释题目"></a>解释题目</h2><p>异常情况: nums[i]&lt;k, 直接返回 −1<br>需要进行转换的元素: nums[i]&gt;k<br>无需转换的元素: nums[i]&#x3D;&#x3D;k</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minOperations(self, nums, k):</span><br><span class="line">        n = len(nums)</span><br><span class="line">        s = <span class="built_in">set</span>([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; k:</span><br><span class="line">                <span class="built_in">return</span> -1</span><br><span class="line">            <span class="keyword">if</span> nums[i] != k:</span><br><span class="line">                s.add(nums[i])</span><br><span class="line">        <span class="built_in">return</span> len(s)</span><br></pre></td></tr></table></figure></div>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>set()</strong><br>set顾名思义是集合 里面不能包含重复的元素 接收一个list作为参数<br>set() 函数创建一个无序不重复元素集 可进行关系测试 删除重复数据 还可以计算交集、差集、并集等</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">list = [2,3,5,7]</span><br><span class="line">s = <span class="built_in">set</span>(list)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#输出set([2,3,5,7])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line">s.add(9)</span><br><span class="line">s.add(7)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#输出set([2,3,5,7,9])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">s.remove(9)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#输出set([2,3,5,7])</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>向字符串添加空格</title>
    <url>/zhihaojiang.github.io/2025/04/10/20250410%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。</p>
<p>数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。</p>
<p>例如，s &#x3D; “EnjoyYourCoffee” 且 spaces &#x3D; [5, 9] ，那么我们需要在 ‘Y’ 和 ‘C’ 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 “Enjoy Your Coffee” 。<br>请你添加空格，并返回修改后的字符串。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：s &#x3D; “LeetcodeHelpsMeLearn”, spaces &#x3D; [8,13,15]<br>输出：”Leetcode Helps Me Learn”<br>解释：<br>下标 8、13 和 15 对应 “LeetcodeHelpsMeLearn” 中加粗斜体字符。<br>接着在这些字符前添加空格。<br>示例 2：</p>
<p>输入：s &#x3D; “icodeinpython”, spaces &#x3D; [1,5,7,9]<br>输出：”i code in py thon”<br>解释：<br>下标 1、5、7 和 9 对应 “icodeinpython” 中加粗斜体字符。<br>接着在这些字符前添加空格。<br>示例 3：</p>
<p>输入：s &#x3D; “spacing”, spaces &#x3D; [0,1,2,3,4,5,6]<br>输出：” s p a c i n g”<br>解释：<br>字符串的第一个字符前可以添加空格。</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def addSpaces(self, s, spaces):</span><br><span class="line">        s = list(s) <span class="comment">#字符串字符串在 Python 中是不可变的 而列表是可变的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> spaces:    <span class="comment">#遍历 spaces 中的每个元素 即i = spaces[i]</span></span><br><span class="line">            s[i] = <span class="string">&#x27; &#x27;</span> + s[i]</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&#x27;&#x27;</span>.<span class="built_in">join</span>(s)   <span class="comment">#将修改后的字符列表重新组合成一个字符串。</span></span><br></pre></td></tr></table></figure></div>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>‘’.join(s)</strong><br>join函数是一个字符串操作函数 这个函数展开来写应该是str.join(item) str表示字符串（字符），item表示一个成员</p>
<blockquote>
<p>例子：<br>‘,’.join(‘abc’)<br>输出：<br>‘a,b,c’</p>
</blockquote>
<p>join里也可以放列表、元组、字典</p>
<blockquote>
<p>例子：<br>‘ ‘.join([a,b,c])<br>输出：<br>a b c</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>统计对称整数的数目</title>
    <url>/zhihaojiang.github.io/2025/04/11/20250411%E7%BB%9F%E8%AE%A1%E5%AF%B9%E7%A7%B0%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个正整数 low 和 high 。</p>
<p>对于一个由 2 * n 位数字组成的整数 x ，如果其前 n 位数字之和与后 n 位数字之和相等，则认为这个数字是一个对称整数。</p>
<p>返回在 [low, high] 范围内的 对称整数的数目 。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：low &#x3D; 1, high &#x3D; 100<br>输出：9<br>解释：在 1 到 100 范围内共有 9 个对称整数：11、22、33、44、55、66、77、88 和 99 。<br>示例 2：</p>
<p>输入：low &#x3D; 1200, high &#x3D; 1230<br>输出：4<br>解释：在 1200 到 1230 范围内共有 4 个对称整数：1203、1212、1221 和 1230 。</p>
<p>提示：<br>1 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 104</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def countSymmetricIntegers(self, low, high):</span><br><span class="line">        count = 0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(low, high + 1):</span><br><span class="line">            <span class="keyword">if</span> i &gt; 0 and i &lt; 100:</span><br><span class="line">                <span class="keyword">if</span> i % 11 == 0:</span><br><span class="line">                    count += 1</span><br><span class="line">            <span class="keyword">if</span> i &gt; 1000 and i &lt; 10000:</span><br><span class="line">                left = i // 1000 + i // 100 % 10</span><br><span class="line">                right = i // 10 % 10 + i % 10</span><br><span class="line">                <span class="keyword">if</span> left == right:</span><br><span class="line">                    count += 1</span><br><span class="line">        <span class="built_in">return</span> count</span><br></pre></td></tr></table></figure></div>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>如何取出4位数中的各个位数</strong><br>以2357为例<br>2 &#x3D; 2357 &#x2F;&#x2F; 1000<br>3 &#x3D; 2357 &#x2F;&#x2F; 100 % 10<br>5 &#x3D; 2357 &#x2F;&#x2F; 10 % 10<br>7 &#x3D; 2357 % 10</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>成人抑郁症数据分析</title>
    <url>/zhihaojiang.github.io/2025/04/14/20250414%E6%88%90%E4%BA%BA%E6%8A%91%E9%83%81%E7%97%87%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p><a class="link"   href="https://www.kaggle.com/datasets/sonawanelalitsunil/adult-depression-lghc-indicator/data" >https://www.kaggle.com/datasets/sonawanelalitsunil/adult-depression-lghc-indicator/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="成人抑郁症"><a href="#成人抑郁症" class="headerlink" title="成人抑郁症"></a>成人抑郁症</h2><p>成人抑郁症（LGHC 指标）数据集提供了由地方健康地理比较 (LGHC) 计划跟踪的成人抑郁症患病率的见解。它可作为了解不同人群和地区心理健康趋势的公共卫生资源。</p>
<p>主要特点：<br>健康指标：根据健康调查的自我报告数据，关注被诊断患有抑郁症的成年人的百分比。<br>人口统计和地理：按年龄、性别、种族&#x2F;民族、收入水平和地理位置（州、县或地方区域）细分数据。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>对数据集进行探索性分析，找出数据集中的问题。</li>
<li>对数据进行预处理，包括缺失值处理、异常值处理、数据类型转换等。</li>
<li>对数据进行可视化分析，找出数据中的规律。</li>
<li>对数据进行分析，找出数据中的规律并预测抑郁症的概率。</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>导入库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.metrics import mean_squared_error,r2_score</span><br></pre></td></tr></table></figure></div>

<p>读取文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;adult-depression-lghc-indicator-24.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>查看文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/002.png"
                      alt="photo"
                ></p>
<h3 id="分析每个字段的含义"><a href="#分析每个字段的含义" class="headerlink" title="分析每个字段的含义"></a>分析每个字段的含义</h3><ul>
<li><code>Year</code>：数据收集年份</li>
<li><code>Strata</code>：包含了各种类别</li>
<li><code>Strata Name</code>：不同类别的详细名称</li>
<li><code>Frequency</code>：频率</li>
<li><code>Weighted Frequency</code>：权重频率</li>
<li><code>Percent</code>：患病百分比 – target</li>
<li><code>Lower 95% CL</code>：较低的 95% CL</li>
<li><code>Upper 95% CL</code>：较高的 95% CL</li>
</ul>
<p>针对Strata</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Strata&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/003.png"
                      alt="photo"
                ></p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">df</span>[<span class="string">&#x27;Year&#x27;</span>]</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;Percent&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sns.lineplot(x=x, y=y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Percent&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Percent of Adults Depressed Over Time&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/004.png"
                      alt="photo"
                ></p>
<p>可以看到 抑郁症发病率在逐年上升 在2017年达到了最高值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Strata_features = [<span class="string">&#x27;Income&#x27;</span>, <span class="string">&#x27;Race-Ethnicity&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Education&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> Strata_features:</span><br><span class="line">    sns.barplot(x=<span class="string">&#x27;Strata Name&#x27;</span>, y=<span class="string">&#x27;Percent&#x27;</span>, data=<span class="built_in">df</span>[<span class="built_in">df</span>[<span class="string">&#x27;Strata&#x27;</span>]== feature], hue=<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line">    plt.title(f<span class="string">&#x27;Percent of Adults Depressed by &#123;feature&#125;&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/005.png"
                      alt="photo"
                ></p>
<p>可以看到 收入小于$20，000的人得抑郁症的概率高于其他收入水平</p>
<p>可能的原因：低收入水平的人可能面临经济困难和压力，从而增加了他们对抑郁的感知和应对的难度。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/006.png"
                      alt="photo"
                ></p>
<p>可以看到 亚非裔的人得抑郁症的概率低于其他种族和民族</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/007.png"
                      alt="photo"
                ></p>
<p>可以看到 随着年龄的增长 得抑郁症的概率也在增长 在65岁以上时又减小</p>
<p>可能的原因：随着年龄的增长 人们的生活和工作环境也在不断变化 压力也越来越大 因此也会增加得抑郁症的概率 在65岁以上时 人们已经退休了 没有了生活和工作的压力 因此也会减少得抑郁症的概率<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/008.png"
                      alt="photo"
                ></p>
<p>可以看到 学历对得抑郁症的概率没有明显影响</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/009.png"
                      alt="photo"
                ></p>
<p>可以看到 女性得抑郁症的概率高于男性</p>
<p>男女性得抑郁症的概率都逐年上升 在2017年达到最高</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plt.scatter(<span class="built_in">df</span>[<span class="string">&#x27;Lower 95% CL&#x27;</span>], <span class="built_in">df</span>[<span class="string">&#x27;Percent&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plt.scatter(<span class="built_in">df</span>[<span class="string">&#x27;Upper 95% CL&#x27;</span>], <span class="built_in">df</span>[<span class="string">&#x27;Percent&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/010.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/011.png"
                      alt="photo"
                ></p>
<p>上述两张散点图可以看到 Upper 95% CL和 Lower 95% CL 对得抑郁症的影响很大</p>
<p>用相关性矩阵查看特征之间的关系</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">num_df = df.select_dtypes(include=[np.number])</span><br><span class="line">sns.heatmap(num_df.corr(), annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Correlation Heatmap&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/14/012.png"
                      alt="photo"
                ></p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.drop(columns=[<span class="string">&#x27;Strata Name&#x27;</span>, <span class="string">&#x27;Strata&#x27;</span>], inplace=True)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Year                  0<br>Frequency             0<br>Weighted Frequency    7<br>Percent               0<br>Lower 95% CL          0<br>Upper 95% CL          0<br>dtype: int64</p>
</blockquote>
<p>由于只有7个缺失值 所以直接删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.dropna(inplace=True)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 Z-Score</span></span><br><span class="line">mean = <span class="built_in">df</span>[<span class="string">&#x27;Frequency&#x27;</span>].mean()</span><br><span class="line">std = <span class="built_in">df</span>[<span class="string">&#x27;Frequency&#x27;</span>].std()</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Z-Score&#x27;</span>] = (<span class="built_in">df</span>[<span class="string">&#x27;Frequency&#x27;</span>] - mean) / std</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测异常值（Z-Score &gt; 3 或 &lt; -3）</span></span><br><span class="line">outliers = <span class="built_in">df</span>[abs(<span class="built_in">df</span>[<span class="string">&#x27;Z-Score&#x27;</span>]) &gt; 3]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异常值：\n&quot;</span>, outliers)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>异常值：<br>    Year  Frequency  Weighted Frequency  Percent  Lower 95% CL  Upper 95% CL  <br>2  2012       1359           2163108.0    15.25         14.30         16.20<br>3  2012       1314           1806371.0    14.57         13.67         15.46   </p>
<pre><code>Z-Score  
</code></pre>
<p>2  3.498507<br>3  3.339020</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from scipy.stats import mstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 胜率变换：将异常值限制在 5% 和 95% 分位数之间</span></span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Frequency_winsorized&#x27;</span>] = mstats.winsorize(<span class="built_in">df</span>[<span class="string">&#x27;Frequency&#x27;</span>], limits=[0.05, 0.05])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;胜率变换后的数据：\n&quot;</span>, <span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>胜率变换后的数据：<br>      Year  Frequency  Weighted Frequency  Percent  Lower 95% CL  Upper 95% CL  <br>1    2012        561           1116664.0     8.12          7.32          8.92<br>2    2012       1359           2163108.0    15.25         14.30         16.20<br>3    2012       1314           1806371.0    14.57         13.67         15.46<br>4    2012         97            222022.0    13.54         10.44         16.65<br>5    2012        412            923174.0     9.98          8.91         11.05<br>..    …        …                 …      …           …           …<br>156  2018        496           1623933.0    17.69         13.72         21.66<br>157  2018        285            749615.0    14.56         10.91         18.21<br>158  2018        301           1052945.0    20.06         15.60         24.52<br>159  2018        432            854201.0    21.44         17.65         25.23<br>160  2018        450            661974.0    15.60         13.42         17.78   </p>
<pre><code>  Z-Score  Frequency_winsorized  
</code></pre>
<p>1    0.670280                   561<br>2    3.498507                  1055<br>3    3.339020                  1055<br>4   -0.974202                    97<br>5    0.142203                   412<br>..        …                   …<br>156  0.439911                   496<br>157 -0.307903                   285<br>158 -0.251197                   301<br>159  0.213086                   432<br>160  0.276880                   450  </p>
<p>[154 rows x 8 columns]</p>
</blockquote>
<p>就是将第2，3行的一场数据进行了胜率变换 其他行数据没有变化</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X = df.drop(columns=[<span class="string">&#x27;Percent&#x27;</span>, <span class="string">&#x27;Z-Score&#x27;</span>, <span class="string">&#x27;Frequency&#x27;</span>])</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;Percent&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行标准化</span></span><br><span class="line">scaler =  StandardScaler()</span><br><span class="line">scaler.fit(X_train, X_test)</span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br></pre></td></tr></table></figure></div>
<h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train_scaled, y_train)</span><br><span class="line">y_pred = lr.predict(X_test_scaled)</span><br></pre></td></tr></table></figure></div>

<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Linear Regression MSE:&quot;</span>, mse)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Linear Regression R^2:&quot;</span>, r2)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Linear Regression MSE: 1.439819098234569e-05<br>Linear Regression R^2: 0.999999015347916</p>
</blockquote>
<p>决定系数为0.99以上 说明模型拟合得很好</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Predict Podcast Listening Time</title>
    <url>/zhihaojiang.github.io/2025/04/16/20250416Predict%20Podcast%20Listening%20Time/</url>
    <content><![CDATA[<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p><a class="link"   href="https://www.kaggle.com/competitions/playground-series-s5e4/data" >https://www.kaggle.com/competitions/playground-series-s5e4/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p>Dataset Description<br>The dataset for this competition (both train and test) was generated from a deep learning model trained on the Podcast Listening Time Prediction dataset. Feature distributions are close to, but not exactly the same, as the original. Feel free to use the original dataset as part of this competition, both to explore differences as well as to see whether incorporating the original in training improves model performance.</p>
<p>Files<br>train.csv - the training dataset; Listening_Time_minutes is the target<br>test.csv - the test dataset; your objective is to predict the Listening_Time_minutes for each row<br>sample_submission.csv - a sample submission file in the correct format.</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>导入库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.metrics import mean_squared_error,r2_score</span><br></pre></td></tr></table></figure></div>

<h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;/kaggle/input/playground-series-s5e4/train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/002.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/003.png"
                      alt="photo"
                ></p>
<p>现在分析一下这些字段是什么意思：</p>
<ul>
<li><code>id</code>：播客名称</li>
<li><code>podcast_Name</code>：播客名称</li>
<li><code>Episode_Title</code>：章节标题</li>
<li><code>Episode_Length_minutes</code>：章节时长</li>
<li><code>Genre</code>：播客类别</li>
<li><code>Host_Popularity_percentage</code>：主持人人气百分比</li>
<li><code>Publication_Day</code>：播放日期</li>
<li><code>Publication_Time</code>：播放时间</li>
<li><code>Guest_Popularity_percentage</code>：嘉宾人人气百分比</li>
<li><code>Number_of_Ads</code>：广告数量</li>
<li><code>Episode_Sentiment</code>：剧集氛围</li>
<li><code>Listening_Time_minutes</code>：收听时长 – target</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/004.png"
                      alt="photo"
                ></p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.histplot(<span class="built_in">df</span>[<span class="string">&#x27;Episode_Length_minutes&#x27;</span>], kde=True, bins=30)</span><br><span class="line">plt.title(<span class="string">&#x27;Episode_Length_minutes&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/005.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.histplot(<span class="built_in">df</span>[<span class="string">&#x27;Guest_Popularity_percentage&#x27;</span>], kde=True, bins=30)</span><br><span class="line">plt.title(<span class="string">&#x27;Guest_Popularity_percentage&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/006.png"
                      alt="photo"
                ></p>
<p>可以看到 这两个字段的分布情况比较均匀 并且他们都是连续数值型数据 利用均值填充</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">missing_features = [<span class="string">&#x27;Episode_Length_minutes&#x27;</span>, <span class="string">&#x27;Guest_Popularity_percentage&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> missing_features:</span><br><span class="line">    <span class="built_in">df</span>[feature].fillna(<span class="built_in">df</span>[feature].mean(), inplace=True)</span><br><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/007.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.dropna(inplace=True)</span><br><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/008.png"
                      alt="photo"
                ><br>接下来我们查看是否存在异常值<br>利用箱线图来查看是否存在异常值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">features = [<span class="string">&#x27;Episode_Length_minutes&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;Host_Popularity_percentage&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Guest_Popularity_percentage&#x27;</span>, <span class="string">&#x27;Number_of_Ads&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Listening_Time_minutes&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    sns.boxplot(x=<span class="built_in">df</span>[col])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/009.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/010.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/011.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/012.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/013.png"
                      alt="photo"
                ></p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>从上述图中可以看到 Episode_Length_minutes和Number_of_Ads存在异常值</p>
<p>Host_Popularity_percentage和Guest_Popularity_percentage存在超过100的值</p>
<p>从常理来看 百分比不可能大于100</p>
<p>因此 将Episode_Length_minutes和Number_of_Ads的异常值删除</p>
<p>将Host_Popularity_percentage和Guest_Popularity_percentage的异常值进行胜率变换</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">deleted_features = [<span class="string">&#x27;Episode_Length_minutes&#x27;</span>, <span class="string">&#x27;Number_of_Ads&#x27;</span>]</span><br><span class="line">df_cleaned = df.copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> deleted_features:</span><br><span class="line">    Q1 = df_cleaned[col].quantile(0.25)</span><br><span class="line">    Q3 = df_cleaned[col].quantile(0.75)</span><br><span class="line">    IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">    lower_bound = Q1 - 1.5 * IQR</span><br><span class="line">    upper_bound = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只保留当前列在正常范围内的数据（逐步过滤）</span></span><br><span class="line">    df_cleaned = df_cleaned[(df_cleaned[col] &gt;= lower_bound) &amp; (df_cleaned[col] &lt;= upper_bound)]</span><br></pre></td></tr></table></figure></div>

<p>检查一遍</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">features = [<span class="string">&#x27;Episode_Length_minutes&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;Host_Popularity_percentage&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Guest_Popularity_percentage&#x27;</span>, <span class="string">&#x27;Number_of_Ads&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Listening_Time_minutes&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    sns.boxplot(x=df_cleaned[col])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/014.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/015.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/016.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/017.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/018.png"
                      alt="photo"
                ></p>
<p>接下来 我们对字符数据进行处理</p>
<p>值得被编码的特征有：</p>
<ul>
<li>Genre</li>
<li>Publication_Day</li>
<li>Publication_Time</li>
<li>Episode_Sentiment</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df_cleaned[<span class="string">&#x27;Genre&#x27;</span>].describe()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/16/019.png"
                      alt="photo"
                ></p>
<p>发现他们的类别都较少 使用独热编码</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line"></span><br><span class="line">one_hot_features = [<span class="string">&#x27;Genre&#x27;</span>, <span class="string">&#x27;Publication_Day&#x27;</span>, <span class="string">&#x27;Publication_Time&#x27;</span>, <span class="string">&#x27;Episode_Sentiment&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ohe = OneHotEncoder(sparse_output=False, handle_unknown=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">encoded_array = ohe.fit_transform(df_cleaned[one_hot_features])</span><br><span class="line">encoded_cols = ohe.get_feature_names_out(one_hot_features)</span><br><span class="line"></span><br><span class="line">encoded_df = pd.DataFrame(encoded_array, columns=encoded_cols, index=df_cleaned.index)</span><br><span class="line"></span><br><span class="line">df_cleaned_encoded = pd.concat([df_cleaned.drop(columns=one_hot_features), encoded_df], axis=1)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df_cleaned_encoded.drop(columns=[<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;Podcast_Name&#x27;</span>, <span class="string">&#x27;Episode_Title&#x27;</span>], inplace=True)</span><br></pre></td></tr></table></figure></div>

<h3 id="模型选择-模型评估"><a href="#模型选择-模型评估" class="headerlink" title="模型选择&amp;模型评估"></a>模型选择&amp;模型评估</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line"></span><br><span class="line">X = df_cleaned_encoded.drop(columns=[<span class="string">&#x27;Listening_Time_minutes&#x27;</span>])</span><br><span class="line">y = df_cleaned_encoded[<span class="string">&#x27;Listening_Time_minutes&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line"></span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line">rf = RandomForestRegressor(n_estimators=100, random_state=42)</span><br><span class="line">rf.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = rf.predict(X_test_scaled)</span><br><span class="line"></span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Mean Squared Error:&quot;</span>, mse)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;R^2 Score:&quot;</span>, r2)</span><br></pre></td></tr></table></figure></div>

<p>在我的MacBook AirM2上 该模型用时约4‘47秒</p>
<p>Mean Squared Error: 161.35316711251312</p>
<p>R^2 Score: 0.7801317443922687</p>
<p>未进行特征工程</p>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>chatGPT 4o<br>提问的问题：</p>
<ol>
<li>在数据分析中 如何查看是否存在缺失值</li>
<li>针对缺失值 在什么情况下用均值填充 在什么情况下用众数填充 在什么情况下用中位数填充</li>
<li>如何对缺失值做可视化图表 查看缺失值的分布情况</li>
<li>数据分布比较均匀的 其缺失值如何填充</li>
<li>Mean Squared Error: 161.35316711251312 R^2 Score: 0.7801317443922687 这个分数对于一个有29个维度 使用随机森林训练的数据来说怎么样</li>
<li>做相关性矩阵就是做个sns.heatmap吗</li>
<li>我对object进行独热编码后对相关性矩阵<br>这个图看起来很吃力 我该怎么做</li>
<li>代码优化：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line"></span><br><span class="line">one_hot_features = [<span class="string">&#x27;Genre&#x27;</span>, <span class="string">&#x27;Publication_Day&#x27;</span>, <span class="string">&#x27;Publication_Time&#x27;</span>, <span class="string">&#x27;Episode_Sentiment&#x27;</span>]</span><br><span class="line">ohe = OneHotEncoder(sparse=False)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> one_hot_features:</span><br><span class="line">    df_cleaned_encoded = ohe.fit_transform(pd.DataFrame(col))</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">Cell In[18], line 4</span><br><span class="line">      1 from sklearn.preprocessing import OneHotEncoder</span><br><span class="line">      3 one_hot_features = [<span class="string">&#x27;Genre&#x27;</span>, <span class="string">&#x27;Publication_Day&#x27;</span>, <span class="string">&#x27;Publication_Time&#x27;</span>, <span class="string">&#x27;Episode_Sentiment&#x27;</span>]</span><br><span class="line">----&gt; 4 ohe = OneHotEncoder(sparse=False)</span><br><span class="line">      5 encoded_parts = []</span><br><span class="line">      6 <span class="keyword">for</span> col <span class="keyword">in</span> one_hot_features:</span><br><span class="line"></span><br><span class="line">TypeError: OneHotEncoder.__init__() got an unexpected keyword argument <span class="string">&#x27;sparse&#x27;</span></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_selection import SelectKBest, chi2</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用卡方检验选择前 2 个最佳特征</span></span><br><span class="line">selector = SelectKBest(chi2, k=2)</span><br><span class="line">X_new = selector.fit_transform(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择后的特征形状：&quot;</span>, X_new.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每个特征的得分：&quot;</span>, selector.scores_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;是否被选择：&quot;</span>, selector.get_support())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出每个特征的得分</span></span><br><span class="line">scores = pd.Series(selector.scores_, index=X.columns)</span><br><span class="line">scores = scores.sort_values(ascending=False)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方检验得分最高的特征：\n&quot;</span>, scores.head(20))</span><br><span class="line"></span><br><span class="line">显示报错</span><br><span class="line"></span><br><span class="line">ValueError: Unknown label <span class="built_in">type</span>: (array([48.82398, 72.06621,  0.     , ..., 13.09288, 30.92493, 29.3002 ]),)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.decomposition import PCA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 PCA 降维到 2 维</span></span><br><span class="line">pca = PCA(n_components=9)</span><br><span class="line">X_pca = pca.fit_transform(X_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;降维后的数据形状：&quot;</span>, X_pca.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个主成分的贡献率</span></span><br><span class="line">explained_variance = pd.Series(pca.explained_variance_ratio_, index=[f<span class="string">&#x27;PC&#123;i+1&#125;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(9)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主成分贡献率：\n&quot;</span>, explained_variance)</span><br><span class="line"></span><br><span class="line">降维后的数据形状： (599991, 9)</span><br><span class="line">主成分贡献率：</span><br><span class="line"> PC1    0.458917</span><br><span class="line">PC2    0.297558</span><br><span class="line">PC3    0.241425</span><br><span class="line">PC4    0.000588</span><br><span class="line">PC5    0.000160</span><br><span class="line">PC6    0.000159</span><br><span class="line">PC7    0.000125</span><br><span class="line">PC8    0.000119</span><br><span class="line">PC9    0.000114</span><br><span class="line"></span><br><span class="line">我想查看到底是哪9个特征</span><br></pre></td></tr></table></figure></div>
<p>我的此项目的kaggle网址：<br><a class="link"   href="https://www.kaggle.com/code/super213/randomforest-r-2-0-78" >https://www.kaggle.com/code/super213/randomforest-r-2-0-78<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Spaceship Titanic</title>
    <url>/zhihaojiang.github.io/2025/04/18/20250418Spaceship%20Titanic/</url>
    <content><![CDATA[<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p><a class="link"   href="https://www.kaggle.com/competitions/spaceship-titanic/data" >https://www.kaggle.com/competitions/spaceship-titanic/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p>欢迎来到2912年，你需要运用数据科学技能来解开一个宇宙之谜。我们收到了来自四光年外的传输信息，情况看起来不太妙。</p>
<p>泰坦尼克号宇宙飞船是一艘星际客轮，于一个月前发射升空。这艘载有近1.3万名乘客的飞船开始了它的首航，将来自我们太阳系的移民运送到三颗围绕邻近恒星运行的、新发现的宜居系外行星。</p>
<p>在绕过半人马座阿尔法星，前往其首个目的地——炙热的巨蟹座E星——的途中，粗心大意的泰坦尼克号宇宙飞船与隐藏在尘埃云中的时空异常相撞。不幸的是，它遭遇了与一千年前同名飞船相似的命运。虽然飞船完好无损，但几乎一半的乘客被传送到了另一个维度！</p>
<p>为了帮助救援队找回失踪的乘客，您需要使用从宇宙飞船受损的计算机系统中恢复的记录来预测哪些乘客是被异常现象运送的。</p>
<p>帮助拯救他们并改变历史！</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>导入库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/002.png"
                      alt="photo"
                ></p>
<p>现在我们分析一下各个字段的含义：</p>
<ul>
<li>PassengerId：乘客的ID</li>
<li>HomePlanet：乘客出发的星球 通常是他们永久居住的星球</li>
<li>CryoSleep：指示乘客是否选择在航行期间处于休眠状态 处于休眠状态的乘客将被限制在自己的船舱内</li>
<li>Cabin：乘客所住舱位号。格式为deck&#x2F;num&#x2F;side 其中side可以是P左舷 也可以是S右舷 </li>
<li>Destination：乘客即将登陆的星球</li>
<li>Age：乘客的年龄</li>
<li>VIP：乘客是否已支付航行期间的特殊VIP服务费用</li>
<li>RoomService： 乘客在泰坦尼克号宇宙飞船的众多豪华设施中支付的金额</li>
<li>FoodCourt： 乘客在泰坦尼克号宇宙飞船的众多豪华设施中支付的金额</li>
<li>ShoppingMall： 乘客在泰坦尼克号宇宙飞船的众多豪华设施中支付的金额</li>
<li>Spa： 乘客在泰坦尼克号宇宙飞船的众多豪华设施中支付的金额</li>
<li>VRDeck： 乘客在泰坦尼克号宇宙飞船的众多豪华设施中支付的金额</li>
<li>Name：乘客的名字和姓氏</li>
<li>Transported：乘客是否被传送到了另一个维度。这是目标，也就是你要预测的列</li>
</ul>
<h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>我们首先处理缺失值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/003.png"
                      alt="photo"
                ></p>
<p>针对数值型特征 使用均值填充</p>
<p>针对类别型特征 使用众数填充</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">missing_features = [<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;RoomService&#x27;</span>, <span class="string">&#x27;FoodCourt&#x27;</span>, <span class="string">&#x27;ShoppingMall&#x27;</span>, <span class="string">&#x27;Spa&#x27;</span>, <span class="string">&#x27;VRDeck&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> missing_features:</span><br><span class="line">    <span class="built_in">df</span>[feature].fillna(<span class="built_in">df</span>[feature].mean(), inplace=True)</span><br><span class="line"></span><br><span class="line">categorical_features = [<span class="string">&#x27;HomePlanet&#x27;</span>, <span class="string">&#x27;CryoSleep&#x27;</span>, <span class="string">&#x27;Cabin&#x27;</span>,<span class="string">&#x27;Destination&#x27;</span>, <span class="string">&#x27;VIP&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> categorical_features:</span><br><span class="line">    <span class="built_in">df</span>[feature].fillna(<span class="built_in">df</span>[feature].mode()[0], inplace=True)</span><br></pre></td></tr></table></figure></div>

<p>我们删除一些不必要的列 例如id和名称</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.drop(columns=[<span class="string">&#x27;PassengerId&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>], inplace=True)</span><br><span class="line"></span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/004.png"
                      alt="photo"
                ></p>
<p>其中 我发现Cabin这个特征包含了许多信息 将其分为三列</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>[[<span class="string">&#x27;Cabin_deck&#x27;</span>, <span class="string">&#x27;Cabin_num&#x27;</span>, <span class="string">&#x27;Cabin_side&#x27;</span>]] = <span class="built_in">df</span>[<span class="string">&#x27;Cabin&#x27;</span>].str.split(<span class="string">&#x27;/&#x27;</span>, <span class="built_in">expand</span>=True)</span><br><span class="line"></span><br><span class="line">df.drop(columns=[<span class="string">&#x27;Cabin&#x27;</span>], inplace=True)</span><br><span class="line"></span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/005.png"
                      alt="photo"
                ></p>
<h3 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h3><p>用箱线图可视化查看异常值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">features = [<span class="string">&#x27;Age&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;RoomService&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FoodCourt&#x27;</span>, <span class="string">&#x27;ShoppingMall&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Spa&#x27;</span>, <span class="string">&#x27;VRDeck&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    sns.boxplot(x=<span class="built_in">df</span>[col])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/006.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/007.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/008.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/009.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/010.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/011.png"
                      alt="photo"
                ><br>对异常值进行处理</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">features = [ <span class="string">&#x27;RoomService&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FoodCourt&#x27;</span>, <span class="string">&#x27;ShoppingMall&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Spa&#x27;</span>, <span class="string">&#x27;VRDeck&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    <span class="built_in">df</span>[col] = np.log1p(<span class="built_in">df</span>[col])</span><br><span class="line"></span><br><span class="line">    Q1 = <span class="built_in">df</span>[col].quantile(0.25)</span><br><span class="line">    Q3 = <span class="built_in">df</span>[col].quantile(0.75)</span><br><span class="line">    IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">    lower = Q1 - 1.5 * IQR</span><br><span class="line">    upper = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line">    <span class="built_in">df</span>[col] = <span class="built_in">df</span>[col].clip(lower=lower, upper=upper)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Q1 = <span class="built_in">df</span>[<span class="string">&#x27;Age&#x27;</span>].quantile(0.25)</span><br><span class="line">Q3 = <span class="built_in">df</span>[<span class="string">&#x27;Age&#x27;</span>].quantile(0.75)</span><br><span class="line">IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">lower = Q1 - 1.5 * IQR</span><br><span class="line">upper = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Age&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;Age&#x27;</span>].clip(lower=lower, upper=upper)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">features = [<span class="string">&#x27;Age&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;RoomService&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FoodCourt&#x27;</span>, <span class="string">&#x27;ShoppingMall&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Spa&#x27;</span>, <span class="string">&#x27;VRDeck&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    sns.boxplot(x=<span class="built_in">df</span>[col])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/012.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/013.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/014.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/015.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/016.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/017.png"
                      alt="photo"
                ></p>
<h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">features = [<span class="string">&#x27;HomePlanet&#x27;</span>, <span class="string">&#x27;CryoSleep&#x27;</span>, <span class="string">&#x27;Destination&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Cabin_deck&#x27;</span>, <span class="string">&#x27;Cabin_side&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">    sns.countplot(x=feature, hue=<span class="string">&#x27;Transported&#x27;</span>, data=<span class="built_in">df</span>)</span><br><span class="line">    plt.title(feature)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/018.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/019.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/020.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/021.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/022.png"
                      alt="photo"
                ></p>
<h3 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line"></span><br><span class="line">one_hot_features = [<span class="string">&#x27;HomePlanet&#x27;</span>, <span class="string">&#x27;Destination&#x27;</span>, <span class="string">&#x27;CryoSleep&#x27;</span>, <span class="string">&#x27;VIP&#x27;</span>, <span class="string">&#x27;Cabin_deck&#x27;</span>, <span class="string">&#x27;Cabin_side&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ohe = OneHotEncoder(sparse_output=False, handle_unknown=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">encoded_array = ohe.fit_transform(<span class="built_in">df</span>[one_hot_features])</span><br><span class="line">encoded_cols = ohe.get_feature_names_out(one_hot_features)</span><br><span class="line"></span><br><span class="line">encoded_df = pd.DataFrame(encoded_array, columns=encoded_cols, index=df.index)</span><br><span class="line"></span><br><span class="line">df_cleaned_encoded = pd.concat([df.drop(columns=one_hot_features), encoded_df], axis=1)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df_cleaned_encoded.drop(columns=[<span class="string">&#x27;Cabin_num&#x27;</span>], inplace=True)</span><br></pre></td></tr></table></figure></div>

<h3 id="相关性矩阵"><a href="#相关性矩阵" class="headerlink" title="相关性矩阵"></a>相关性矩阵</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = df_cleaned_encoded[<span class="string">&#x27;Transported&#x27;</span>]</span><br><span class="line">X = df_cleaned_encoded.drop([<span class="string">&#x27;Transported&#x27;</span>], axis=1)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">correlation_matrix = pd.concat([X_train, y_train], axis=1).corr()</span><br><span class="line"><span class="comment"># 设置相关性的阈值</span></span><br><span class="line">threshold = 0.2</span><br><span class="line">mask = np.abs(correlation_matrix) &gt; threshold</span><br><span class="line"></span><br><span class="line">sns.heatmap(correlation_matrix, annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>, mask=~mask, center=0)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/024.png"
                      alt="photo"
                ></p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_selection import SelectKBest, chi2</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用卡方检验选择前 2 个最佳特征</span></span><br><span class="line">selector = SelectKBest(chi2, k=9)</span><br><span class="line">X_new = selector.fit_transform(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择后的特征形状：&quot;</span>, X_new.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每个特征的得分：&quot;</span>, selector.scores_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;是否被选择：&quot;</span>, selector.get_support())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出每个特征的得分</span></span><br><span class="line">scores = pd.Series(selector.scores_, index=X.columns)</span><br><span class="line">scores = scores.sort_values(ascending=False)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方检验得分最高的特征：\n&quot;</span>, scores.head(29))</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/025.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方检验得分最低的特征：\n&quot;</span>, scores.tail(15))</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/026.png"
                      alt="photo"
                ></p>
<p>我们将特征分数较低的删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df_cleaned_encoded.drop(columns=[</span><br><span class="line">    <span class="string">&#x27;Cabin_deck_A&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Destination_PSO J318.5-22&#x27;</span></span><br><span class="line">, <span class="string">&#x27;VIP_False&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_T&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_G&#x27;</span></span><br><span class="line">, <span class="string">&#x27;HomePlanet_Mars&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_D&#x27;</span></span><br><span class="line">, <span class="string">&#x27;VIP_True&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Destination_TRAPPIST-1e&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_side_S&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_side_P&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_F&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_E&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Destination_55 Cancri e&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_C&#x27;</span>], inplace=True)</span><br></pre></td></tr></table></figure></div>

<h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = df_cleaned_encoded[<span class="string">&#x27;Transported&#x27;</span>]</span><br><span class="line">X = df_cleaned_encoded.drop([<span class="string">&#x27;Transported&#x27;</span>], axis=1)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line">rf = RandomForestClassifier(n_estimators=100, random_state=42)</span><br><span class="line">rf.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = rf.predict(X_test_scaled)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/027.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import lightgbm as lgb</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line">model = lgb.LGBMClassifier()</span><br><span class="line">model.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = model.predict(X_test_scaled)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征重要性</span></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">lgb.plot_importance(model, max_num_features=20)</span><br><span class="line">plt.title(<span class="string">&quot;Feature Importance&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/028.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/029.png"
                      alt="photo"
                ></p>
<h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay</span><br><span class="line"></span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">disp = ConfusionMatrixDisplay(confusion_matrix=cm)</span><br><span class="line">disp.plot(cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Confusion Matrix&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/18/030.png"
                      alt="photo"
                ></p>
<h2 id="测试集预测"><a href="#测试集预测" class="headerlink" title="测试集预测"></a>测试集预测</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#整理测试集</span></span><br><span class="line">tdf = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">missing_features = [<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;RoomService&#x27;</span>, <span class="string">&#x27;FoodCourt&#x27;</span>, <span class="string">&#x27;ShoppingMall&#x27;</span>, <span class="string">&#x27;Spa&#x27;</span>, <span class="string">&#x27;VRDeck&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> missing_features:</span><br><span class="line">    tdf[feature].fillna(tdf[feature].mean(), inplace=True)</span><br><span class="line"></span><br><span class="line">categorical_features = [<span class="string">&#x27;HomePlanet&#x27;</span>, <span class="string">&#x27;CryoSleep&#x27;</span>, <span class="string">&#x27;Cabin&#x27;</span>,<span class="string">&#x27;Destination&#x27;</span>, <span class="string">&#x27;VIP&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用众数填充缺失值</span></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> categorical_features:</span><br><span class="line">    tdf[feature].fillna(tdf[feature].mode()[0], inplace=True)</span><br><span class="line"></span><br><span class="line">tdf.drop(columns=[<span class="string">&#x27;PassengerId&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>], inplace=True)</span><br><span class="line"></span><br><span class="line">tdf[[<span class="string">&#x27;Cabin_deck&#x27;</span>, <span class="string">&#x27;Cabin_num&#x27;</span>, <span class="string">&#x27;Cabin_side&#x27;</span>]] = tdf[<span class="string">&#x27;Cabin&#x27;</span>].str.split(<span class="string">&#x27;/&#x27;</span>, <span class="built_in">expand</span>=True)</span><br><span class="line"></span><br><span class="line">tdf.drop(columns=[<span class="string">&#x27;Cabin&#x27;</span>], inplace=True)</span><br><span class="line"></span><br><span class="line">features = [ <span class="string">&#x27;RoomService&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;FoodCourt&#x27;</span>, <span class="string">&#x27;ShoppingMall&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Spa&#x27;</span>, <span class="string">&#x27;VRDeck&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    tdf[col] = np.log1p(tdf[col])</span><br><span class="line"></span><br><span class="line">    Q1 = tdf[col].quantile(0.25)</span><br><span class="line">    Q3 = tdf[col].quantile(0.75)</span><br><span class="line">    IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">    lower = Q1 - 1.5 * IQR</span><br><span class="line">    upper = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line">    tdf[col] = tdf[col].clip(lower=lower, upper=upper)</span><br><span class="line"></span><br><span class="line">Q1 = <span class="built_in">df</span>[<span class="string">&#x27;Age&#x27;</span>].quantile(0.25)</span><br><span class="line">Q3 = <span class="built_in">df</span>[<span class="string">&#x27;Age&#x27;</span>].quantile(0.75)</span><br><span class="line">IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">lower = Q1 - 1.5 * IQR</span><br><span class="line">upper = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line">tdf[<span class="string">&#x27;Age&#x27;</span>] = tdf[<span class="string">&#x27;Age&#x27;</span>].clip(lower=lower, upper=upper)</span><br><span class="line"></span><br><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line"></span><br><span class="line">one_hot_features = [<span class="string">&#x27;HomePlanet&#x27;</span>, <span class="string">&#x27;Destination&#x27;</span>, <span class="string">&#x27;CryoSleep&#x27;</span>, <span class="string">&#x27;VIP&#x27;</span>, <span class="string">&#x27;Cabin_deck&#x27;</span>, <span class="string">&#x27;Cabin_side&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ohe = OneHotEncoder(sparse_output=False, handle_unknown=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">encoded_array = ohe.fit_transform(tdf[one_hot_features])</span><br><span class="line">encoded_cols = ohe.get_feature_names_out(one_hot_features)</span><br><span class="line"></span><br><span class="line">encoded_df = pd.DataFrame(encoded_array, columns=encoded_cols, index=tdf.index)</span><br><span class="line"></span><br><span class="line">tdf_cleaned_encoded = pd.concat([tdf.drop(columns=one_hot_features), encoded_df], axis=1)</span><br><span class="line"></span><br><span class="line">tdf_cleaned_encoded.drop(columns=[<span class="string">&#x27;Cabin_num&#x27;</span>], inplace=True)</span><br><span class="line"></span><br><span class="line">tdf_cleaned_encoded.drop(columns=[</span><br><span class="line">    <span class="string">&#x27;Cabin_deck_A&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Destination_PSO J318.5-22&#x27;</span></span><br><span class="line">, <span class="string">&#x27;VIP_False&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_T&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_G&#x27;</span></span><br><span class="line">, <span class="string">&#x27;HomePlanet_Mars&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_D&#x27;</span></span><br><span class="line">, <span class="string">&#x27;VIP_True&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Destination_TRAPPIST-1e&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_side_S&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_side_P&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_F&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_E&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Destination_55 Cancri e&#x27;</span></span><br><span class="line">, <span class="string">&#x27;Cabin_deck_C&#x27;</span>], inplace=True)</span><br><span class="line"></span><br><span class="line">X_test_scaled = scaler.transform(tdf_cleaned_encoded)</span><br><span class="line"></span><br><span class="line">model = lgb.LGBMClassifier()</span><br><span class="line">model.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型预测</span></span><br><span class="line">y_pred = model.predict(tdf_cleaned_encoded)</span><br><span class="line"></span><br><span class="line">tdf = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>)</span><br><span class="line">tdf[<span class="string">&#x27;pred&#x27;</span>] = y_pred</span><br><span class="line"></span><br><span class="line">result = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;iPassengerId&#x27;</span>: tdf[<span class="string">&#x27;PassengerId&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Transported&#x27;</span>: tdf[<span class="string">&#x27;pred&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">result.to_csv(<span class="string">&quot;submission.csv&quot;</span>, index=False)</span><br></pre></td></tr></table></figure></div>

<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>chatGPT 4o<br>提问的问题：</p>
<ol>
<li>我有一份数据 其中的一个特征内容为：B&#x2F;0&#x2F;P 这种形式 如何将这一组数据以“&#x2F;”拆分成三列特征</li>
<li>bool类型的数据怎么处理</li>
<li>bool类型要转换为数值型吗</li>
<li>我想查看类别型与target之间的关系</li>
<li>在数据分析时 我有一列是类别型 但是这一列的内容是数字 如何将其转换为数值型</li>
<li>如何将object类型添加到相关性矩阵查看其相关性</li>
<li>分类问题选择哪个模型好 GBDT怎么样</li>
<li>如何用这个模型来预测测试集</li>
<li>就是说我要重新把测试集也像训练集一样进行处理吗</li>
<li>假设我有两列叫id和pred 我如何将其保存到一个新的csv文件中</li>
<li>代码问题：</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ValueError: Classification metrics can<span class="string">&#x27;t handle a mix of continuous-multioutput and binary targets</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import lightgbm as lgb</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line">model = lgb.LGBMClassifier()</span><br><span class="line">model.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = model.predict(X_test_scaled)</span><br><span class="line"><span class="built_in">print</span>(classification_report(X_test_scaled, y_pred))</span><br><span class="line"></span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Mean Squared Error:&quot;</span>, mse)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;R^2 Score:&quot;</span>, r2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征重要性</span></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">lgb.plot_importance(model, max_num_features=20)</span><br><span class="line">plt.title(<span class="string">&quot;Feature Importance&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">Cell In[67], line 9</span><br><span class="line">      6 model.fit(X_train_scaled, y_train)</span><br><span class="line">      8 y_pred = model.predict(X_test_scaled)</span><br><span class="line">----&gt; 9 <span class="built_in">print</span>(classification_report(X_test, y_pred))</span><br><span class="line">     11 mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">     12 r2 = r2_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line">File /opt/anaconda3/lib/python3.12/site-packages/sklearn/utils/_param_validation.py:213, <span class="keyword">in</span> validate_params.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)</span><br><span class="line">    207 try:</span><br><span class="line">    208     with config_context(</span><br><span class="line">    209         skip_parameter_validation=(</span><br><span class="line">    210             prefer_skip_nested_validation or global_skip_validation</span><br><span class="line">    211         )</span><br><span class="line">    212     ):</span><br><span class="line">--&gt; 213         <span class="built_in">return</span> func(*args, **kwargs)</span><br><span class="line">    214 except InvalidParameterError as e:</span><br><span class="line">    215     <span class="comment"># When the function is just a wrapper around an estimator, we allow</span></span><br><span class="line">    216     <span class="comment"># the function to delegate validation to the estimator, but we replace</span></span><br><span class="line">    217     <span class="comment"># the name of the estimator by the name of the function in the error</span></span><br><span class="line">    218     <span class="comment"># message to avoid confusion.</span></span><br><span class="line">    219     msg = re.sub(</span><br><span class="line">    220         r<span class="string">&quot;parameter of \w+ must be&quot;</span>,</span><br><span class="line">    221         f<span class="string">&quot;parameter of &#123;func.__qualname__&#125; must be&quot;</span>,</span><br><span class="line">...</span><br><span class="line">    116     )</span><br><span class="line">    118 <span class="comment"># We can&#x27;t have more than one value on y_type =&gt; The set is no more needed</span></span><br><span class="line">    119 y_type = y_type.pop()</span><br><span class="line"></span><br><span class="line">ValueError: Classification metrics can<span class="string">&#x27;t handle a mix of continuous-multioutput and binary t</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">Cell In[68], line 11</span><br><span class="line">      8 y_pred = model.predict(X_test_scaled)</span><br><span class="line">      9 <span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line">---&gt; 11 mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">     12 r2 = r2_score(y_test, y_pred)</span><br><span class="line">     14 <span class="built_in">print</span>(<span class="string">&quot;Mean Squared Error:&quot;</span>, mse)</span><br><span class="line"></span><br><span class="line">File /opt/anaconda3/lib/python3.12/site-packages/sklearn/utils/_param_validation.py:213, <span class="keyword">in</span> validate_params.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)</span><br><span class="line">    207 try:</span><br><span class="line">    208     with config_context(</span><br><span class="line">    209         skip_parameter_validation=(</span><br><span class="line">    210             prefer_skip_nested_validation or global_skip_validation</span><br><span class="line">    211         )</span><br><span class="line">    212     ):</span><br><span class="line">--&gt; 213         <span class="built_in">return</span> func(*args, **kwargs)</span><br><span class="line">    214 except InvalidParameterError as e:</span><br><span class="line">    215     <span class="comment"># When the function is just a wrapper around an estimator, we allow</span></span><br><span class="line">    216     <span class="comment"># the function to delegate validation to the estimator, but we replace</span></span><br><span class="line">    217     <span class="comment"># the name of the estimator by the name of the function in the error</span></span><br><span class="line">    218     <span class="comment"># message to avoid confusion.</span></span><br><span class="line">    219     msg = re.sub(</span><br><span class="line">    220         r<span class="string">&quot;parameter of \w+ must be&quot;</span>,</span><br><span class="line">    221         f<span class="string">&quot;parameter of &#123;func.__qualname__&#125; must be&quot;</span>,</span><br><span class="line">...</span><br><span class="line">--&gt; 510 output_errors = np.average((y_true - y_pred) ** <span class="number">2</span>, axis=<span class="number">0</span>, weights=sample_weight)</span><br><span class="line">    <span class="number">512</span> if isinstance(multioutput, str):</span><br><span class="line">    <span class="number">513</span>     if multioutput == &quot;raw_values&quot;:</span><br><span class="line"></span><br><span class="line">TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead.</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">这个是用RandomForestClassifier</span><br><span class="line">precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">       False       0.78      0.75      0.76       861</span><br><span class="line">        True       0.76      0.79      0.77       878</span><br><span class="line"></span><br><span class="line">    accuracy                           0.77      1739</span><br><span class="line">   macro avg       0.77      0.77      0.77      1739</span><br><span class="line">weighted avg       0.77      0.77      0.77      1739</span><br><span class="line"></span><br><span class="line">这个是用GBDT</span><br><span class="line">[LightGBM] [Info] Number of positive: 3500, number of negative: 3454</span><br><span class="line">[LightGBM] [Info] Auto-choosing row-wise multi-threading, the overhead of testing was 0.000422 seconds.</span><br><span class="line">You can <span class="built_in">set</span> `force_row_wise=<span class="literal">true</span>` to remove the overhead.</span><br><span class="line">And <span class="keyword">if</span> memory is not enough, you can <span class="built_in">set</span> `force_col_wise=<span class="literal">true</span>`.</span><br><span class="line">[LightGBM] [Info] Total Bins 1356</span><br><span class="line">[LightGBM] [Info] Number of data points <span class="keyword">in</span> the train <span class="built_in">set</span>: 6954, number of used features: 11</span><br><span class="line">[LightGBM] [Info] [binary:BoostFromScore]: pavg=0.503307 -&gt; initscore=0.013230</span><br><span class="line">[LightGBM] [Info] Start training from score 0.013230</span><br><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">       False       0.80      0.75      0.77       861</span><br><span class="line">        True       0.77      0.82      0.79       878</span><br><span class="line"></span><br><span class="line">    accuracy                           0.78      1739</span><br><span class="line">   macro avg       0.78      0.78      0.78      1739</span><br><span class="line">weighted avg       0.78      0.78      0.78      1739</span><br><span class="line"></span><br><span class="line">他们的结果还可以吗 哪个好</span><br></pre></td></tr></table></figure></div>

<h2 id="kaggle地址"><a href="#kaggle地址" class="headerlink" title="kaggle地址"></a>kaggle地址</h2><p>我的此项目的kaggle网址：<br><a class="link"   href="https://www.kaggle.com/code/super213/randomforest-gbdt-f1-0-77" >https://www.kaggle.com/code/super213/randomforest-gbdt-f1-0-77<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>环境检测</title>
    <url>/zhihaojiang.github.io/2025/04/21/20250421%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h2><p>Arduino UNO R3</p>
<h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p><strong>BMP180</strong></p>
<blockquote>
<p>VCC → 3.3V 或 5V<br>GND → GND<br>SCL → A5<br>SDA → A4</p>
</blockquote>
<p><strong>OLED (SSD1306 I2C)</strong></p>
<blockquote>
<p>VCC → 3.3V 或 5V<br>GND → GND<br>SCL → A5<br>SDA → A4</p>
</blockquote>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>报错信息</p>

    </div>
    <div class="notel-content">
      <p>这两个的SDA和SCL都接A4和A5 可以共用的</p>

    </div>
  </div>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;Wire.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;Adafruit_Sensor.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;Adafruit_BMP085_U.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;Adafruit_GFX.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;Adafruit_SSD1306.h&gt;</span></span><br><span class="line"></span><br><span class="line">// OLED 设置</span><br><span class="line"><span class="comment">#define SCREEN_WIDTH 128</span></span><br><span class="line"><span class="comment">#define SCREEN_HEIGHT 64</span></span><br><span class="line"><span class="comment">#define OLED_RESET    -1</span></span><br><span class="line">Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);</span><br><span class="line"></span><br><span class="line">// BMP180 传感器对象</span><br><span class="line">Adafruit_BMP085_Unified bmp = Adafruit_BMP085_Unified(10085);</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">setup</span></span>() &#123;</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line"></span><br><span class="line">  // 初始化 OLED</span><br><span class="line">  <span class="keyword">if</span> (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;OLED ERROR&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (1);</span><br><span class="line">  &#125;</span><br><span class="line">  display.clearDisplay();</span><br><span class="line">  display.setTextSize(1);</span><br><span class="line">  display.setTextColor(WHITE);</span><br><span class="line"></span><br><span class="line">  // 初始化 BMP180</span><br><span class="line">  <span class="keyword">if</span> (!bmp.begin()) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;can&#x27;t find BMP180&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">loop</span></span>() &#123;</span><br><span class="line">  sensors_event_t event;</span><br><span class="line">  bmp.getEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">  display.clearDisplay();</span><br><span class="line">  display.setCursor(0, 0);</span><br><span class="line">  display.println(<span class="string">&quot;Environment&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.pressure) &#123;</span><br><span class="line">    display.setCursor(0, 20);</span><br><span class="line">    display.print(<span class="string">&quot;ATM: &quot;</span>);</span><br><span class="line">    display.print(event.pressure);</span><br><span class="line">    display.println(<span class="string">&quot; hPa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> temperature;</span><br><span class="line">    bmp.getTemperature(&amp;temperature);</span><br><span class="line"></span><br><span class="line">    display.setCursor(0, 40);</span><br><span class="line">    display.print(<span class="string">&quot;temperature: &quot;</span>);</span><br><span class="line">    display.print(temperature);</span><br><span class="line">    display.println(<span class="string">&quot; C&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    display.setCursor(0, 20);</span><br><span class="line">    display.println(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  display.display();</span><br><span class="line">  delay(1000);  // 每秒刷新一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>超声波雷达测距</title>
    <url>/zhihaojiang.github.io/2025/04/21/20250421%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9B%B7%E8%BE%BE%E6%B5%8B%E8%B7%9D/</url>
    <content><![CDATA[<h2 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h2><p>Arduino UNO R3</p>
<h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p><strong>HC-SR04</strong></p>
<blockquote>
<p>VCC → 3.3V 或 5V<br>GND → GND<br>Trig → Arduino D9<br>Echo → Arduino D10</p>
</blockquote>
<p><strong>OLED (SSD1306 I2C)</strong></p>
<blockquote>
<p>VCC → 3.3V 或 5V<br>GND → GND<br>SCL → A5<br>SDA → A4</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;Adafruit_GFX.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;Adafruit_SSD1306.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TRIG_PIN 9</span></span><br><span class="line"><span class="comment">#define ECHO_PIN 10</span></span><br><span class="line"><span class="comment">#define SCREEN_WIDTH 128</span></span><br><span class="line"><span class="comment">#define SCREEN_HEIGHT 64</span></span><br><span class="line"><span class="comment">#define OLED_RESET     -1</span></span><br><span class="line">Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">setup</span></span>() &#123;</span><br><span class="line">  pinMode(TRIG_PIN, OUTPUT);</span><br><span class="line">  pinMode(ECHO_PIN, INPUT);</span><br><span class="line"></span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  <span class="keyword">if</span>(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) &#123;</span><br><span class="line">    Serial.println(F(<span class="string">&quot;OLED init failed&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span>(;;);</span><br><span class="line">  &#125;</span><br><span class="line">  display.clearDisplay();</span><br><span class="line">  display.display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> <span class="function"><span class="title">getDistance</span></span>() &#123;</span><br><span class="line">  digitalWrite(TRIG_PIN, LOW);</span><br><span class="line">  delayMicroseconds(2);</span><br><span class="line">  digitalWrite(TRIG_PIN, HIGH);</span><br><span class="line">  delayMicroseconds(10);</span><br><span class="line">  digitalWrite(TRIG_PIN, LOW);</span><br><span class="line">  long duration = pulseIn(ECHO_PIN, HIGH);</span><br><span class="line">  <span class="built_in">return</span> duration * 0.034 / 2;  // 距离（厘米）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int posX = 0; // 用来在横向慢慢移动</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">loop</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">      // 绘制两边的参考线</span><br><span class="line">  display.drawLine(0, 0, 0, SCREEN_HEIGHT, WHITE);  // 左边的距离线</span><br><span class="line">  display.drawLine(SCREEN_WIDTH - 1, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT, WHITE);  // 右边的距离线</span><br><span class="line">  display.display();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">float</span> distance = getDistance();  // 单位 cm</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Distance: &quot;</span>);</span><br><span class="line">  Serial.println(distance);</span><br><span class="line"></span><br><span class="line">  // 归一化距离（最多显示到60cm）</span><br><span class="line">  int r = map(min(distance, 60.0), 0, 60, SCREEN_HEIGHT - 1, 0); // 越远越上</span><br><span class="line"></span><br><span class="line">  display.drawPixel(posX, r, WHITE);</span><br><span class="line">  posX++;</span><br><span class="line">  <span class="keyword">if</span> (posX &gt;= SCREEN_WIDTH) &#123;</span><br><span class="line">    posX = 0;</span><br><span class="line">    display.clearDisplay(); // 清除屏幕从头来</span><br><span class="line">  &#125;</span><br><span class="line">  display.display();</span><br><span class="line">  delay(100); // 每秒10个点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中的优化方法及其python实现</title>
    <url>/zhihaojiang.github.io/2025/04/26/20250426%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p><a class="link"   href="https://www.kaggle.com/datasets/mirichoi0218/insurance/data" >https://www.kaggle.com/datasets/mirichoi0218/insurance/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p>About Dataset<br>Context<br>Machine Learning with R by Brett Lantz is a book that provides an introduction to machine learning using R. As far as I can tell, Packt Publishing does not make its datasets available online unless you buy the book and create a user account which can be a problem if you are checking the book out from the library or borrowing the book from a friend. All of these datasets are in the public domain but simply needed some cleaning up and recoding to match the format in the book.</p>
<p>Content<br>Columns</p>
<p>age: age of primary beneficiary</p>
<p>sex: insurance contractor gender, female, male</p>
<p>bmi: Body mass index, providing an understanding of body, weights that are relatively high or low relative to height,<br>objective index of body weight (kg &#x2F; m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9</p>
<p>children: Number of children covered by health insurance &#x2F; Number of dependents</p>
<p>smoker: Smoking</p>
<p>region: the beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.</p>
<p>charges: Individual medical costs billed by health insurance</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler, OneHotEncoder</span><br><span class="line">from sklearn.compose import ColumnTransformer</span><br><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.metrics import mean_squared_error, r2_score</span><br></pre></td></tr></table></figure></div>

<h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;insurance.csv&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/002.png"
                      alt="photo"
                ></p>
<h3 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">num_cols = df.select_dtypes(include=[np.number]).columns.tolist()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> num_cols:</span><br><span class="line">    sns.boxplot(x=col, data=<span class="built_in">df</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/003.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/004.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/005.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/006.png"
                      alt="photo"
                ></p>
<p>可以看到 bmi有异常值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from scipy.stats import mstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 胜率变换：将异常值限制在 5% 和 95% 分位数之间</span></span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;bmi&#x27;</span>] = mstats.winsorize(<span class="built_in">df</span>[<span class="string">&#x27;bmi&#x27;</span>], limits=[0.05, 0.05])</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">object_cols = df.select_dtypes(include=[<span class="string">&#x27;object&#x27;</span>]).columns.tolist()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> object_cols:</span><br><span class="line">    sns.countplot(x=col, data=<span class="built_in">df</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/007.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/008.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/009.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此图来源：https://www.kaggle.com/code/analyticaobscura/medical-cost-analysis</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(10, 6))</span><br><span class="line">sns.kdeplot(</span><br><span class="line">    data=<span class="built_in">df</span>, </span><br><span class="line">    x=<span class="string">&quot;age&quot;</span>, </span><br><span class="line">    y=<span class="string">&quot;charges&quot;</span>, </span><br><span class="line">    cmap=<span class="string">&quot;Purples&quot;</span>, </span><br><span class="line">    shade=True,     </span><br><span class="line">    cbar=True       </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Age vs Medical Charges KDE Plot&quot;</span>, fontsize=16, color=<span class="string">&#x27;indigo&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Age&quot;</span>, fontsize=12, color=<span class="string">&#x27;slateblue&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Medical Charges ($)&quot;</span>, fontsize=12, color=<span class="string">&#x27;slateblue&#x27;</span>)</span><br><span class="line">plt.grid(True, color=<span class="string">&#x27;lavender&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/015.png"
                      alt="photo"
                ></p>
<p>可以看到 费用与年龄的关系不大<br>大部份人的费用在 10000 左右 并且费用呈现3个档次：10000以下 20000左右 35000左右</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此图来源：https://www.kaggle.com/code/analyticaobscura/medical-cost-analysis</span></span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(1, 2, figsize=(16, 6))</span><br><span class="line">colors = sns.color_palette(<span class="string">&quot;Purples&quot;</span>, 2)  </span><br><span class="line"></span><br><span class="line">sns.boxplot(</span><br><span class="line">    ax=axes[0], </span><br><span class="line">    data=<span class="built_in">df</span>, </span><br><span class="line">    x=<span class="string">&quot;smoker&quot;</span>, </span><br><span class="line">    y=<span class="string">&quot;charges&quot;</span>, </span><br><span class="line">    palette=<span class="string">&quot;Purples&quot;</span></span><br><span class="line">    )</span><br><span class="line">axes[0].set_title(<span class="string">&quot;Medical Charges by Smoking Status&quot;</span>, fontsize=16, color=<span class="string">&#x27;indigo&#x27;</span>)</span><br><span class="line">axes[0].set_xlabel(<span class="string">&quot;Smoker&quot;</span>, fontsize=12, color=<span class="string">&#x27;slateblue&#x27;</span>)</span><br><span class="line">axes[0].set_ylabel(<span class="string">&quot;Medical Charges ($)&quot;</span>, fontsize=12, color=<span class="string">&#x27;slateblue&#x27;</span>)</span><br><span class="line">axes[0].grid(True, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;lavender&#x27;</span>)</span><br><span class="line"></span><br><span class="line">smoker_counts = <span class="built_in">df</span>[<span class="string">&#x27;smoker&#x27;</span>].value_counts()</span><br><span class="line">axes[1].pie(</span><br><span class="line">    smoker_counts, </span><br><span class="line">    labels=smoker_counts.index, </span><br><span class="line">    autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, </span><br><span class="line">    colors=colors, </span><br><span class="line">    startangle=140, </span><br><span class="line">    wedgeprops=&#123;<span class="string">&#x27;edgecolor&#x27;</span>: <span class="string">&#x27;white&#x27;</span>&#125;</span><br><span class="line">)</span><br><span class="line">axes[1].set_title(<span class="string">&quot;Proportion of Smokers vs Non-Smokers&quot;</span>, fontsize=16, color=<span class="string">&#x27;indigo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/016.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plt.subplots(figsize=(10, 6))</span><br><span class="line">plt.subplot(1, 2, 1)</span><br><span class="line">sns.countplot(x=<span class="string">&#x27;smoker&#x27;</span>, data=<span class="built_in">df</span>,hue=<span class="string">&#x27;sex&#x27;</span>, palette=<span class="string">&#x27;Purples&#x27;</span>)</span><br><span class="line">plt.subplot(1, 2, 2)</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;smoker&#x27;</span>,y = <span class="string">&#x27;charges&#x27;</span>, data=<span class="built_in">df</span>,hue=<span class="string">&#x27;sex&#x27;</span>, palette=<span class="string">&#x27;Purples&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/017.png"
                      alt="photo"
                ></p>
<p>可以看到 调查者中不吸烟的占大多数 吸烟者中 男性较多 并且 不吸烟的人医疗费用远小于吸烟者</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">&#x27;children&#x27;</span>,y = <span class="string">&#x27;charges&#x27;</span>, data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/018.png"
                      alt="photo"
                ></p>
<p>可以看到 有3个孩子的人医疗费用最高 不过我认为 孩子越多费用越高 不过那4和5比3要低 可能因为幸存者偏差：负担的费用过高而破产、自杀、没被记录所导致的</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">&#x27;region&#x27;</span>, y=<span class="string">&#x27;charges&#x27;</span>,data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/019.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(</span><br><span class="line">    x=<span class="string">&#x27;bmi&#x27;</span>, </span><br><span class="line">    y=<span class="string">&#x27;charges&#x27;</span>, </span><br><span class="line">    shade=True,</span><br><span class="line">    cmap=<span class="string">&#x27;Purples&#x27;</span>,</span><br><span class="line">    data=<span class="built_in">df</span></span><br><span class="line">    )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/020.png"
                      alt="photo"
                ></p>
<p>可以看到 大部份人的bmi指数在20～40之间 且费用都在10000左右 通过查询得知 bmi指数在18.5～24.9之间为正常范围 由此得知 现在人们的bmi指数普遍偏高</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">&#x27;sex&#x27;</span>,y = <span class="string">&#x27;bmi&#x27;</span>,hue=<span class="string">&#x27;children&#x27;</span> ,data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/021.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.lmplot(x=<span class="string">&#x27;age&#x27;</span>,y = <span class="string">&#x27;bmi&#x27;</span> ,data=<span class="built_in">df</span>, line_kws=&#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;orange&#x27;</span>&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/022.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此图来源：https://www.kaggle.com/code/analyticaobscura/medical-cost-analysis</span></span><br><span class="line"></span><br><span class="line">average_charges_by_region = df.groupby(<span class="string">&#x27;region&#x27;</span>)[<span class="string">&#x27;charges&#x27;</span>].mean().reset_index()</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(1, 2, figsize=(16, 6)) </span><br><span class="line">colors = sns.color_palette(<span class="string">&quot;Purples&quot;</span>, len(average_charges_by_region))  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sns.barplot(</span><br><span class="line">    ax=axes[0], </span><br><span class="line">    data=average_charges_by_region, </span><br><span class="line">    x=<span class="string">&quot;region&quot;</span>, </span><br><span class="line">    y=<span class="string">&quot;charges&quot;</span>, </span><br><span class="line">    palette=<span class="string">&quot;Purples&quot;</span></span><br><span class="line">    )</span><br><span class="line">axes[0].set_title(<span class="string">&quot;Average Medical Charges by Region&quot;</span>, fontsize=16, color=<span class="string">&#x27;indigo&#x27;</span>)</span><br><span class="line">axes[0].set_xlabel(<span class="string">&quot;Region&quot;</span>, fontsize=12, color=<span class="string">&#x27;slateblue&#x27;</span>)</span><br><span class="line">axes[0].set_ylabel(<span class="string">&quot;Average Medical Charges ($)&quot;</span>, fontsize=12, color=<span class="string">&#x27;slateblue&#x27;</span>)</span><br><span class="line">axes[0].grid(True, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;lavender&#x27;</span>)</span><br><span class="line"></span><br><span class="line">charges = average_charges_by_region[<span class="string">&#x27;charges&#x27;</span>]</span><br><span class="line">regions = average_charges_by_region[<span class="string">&#x27;region&#x27;</span>]</span><br><span class="line">explode = [0.1 <span class="keyword">if</span> i == charges.idxmax() <span class="keyword">else</span> 0 <span class="keyword">for</span> i <span class="keyword">in</span> range(len(charges))] </span><br><span class="line">axes[1].pie(</span><br><span class="line">    charges, </span><br><span class="line">    labels=regions, </span><br><span class="line">    autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, </span><br><span class="line">    colors=colors, </span><br><span class="line">    explode=explode, </span><br><span class="line">    shadow=True, </span><br><span class="line">    startangle=140, </span><br><span class="line">    wedgeprops=&#123;<span class="string">&#x27;edgecolor&#x27;</span>: <span class="string">&#x27;white&#x27;</span>&#125;</span><br><span class="line">)</span><br><span class="line">axes[1].set_title(<span class="string">&quot;Proportion of Average Charges by Region&quot;</span>, fontsize=16, color=<span class="string">&#x27;indigo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/023.png"
                      alt="photo"
                ></p>
<h3 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X = df.drop(columns=[<span class="string">&#x27;charges&#x27;</span>])</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;charges&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br></pre></td></tr></table></figure></div>

<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>数值型 归一化<br>类别型 独热编码</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">num_cols = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;bmi&#x27;</span>, <span class="string">&#x27;children&#x27;</span>]</span><br><span class="line">obj_cols = [<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>, <span class="string">&#x27;region&#x27;</span>]</span><br><span class="line"></span><br><span class="line">preprocessor = ColumnTransformer([</span><br><span class="line">    (<span class="string">&#x27;scale_num&#x27;</span>, StandardScaler(), num_cols),</span><br><span class="line">    (<span class="string">&#x27;encode_obj&#x27;</span>, OneHotEncoder(), obj_cols)</span><br><span class="line">])</span><br></pre></td></tr></table></figure></div>

<h3 id="模型建立（线性回归）"><a href="#模型建立（线性回归）" class="headerlink" title="模型建立（线性回归）"></a>模型建立（线性回归）</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">preprocessor.fit(X_train)</span><br><span class="line"></span><br><span class="line">X_train_processed = preprocessor.transform(X_train)</span><br><span class="line">X_test_processed = preprocessor.transform(X_test)</span><br><span class="line"></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_train_processed, y_train)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y_pred = model.predict(X_test_processed)</span><br><span class="line"></span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line">score = model.score(X_test_processed, y_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mse =&quot;</span>, mse)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;R2 =&quot;</span>, r2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;score =&quot;</span>, score)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/010.png"
                      alt="photo"
                ></p>
<h3 id="使用不同的优化算法进行优化"><a href="#使用不同的优化算法进行优化" class="headerlink" title="使用不同的优化算法进行优化"></a>使用不同的优化算法进行优化</h3><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X_train_array = X_train_processed</span><br><span class="line">X_test_array = X_test_processed</span><br><span class="line"></span><br><span class="line">results = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line">def gradient_descent(X, y, lr=0.01, n_epochs=1000):</span><br><span class="line">    m, n = X.shape</span><br><span class="line">    w = np.random.randn(n)</span><br><span class="line">    b = 0</span><br><span class="line">    losses = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        y_pred = X @ w + b</span><br><span class="line">        error = y_pred - y</span><br><span class="line">        grad_w = (1/m) * X.T @ error</span><br><span class="line">        grad_b = (1/m) * np.sum(error)</span><br><span class="line"></span><br><span class="line">        w -= lr * grad_w</span><br><span class="line">        b -= lr * grad_b</span><br><span class="line"></span><br><span class="line">        loss = (1/(2*m)) * np.sum(error**2)</span><br><span class="line">        losses.append(loss)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> w, b, losses</span><br><span class="line"></span><br><span class="line">w_gd, b_gd, losses_gd = gradient_descent(X_train_array, y_train.values, lr=0.002, n_epochs=20000)</span><br><span class="line">y_pred_gd = X_test_array @ w_gd + b_gd</span><br><span class="line">results[<span class="string">&#x27;Gradient Descent&#x27;</span>] = &#123;</span><br><span class="line">    <span class="string">&#x27;MSE&#x27;</span>: mean_squared_error(y_test, y_pred_gd),</span><br><span class="line">    <span class="string">&#x27;R2&#x27;</span>: r2_score(y_test, y_pred_gd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results_df = pd.DataFrame(results).T</span><br><span class="line"><span class="built_in">print</span>(results_df)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(8, 5))</span><br><span class="line">plt.plot(range(1, len(losses_gd)+1), losses_gd, label=<span class="string">&#x27;Gradient Descent Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss (MSE)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Learning Curve - Gradient Descent&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/012.png"
                      alt="photo"
                ></p>
<h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 牛顿法（正规方程）</span></span><br><span class="line">X_train_bias = np.hstack([X_train_array, np.ones((X_train_array.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_test_bias = np.hstack([X_test_array, np.ones((X_test_array.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line"></span><br><span class="line">XTX = X_train_bias.T @ X_train_bias</span><br><span class="line">XTy = X_train_bias.T @ y_train.values</span><br><span class="line">w_newton = np.linalg.pinv(XTX) @ XTy</span><br><span class="line">y_pred_newton = X_test_bias @ w_newton</span><br><span class="line"></span><br><span class="line">results[<span class="string">&quot;Newton&#x27;s Method&quot;</span>] = &#123;</span><br><span class="line">    <span class="string">&#x27;MSE&#x27;</span>: mean_squared_error(y_test, y_pred_newton),</span><br><span class="line">    <span class="string">&#x27;R2&#x27;</span>: r2_score(y_test, y_pred_newton)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results_df = pd.DataFrame(results).T</span><br><span class="line"><span class="built_in">print</span>(results_df)</span><br></pre></td></tr></table></figure></div>

<h4 id="SGDRegressor"><a href="#SGDRegressor" class="headerlink" title="SGDRegressor"></a>SGDRegressor</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model import SGDRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn SGDRegressor</span></span><br><span class="line">sgd_model = SGDRegressor(penalty=None,max_iter=10000, learning_rate=<span class="string">&#x27;adaptive&#x27;</span>, eta0=0.001, random_state=42)</span><br><span class="line">sgd_model.fit(X_train_array, y_train)</span><br><span class="line">y_pred_sgd = sgd_model.predict(X_test_array)</span><br><span class="line">results[<span class="string">&#x27;SGDRegressor (sklearn)&#x27;</span>] = &#123;</span><br><span class="line">    <span class="string">&#x27;MSE&#x27;</span>: mean_squared_error(y_test, y_pred_sgd),</span><br><span class="line">    <span class="string">&#x27;R2&#x27;</span>: r2_score(y_test, y_pred_sgd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="动量法"><a href="#动量法" class="headerlink" title="动量法"></a>动量法</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动量法</span></span><br><span class="line">def momentum_optimizer(X, y, lr=0.01, n_epochs=1000, beta=0.9):</span><br><span class="line">    m, n = X.shape</span><br><span class="line">    w = np.random.randn(n)  <span class="comment"># 初始化权重</span></span><br><span class="line">    b = 0  <span class="comment"># 初始化偏置</span></span><br><span class="line"></span><br><span class="line">    v_w = np.zeros(n)  <span class="comment"># 初始化动量</span></span><br><span class="line">    v_b = 0  <span class="comment"># 初始化偏置动量</span></span><br><span class="line"></span><br><span class="line">    losses = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        y_pred = X @ w + b</span><br><span class="line">        error = y_pred - y</span><br><span class="line"></span><br><span class="line">        grad_w = (1/m) * (X.T @ error)</span><br><span class="line">        grad_b = (1/m) * np.sum(error)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新动量</span></span><br><span class="line">        v_w = beta * v_w + (1 - beta) * grad_w</span><br><span class="line">        v_b = beta * v_b + (1 - beta) * grad_b</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        w -= lr * v_w</span><br><span class="line">        b -= lr * v_b</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算损失</span></span><br><span class="line">        loss = (1/(2*m)) * np.sum(error**2)</span><br><span class="line">        losses.append(loss)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> w, b, losses</span><br><span class="line">    </span><br><span class="line">w_momentum, b_momentum, losses_momentum = momentum_optimizer(X_train_array, y_train.values, lr=0.001, n_epochs=10000, beta=0.9)</span><br><span class="line"></span><br><span class="line">y_pred_momentum = X_test_array @ w_momentum + b_momentum</span><br><span class="line"></span><br><span class="line">results[<span class="string">&#x27;momentum_optimizer&#x27;</span>] = &#123;</span><br><span class="line">    <span class="string">&#x27;MSE&#x27;</span>: mean_squared_error(y_test, y_pred_momentum),</span><br><span class="line">    <span class="string">&#x27;R2&#x27;</span>: r2_score(y_test, y_pred_momentum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(8, 5))</span><br><span class="line">plt.plot(range(1, len(losses_momentum)+1), losses_momentum, label=<span class="string">&#x27;momentum_optimizer Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss (MSE)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Learning Curve - momentum_optimizer&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/013.png"
                      alt="photo"
                ></p>
<h4 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Adam优化器</span></span><br><span class="line">def adam_optimizer(X, y, lr=0.001, n_epochs=1000, beta1=0.9, beta2=0.999, epsilon=1e-8):</span><br><span class="line">    m, n = X.shape</span><br><span class="line">    w = np.random.randn(n)  <span class="comment"># 初始化权重</span></span><br><span class="line">    b = 0  <span class="comment"># 初始化偏置</span></span><br><span class="line"></span><br><span class="line">    m_w = np.zeros(n)  <span class="comment"># 初始化一阶矩</span></span><br><span class="line">    v_w = np.zeros(n)  <span class="comment"># 初始化二阶矩</span></span><br><span class="line">    m_b = 0  <span class="comment"># 初始化偏置的一阶矩</span></span><br><span class="line">    v_b = 0  <span class="comment"># 初始化偏置的二阶矩</span></span><br><span class="line"></span><br><span class="line">    losses = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        y_pred = X @ w + b</span><br><span class="line">        error = y_pred - y</span><br><span class="line"></span><br><span class="line">        grad_w = (1/m) * (X.T @ error)</span><br><span class="line">        grad_b = (1/m) * np.sum(error)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新一阶矩和二阶矩</span></span><br><span class="line">        m_w = beta1 * m_w + (1 - beta1) * grad_w</span><br><span class="line">        v_w = beta2 * v_w + (1 - beta2) * (grad_w ** 2)</span><br><span class="line">        m_b = beta1 * m_b + (1 - beta1) * grad_b</span><br><span class="line">        v_b = beta2 * v_b + (1 - beta2) * (grad_b ** 2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算偏差修正</span></span><br><span class="line">        m_w_hat = m_w / (1 - beta1 ** (epoch + 1))</span><br><span class="line">        v_w_hat = v_w / (1 - beta2 ** (epoch + 1))</span><br><span class="line">        m_b_hat = m_b / (1 - beta1 ** (epoch + 1))</span><br><span class="line">        v_b_hat = v_b / (1 - beta2 ** (epoch + 1))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新权重和偏置</span></span><br><span class="line">        w -= lr * m_w_hat / (np.sqrt(v_w_hat) + epsilon)</span><br><span class="line">        b -= lr * m_b_hat / (np.sqrt(v_b_hat) + epsilon)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算损失</span></span><br><span class="line">        loss = (1/(2*m)) * np.sum(error**2)</span><br><span class="line">        losses.append(loss)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> w, b, losses</span><br><span class="line">    </span><br><span class="line">w_adam, b_adam, losses_adam = adam_optimizer(X_train_array, y_train.values, lr=0.0001, n_epochs=50000,beta1=0.85)</span><br><span class="line"></span><br><span class="line">y_pred_adam = X_test_array @ w_adam + b_adam</span><br><span class="line"></span><br><span class="line">results[<span class="string">&#x27;adam_optimizer&#x27;</span>] = &#123;</span><br><span class="line">    <span class="string">&#x27;MSE&#x27;</span>: mean_squared_error(y_test, y_pred_adam),</span><br><span class="line">    <span class="string">&#x27;R2&#x27;</span>: r2_score(y_test, y_pred_adam)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(8, 5))</span><br><span class="line">plt.plot(range(1, len(losses_adam)+1), losses_adam, label=<span class="string">&#x27;adam_optimizer Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss (MSE)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Learning Curve - adam_optimizer&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/014.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">results_df = pd.DataFrame(results).T</span><br><span class="line"><span class="built_in">print</span>(results_df)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/04/26/011.png"
                      alt="photo"
                ></p>
<h3 id="使用随机森林预测"><a href="#使用随机森林预测" class="headerlink" title="使用随机森林预测"></a>使用随机森林预测</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line"></span><br><span class="line">rf_model = RandomForestRegressor(n_estimators=100, random_state=42)</span><br><span class="line">rf_model.fit(X_train_processed, y_train)</span><br><span class="line"></span><br><span class="line">y_pred_rf = rf_model.predict(X_test_array)</span><br><span class="line"></span><br><span class="line">mse_rf = mean_squared_error(y_test, y_pred_rf)</span><br><span class="line">r2_rf = r2_score(y_test, y_pred_rf)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Random Forest MSE: &#123;mse_rf:.4f&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Random Forest R2: &#123;r2_rf:.4f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Random Forest MSE: 21083936.2878<br>Random Forest R2: 0.8642</p>
</blockquote>
<h4 id="贝叶斯优化"><a href="#贝叶斯优化" class="headerlink" title="贝叶斯优化"></a>贝叶斯优化</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from hyperopt import fmin, tpe, hp, STATUS_OK, Trials</span><br><span class="line"></span><br><span class="line">def objective(params):</span><br><span class="line">    model = RandomForestRegressor(</span><br><span class="line">        n_estimators=int(params[<span class="string">&#x27;n_estimators&#x27;</span>]),</span><br><span class="line">        max_depth=int(params[<span class="string">&#x27;max_depth&#x27;</span>]),</span><br><span class="line">        min_samples_split=int(params[<span class="string">&#x27;min_samples_split&#x27;</span>]),</span><br><span class="line">        min_samples_leaf=int(params[<span class="string">&#x27;min_samples_leaf&#x27;</span>]),</span><br><span class="line">        random_state=42</span><br><span class="line">    )</span><br><span class="line">    model.fit(X_train_processed, y_train)</span><br><span class="line">    y_pred = model.predict(X_test_processed)</span><br><span class="line">    mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">    rmse = np.sqrt(mse)</span><br><span class="line">    <span class="built_in">return</span> &#123;<span class="string">&#x27;loss&#x27;</span>: rmse,<span class="string">&#x27;status&#x27;</span>: STATUS_OK&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义超参数空间</span></span><br><span class="line">space = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: hp.quniform(<span class="string">&#x27;n_estimators&#x27;</span>, 50, 200, 1),</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: hp.quniform(<span class="string">&#x27;max_depth&#x27;</span>, 5, 20, 1),</span><br><span class="line">    <span class="string">&#x27;min_samples_split&#x27;</span>: hp.quniform(<span class="string">&#x27;min_samples_split&#x27;</span>, 2, 10, 1),</span><br><span class="line">    <span class="string">&#x27;min_samples_leaf&#x27;</span>: hp.quniform(<span class="string">&#x27;min_samples_leaf&#x27;</span>, 1, 4, 1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 定义优化算法</span></span><br><span class="line">tpe_algorithm = tpe.suggest</span><br><span class="line"><span class="comment"># 定义优化过程</span></span><br><span class="line">trials = Trials()</span><br><span class="line">best = fmin(fn=objective,</span><br><span class="line">            space=space,</span><br><span class="line">            algo=tpe_algorithm,</span><br><span class="line">            max_evals=20,</span><br><span class="line">            trials=trials)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best parameters found: &quot;</span>, best)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>100%|██████████| 20&#x2F;20 [00:02&lt;00:00,  6.72trial&#x2F;s, best loss: 4357.951533549515]<br>Best parameters found:  {‘max_depth’: 7.0, ‘min_samples_leaf’: 3.0, ‘min_samples_split’: 7.0, ‘n_estimators’: 81.0}</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">best_model = RandomForestRegressor(</span><br><span class="line">    n_estimators=int(best[<span class="string">&#x27;n_estimators&#x27;</span>]),</span><br><span class="line">    max_depth=int(best[<span class="string">&#x27;max_depth&#x27;</span>]),</span><br><span class="line">    min_samples_split=int(best[<span class="string">&#x27;min_samples_split&#x27;</span>]),</span><br><span class="line">    min_samples_leaf=int(best[<span class="string">&#x27;min_samples_leaf&#x27;</span>]),</span><br><span class="line">    random_state=42</span><br><span class="line">)</span><br><span class="line">best_model.fit(X_train_processed, y_train)</span><br><span class="line">y_pred = best_model.predict(X_test_processed)</span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">rmse = np.sqrt(mse)</span><br><span class="line">R2 = r2_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;RMSE: &#123;rmse&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;R2: &#123;R2&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>RMSE: 4357.951533549515<br>R2: 0.8776689420501131</p>
</blockquote>
<h4 id="网格优化"><a href="#网格优化" class="headerlink" title="网格优化"></a>网格优化</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line"></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: [100, 200, 300],</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: [10, 20, None],</span><br><span class="line">    <span class="string">&#x27;min_samples_split&#x27;</span>: [2, 5, 10],</span><br><span class="line">    <span class="string">&#x27;min_samples_leaf&#x27;</span>: [1, 2, 4],</span><br><span class="line">    <span class="string">&#x27;max_features&#x27;</span>: [<span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;log2&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GridSearchCV</span></span><br><span class="line">grid_search = GridSearchCV(</span><br><span class="line">    estimator=rf_model,</span><br><span class="line">    param_grid=param_grid,</span><br><span class="line">    cv=5,             <span class="comment"># 5折交叉验证</span></span><br><span class="line">    n_jobs=-1,        <span class="comment"># 用所有CPU核加速</span></span><br><span class="line">    verbose=2         <span class="comment"># 输出搜索过程</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">grid_search.fit(X_train_processed, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优参数：&quot;</span>, grid_search.best_params_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优得分：&quot;</span>, grid_search.best_score_)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>最优参数： {‘max_depth’: 10, ‘max_features’: ‘sqrt’, ‘min_samples_leaf’: 2, ‘min_samples_split’: 2, ‘n_estimators’: 300}<br>最优得分： 0.8405858915839397</p>
</blockquote>
<p>综上 无论是线性回归还是随机森林 在进行优化后 他们的分数都至少上升了1% 说明使用优化器进行优化是有效果的</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Predict Calorie Expenditure</title>
    <url>/zhihaojiang.github.io/2025/05/09/20250509Predict%20Calorie%20Expenditure/</url>
    <content><![CDATA[<h1 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h1><p><a class="link"   href="https://www.kaggle.com/competitions/playground-series-s5e5/data" >https://www.kaggle.com/competitions/playground-series-s5e5/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>The dataset for this competition (both train and test) was generated from a deep learning model trained on the Calories Burnt Prediction dataset. Feature distributions are close to, but not exactly the same, as the original. Feel free to use the original dataset as part of this competition, both to explore differences as well as to see whether incorporating the original in training improves model performance.</p>
<p>Files<br>train.csv - the training dataset; Calories is the continuous target<br>test.csv - the test dataset; your objective is to predict the Calories for each row<br>sample_submission.csv - a sample submission file in the correct format.</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>导入库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br></pre></td></tr></table></figure></div>

<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/002.png"
                      alt="photo"
                ></p>
<p>通过翻译得到每个特征的意思：</p>
<ul>
<li>Sex: 性别，1表示男性，0表示女性</li>
<li>Age: 年龄</li>
<li>Height: 身高，单位为厘米</li>
<li>Weight: 体重，单位为千克</li>
<li>Duration: 活动持续时间，单位为分钟</li>
<li>Heart_Rate: 心率，每分钟的心跳次数</li>
<li>Body_Temp: 体温，单位为摄氏度</li>
<li>Calories: 卡路里，这是我们要预测的目标变量</li>
</ul>
<p>我们首先检查数据集中是否存在缺失值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.drop(columns=[<span class="string">&#x27;id&#x27;</span>], inplace=True)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/003.png"
                      alt="photo"
                ></p>
<p>可以看到 没有缺失值</p>
<p>由于我们要预测卡路里的消耗量 因此我们自然想到BMI这个指标与人体有关 因此添加BMI这个特征</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;BMI&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;Weight&#x27;</span>] / (<span class="built_in">df</span>[<span class="string">&#x27;Height&#x27;</span>] / 100) ** 2</span><br></pre></td></tr></table></figure></div>
<h2 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h2><p>将性别转换为数值型</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Sex&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;Sex&#x27;</span>].replace(&#123;<span class="string">&#x27;male&#x27;</span>: 1, <span class="string">&#x27;female&#x27;</span>: 0&#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    plt.scatter(<span class="built_in">df</span>[col], <span class="built_in">df</span>[<span class="string">&#x27;Calories&#x27;</span>])</span><br><span class="line">    plt.xlabel(col)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Calories&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/004.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/005.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/006.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/007.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/008.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/009.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/010.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/011.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/012.png"
                      alt="photo"
                ></p>
<p>可以看到 duration、Heart_Rate、Body_Temp与Calories呈线性关系<br>接下来我们查看特征与特征之间的相关性。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.countplot(x=pd.cut(<span class="built_in">df</span>[<span class="string">&#x27;Weight&#x27;</span>], bins=20, labels=False), data=<span class="built_in">df</span>,hue=<span class="string">&#x27;Sex&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/013.png"
                      alt="photo"
                ></p>
<p>可以看到 男性的体重分布是偏右的，而女性的体重分布是偏左的</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.lineplot(x=<span class="string">&#x27;Height&#x27;</span>,y=<span class="string">&#x27;Weight&#x27;</span>,data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/014.png"
                      alt="photo"
                ></p>
<p>可以看到 Weight与Height存在正相关</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.lineplot(x=<span class="string">&#x27;Duration&#x27;</span>,y=<span class="string">&#x27;Heart_Rate&#x27;</span>,data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/015.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.lineplot(x=<span class="string">&#x27;Duration&#x27;</span>,y=<span class="string">&#x27;Body_Temp&#x27;</span>,data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/016.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.lineplot(x=<span class="string">&#x27;Heart_Rate&#x27;</span>,y=<span class="string">&#x27;Body_Temp&#x27;</span>,data=<span class="built_in">df</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/017.png"
                      alt="photo"
                ></p>
<h2 id="异常值可视化检测"><a href="#异常值可视化检测" class="headerlink" title="异常值可视化检测"></a>异常值可视化检测</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    sns.boxplot(x=<span class="built_in">df</span>[col])</span><br><span class="line">    plt.title(col)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/018.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/019.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/020.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/021.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/022.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/023.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/024.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/025.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/026.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from scipy.stats import mstats</span><br><span class="line"></span><br><span class="line">features = [<span class="string">&#x27;Height&#x27;</span>, <span class="string">&#x27;Weight&#x27;</span>, <span class="string">&#x27;Heart_Rate&#x27;</span>, <span class="string">&#x27;Body_Temp&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> features:</span><br><span class="line">    <span class="built_in">df</span>[col] = mstats.winsorize(<span class="built_in">df</span>[col], limits=[0.05, 0.05])</span><br></pre></td></tr></table></figure></div>

<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.corr()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/09/027.png"
                      alt="photo"
                ></p>
<p>可以看到在相关性分析中</p>
<p><code>Calories</code>与<code>Duration</code>、<code>Heart_Rate</code>、<code>Body_Temp</code>的相关性最高<br>为0.959908、0.908748、0.828671，因此选择这三个特征作为模型的输入特征<br>接下来 我们通过卡方检验来选择特征</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;Calories&#x27;</span>]</span><br><span class="line">X = df.drop([<span class="string">&#x27;Calories&#x27;</span>], axis=1)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_selection import SelectKBest, chi2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用卡方检验选择前 2 个最佳特征</span></span><br><span class="line">selector = SelectKBest(chi2, k=3)</span><br><span class="line">X_new = selector.fit_transform(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择后的特征形状：&quot;</span>, X_new.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每个特征的得分：&quot;</span>, selector.scores_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;是否被选择：&quot;</span>, selector.get_support())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出每个特征的得分</span></span><br><span class="line">scores = pd.Series(selector.scores_, index=X.columns)</span><br><span class="line">scores = scores.sort_values(ascending=False)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方检验得分最高的特征：\n&quot;</span>, scores.head(10))</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>选择后的特征形状： (600000, 3)<br>每个特征的得分： [8.72102007e+03 2.13858892e+05 1.32375353e+04 4.71694088e+04<br> 2.61568982e+06 4.35154289e+05 6.94410801e+03 1.65968833e+03]<br>是否被选择： [False  True False False  True  True False False]<br>卡方检验得分最高的特征：<br> Duration      2.615690e+06<br>Heart_Rate    4.351543e+05<br>Age           2.138589e+05<br>Weight        4.716941e+04<br>Height        1.323754e+04<br>Sex           8.721020e+03<br>Body_Temp     6.944108e+03<br>BMI           1.659688e+03<br>dtype: float64</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.drop(columns=[<span class="string">&#x27;BMI&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Weight&#x27;</span>, <span class="string">&#x27;Height&#x27;</span>], inplace=True)</span><br></pre></td></tr></table></figure></div>

<h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;Calories&#x27;</span>]</span><br><span class="line">X = df.drop([<span class="string">&#x27;Calories&#x27;</span>], axis=1)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br></pre></td></tr></table></figure></div>

<h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line">import xgboost as xgb</span><br><span class="line">from sklearn.ensemble import GradientBoostingRegressor</span><br><span class="line">from sklearn.metrics import root_mean_squared_error, root_mean_squared_log_error, r2_score</span><br><span class="line"></span><br><span class="line">models = &#123;</span><br><span class="line">    <span class="string">&#x27;Linear Regression&#x27;</span>: LinearRegression(),</span><br><span class="line">    <span class="string">&#x27;Random Forest&#x27;</span>: RandomForestRegressor(),</span><br><span class="line">    <span class="string">&#x27;XGBoost&#x27;</span>: xgb.XGBRegressor(),</span><br><span class="line">    <span class="string">&#x27;Gradient Boosting&#x27;</span>: GradientBoostingRegressor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models.items():</span><br><span class="line">    y_train_log = np.log1p(y_train)</span><br><span class="line">    model.fit(X_train_scaled, y_train_log)</span><br><span class="line">    y_pred_log = model.predict(X_test_scaled)</span><br><span class="line">    y_pred = np.expm1(y_pred_log)</span><br><span class="line"></span><br><span class="line">    rmse = root_mean_squared_error(y_test, y_pred)</span><br><span class="line">    rmsle = root_mean_squared_log_error(y_test, y_pred)</span><br><span class="line">    r2 = r2_score(y_test, y_pred)</span><br><span class="line">    </span><br><span class="line">    results.append(&#123;</span><br><span class="line">        <span class="string">&#x27;Model&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;RMSE&#x27;</span>: rmse,</span><br><span class="line">        <span class="string">&#x27;RMSLE&#x27;</span>: rmsle,</span><br><span class="line">        <span class="string">&#x27;R²&#x27;</span>: r2</span><br><span class="line">    &#125;)</span><br><span class="line">results_df = pd.DataFrame(results)</span><br><span class="line"><span class="built_in">print</span>(results_df)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<pre><code>           Model       RMSE     RMSLE        R²
</code></pre>
<p>0  Linear Regression  16.044743  0.212877  0.933576<br>1      Random Forest   7.287551  0.102109  0.986297<br>2            XGBoost   6.839083  0.096267  0.987931<br>3  Gradient Boosting   7.001537  0.097709  0.987351</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>糖尿病预测分析</title>
    <url>/zhihaojiang.github.io/2025/05/18/20250518%E7%B3%96%E5%B0%BF%E7%97%85%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>心血管病、糖尿病等慢性疾病，每年导致的死亡人数占总死亡人数的80%，每年用于慢病医疗费用占中国公共医疗卫生支出的比例超过13%。作为一种常见慢性疾病，糖尿病目前无法根治，但通过科学有效的干预、预防和治疗，能降低发病率和提高患者的生活质量。本课题拟对UCI的糖尿病诊断数据集进行机器学习建模分析，在此基础上探讨诱发糖尿病的重要病因</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>导入库</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from scipy.stats import mstats</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.svm import SVC</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line">from xgboost import XGBClassifier</span><br><span class="line"></span><br><span class="line">from skopt import BayesSearchCV</span><br><span class="line">from skopt.space import Integer, Real</span><br><span class="line">from sklearn.model_selection import StratifiedKFold</span><br><span class="line">from sklearn.metrics import recall_score</span><br><span class="line">from skopt.space import Real, Categorical</span><br><span class="line">from sklearn.metrics import classification_report, confusion_matrix, accuracy_score</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import data_analysis_tools as dat <span class="comment">#我自己创建的库</span></span><br></pre></td></tr></table></figure></div>

<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>=pd.read_csv(<span class="string">&#x27;pima-indians-diabetes.data.csv&#x27;</span>)</span><br><span class="line">dat.summarize_df(<span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>{‘head’:      6    148    72    35      0  33.6  0.627    50    1  Unnamed: 9  <br> 0  1.0   85.0  66.0  29.0    0.0  26.6  0.351  31.0  0.0         NaN<br> 1  8.0  183.0  64.0   0.0    0.0  23.3  0.672  32.0  1.0         NaN<br> 2  1.0   89.0  66.0  23.0   94.0  28.1  0.167  21.0  0.0         NaN<br> 3  0.0  137.0  40.0  35.0  168.0  43.1  2.288  33.0  1.0         NaN<br> 4  5.0  116.0  74.0   0.0    0.0  25.6  0.201  30.0  0.0         NaN   </p>
<pre><code>Unnamed: 10  Unnamed: 11 Unnamed: 12  
</code></pre>
<p> 0          NaN          NaN         NaN<br> 1          NaN          NaN         NaN<br> 2          NaN          NaN         NaN<br> 3          NaN          NaN         NaN<br> 4          NaN          NaN         NaN  ,<br> ‘tail’:       6  148  72  35   0  33.6  0.627  50   1  Unnamed: 9  Unnamed: 10  <br> 772 NaN  NaN NaN NaN NaN   NaN    NaN NaN NaN         NaN          NaN<br> 773 NaN  NaN NaN NaN NaN   NaN    NaN NaN NaN         NaN          NaN<br> 774 NaN  NaN NaN NaN NaN   NaN    NaN NaN NaN         NaN          NaN<br> 775 NaN  NaN NaN NaN NaN   NaN    NaN NaN NaN         NaN          NaN<br> 776 NaN  NaN NaN NaN NaN   NaN    NaN NaN NaN         NaN          NaN   </p>
<pre><code>  Unnamed: 11                                        Unnamed: 12  
</code></pre>
<p> 772          NaN                # 5. 2-Hour serum insulin (mu U&#x2F;ml)<br> 773          NaN  # 6. Body mass index (weight in kg&#x2F;(height in …<br> 774          NaN                    # 7. Diabetes pedigree function<br> 775          NaN                                   # 8. Age (years)<br> 776          NaN                       # 9. Class variable (0 or 1)  ,<br> ‘describe’:                  6         148          72          35           0  <br> count   767.000000  767.000000  767.000000  767.000000  767.000000<br> unique         NaN         NaN         NaN         NaN         NaN<br> top            NaN         NaN         NaN         NaN         NaN<br> freq           NaN         NaN         NaN         NaN         NaN<br> mean      3.842243  120.859192   69.101695   20.517601   79.903520<br> std       3.370877   31.978468   19.368155   15.954059  115.283105<br> min       0.000000    0.000000    0.000000    0.000000    0.000000<br> 25%       1.000000   99.000000   62.000000    0.000000    0.000000<br> 50%       3.000000  117.000000   72.000000   23.000000   32.000000<br> 75%       6.000000  140.000000   80.000000   32.000000  127.500000<br> max      17.000000  199.000000  122.000000   99.000000  846.000000   </p>
<pre><code>           33.6       0.627          50           1  Unnamed: 9  \
</code></pre>
<p> count   767.000000  767.000000  767.000000  767.000000         0.0<br> unique         NaN         NaN         NaN         NaN         NaN<br> top            NaN         NaN         NaN         NaN         NaN<br> freq           NaN         NaN         NaN         NaN         NaN<br> mean     31.990482    0.471674   33.219035    0.348110         NaN<br> std       7.889091    0.331497   11.752296    0.476682         NaN<br> min       0.000000    0.078000   21.000000    0.000000         NaN<br> 25%      27.300000    0.243500   24.000000    0.000000         NaN<br> 50%      32.000000    0.371000   29.000000    0.000000         NaN<br> 75%      36.600000    0.625000   41.000000    1.000000         NaN<br> max      67.100000    2.420000   81.000000    1.000000         NaN   </p>
<pre><code>     Unnamed: 10  Unnamed: 11                    Unnamed: 12  
</code></pre>
<p> count           0.0          0.0                              9<br> unique          NaN          NaN                              9<br> top             NaN          NaN  # 1. Number of times pregnant<br> freq            NaN          NaN                              1<br> mean            NaN          NaN                            NaN<br> std             NaN          NaN                            NaN<br> min             NaN          NaN                            NaN<br> 25%             NaN          NaN                            NaN<br> 50%             NaN          NaN                            NaN<br> 75%             NaN          NaN                            NaN<br> max             NaN          NaN                            NaN  ,<br> ‘info’: “&lt;class ‘pandas.core.frame.DataFrame’&gt;\nRangeIndex: 777 entries, 0 to 776\nData columns (total 13 columns):\n #   Column       Non-Null Count  Dtype  \n—  ——       ————–  —–  \n 0   6            767 non-null    float64\n 1   148          767 non-null    float64\n 2   72           767 non-null    float64\n 3   35           767 non-null    float64\n 4   0            767 non-null    float64\n 5   33.6         767 non-null    float64\n 6   0.627        767 non-null    float64\n 7   50           767 non-null    float64\n 8   1            767 non-null    float64\n 9   Unnamed: 9   0 non-null      float64\n 10  Unnamed: 10  0 non-null      float64\n 11  Unnamed: 11  0 non-null      float64\n 12  Unnamed: 12  9 non-null      object \ndtypes: float64(12), object(1)\nmemory usage: 79.0+ KB\n”,<br> ‘dtypes’: 6              float64<br> 148            float64<br> 72             float64<br> 35             float64<br> 0              float64<br> 33.6           float64<br> 0.627          float64<br> 50             float64<br> 1              float64<br> Unnamed: 9     float64<br> Unnamed: 10    float64<br> Unnamed: 11    float64<br> Unnamed: 12     object<br> dtype: object,<br> ‘missing’: 6               10<br> 148             10<br> 72              10<br> 35              10<br> 0               10<br> 33.6            10<br> 0.627           10<br> 50              10<br> 1               10<br> Unnamed: 9     777<br> Unnamed: 10    777<br> Unnamed: 11    777<br> Unnamed: 12    768<br> dtype: int64}</p>
</blockquote>
<p>通过上述查看，我们得知此数据集的特征描述在文件的右下角，我们将字段名称补充进去</p>
<p>我们首先得到列名</p>
<p>df.columns.tolist()</p>
<blockquote>
<p>[‘6’,<br> ‘148’,<br> ‘72’,<br> ‘35’,<br> ‘0’,<br> ‘33.6’,<br> ‘0.627’,<br> ‘50’,<br> ‘1’,<br> ‘Unnamed: 9’,<br> ‘Unnamed: 10’,<br> ‘Unnamed: 11’,<br> ‘Unnamed: 12’]</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.drop([ <span class="string">&#x27;Unnamed: 9&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Unnamed: 10&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Unnamed: 11&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Unnamed: 12&#x27;</span>], axis=1, inplace=True)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/003.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/004.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">columns = [</span><br><span class="line">    <span class="string">&quot;Number of times pregnant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Plasma glucose concentration&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Diastolic blood pressure (mm Hg)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Triceps skin fold thickness (mm)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2-Hour serum insulin (mu U/ml)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Body mass index (kg/m^2)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Diabetes pedigree function&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age (years)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Class variable&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加字段名称</span></span><br><span class="line">df.columns = columns</span><br><span class="line"></span><br><span class="line">new_row = pd.Series([6, 148, 72, 35, 0, 33.6, 0.627, 50, 1], index=df.columns)</span><br><span class="line"><span class="built_in">df</span> =pd.concat([<span class="built_in">df</span>, new_row.to_frame().T], ignore_index=True)</span><br><span class="line"></span><br><span class="line">df.tail()</span><br><span class="line"></span><br><span class="line">df.to_csv(<span class="string">&#x27;new_pima-indians-diabetes.data.csv&#x27;</span>, index=False)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>=pd.read_csv(<span class="string">&#x27;new_pima-indians-diabetes.data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>从之前的输出中我们可以看到有空白行 将其删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = df.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Number of times pregnant            0<br>Plasma glucose concentration        0<br>Diastolic blood pressure (mm Hg)    0<br>Triceps skin fold thickness (mm)    0<br>2-Hour serum insulin (mu U&#x2F;ml)      0<br>Body mass index (kg&#x2F;m^2)            0<br>Diabetes pedigree function          0<br>Age (years)                         0<br>Class variable                      0<br>dtype: int64</p>
</blockquote>
<ul>
<li>Number of times pregnant</li>
<li>怀孕次数</li>
<li>Plasma glucose concentration a 2 hours in an oral glucose tolerance test</li>
<li>口服葡萄糖耐量试验中 2 小时的血浆葡萄糖浓度</li>
<li>Diastolic blood pressure (mm Hg)</li>
<li>舒张压（毫米汞柱）</li>
<li>Triceps skin fold thickness (mm)</li>
<li>三头肌皮褶厚度（毫米）</li>
<li>2-Hour serum insulin (mu U&#x2F;ml)</li>
<li>2 小时血清胰岛素（微单位&#x2F;毫升）</li>
<li>Body mass index (weight in kg&#x2F;(height in m)^2)</li>
<li>体重指数（体重以千克除以身高以米的平方）</li>
<li>Diabetes pedigree function</li>
<li>糖尿病家族史功能</li>
<li>Age (years)</li>
<li>年龄（年）</li>
<li>Class variable (0 or 1)</li>
<li>类别变量（0 或 1）</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/005.png"
                      alt="photo"
                ></p>
<p>从min中看到，有0元素，像是Diastolic blood pressure (mm Hg)之类的特征不应该存在0</p>
<p>说明这是缺失值，用均值填充</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">columns = [<span class="string">&#x27;Plasma glucose concentration&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Diastolic blood pressure (mm Hg)&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Triceps skin fold thickness (mm)&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;2-Hour serum insulin (mu U/ml)&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Body mass index (kg/m^2)&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Diabetes pedigree function&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Age (years)&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> columns:</span><br><span class="line">    mean_value = df.loc[<span class="built_in">df</span>[col] != 0, col].mean()</span><br><span class="line">    <span class="built_in">df</span>[col] = <span class="built_in">df</span>[col].replace(0, mean_value)</span><br></pre></td></tr></table></figure></div>

<p>接下来我们查看是否存在异常值 通过查询相关信息，得到了以下结果</p>
<ol>
<li>Number of times pregnant (怀孕次数)<br>正常范围 ：0 到任意正整数。<br>解释 ：这是一个计数字段，表示一个人怀孕的次数。通常没有上限，但常见的范围是 0 到 15 次（极少数情况下可能更高）。</li>
<li>Plasma glucose concentration a 2 hours in an oral glucose tolerance test (口服葡萄糖耐量试验中 2 小时的血浆葡萄糖浓度)<br>单位 ：mg&#x2F;dL 或 mmol&#x2F;L<br>正常范围 ：<br>正常：小于 140 mg&#x2F;dL（7.8 mmol&#x2F;L）<br>空腹血糖受损（IFG）或糖耐量受损（IGT）：140-199 mg&#x2F;dL（7.8-11.1 mmol&#x2F;L）<br>糖尿病：大于等于 200 mg&#x2F;dL（11.1 mmol&#x2F;L）<br>解释 ：这是诊断糖尿病的重要指标之一。通过口服葡萄糖耐量试验（OGTT），可以评估身体对葡萄糖的代谢能力。</li>
<li>Diastolic blood pressure (mm Hg) (舒张压，毫米汞柱)<br>正常范围 ：60-80 mm Hg<br>异常范围 ：<br>高血压前期：80-89 mm Hg<br>高血压：大于等于 90 mm Hg<br>低血压：小于 60 mm Hg<br>解释 ：舒张压是指心脏放松时血管内的压力。长期高血压可能导致心血管疾病。</li>
<li>Triceps skin fold thickness (mm) (三头肌皮褶厚度，毫米)<br>正常范围 （因性别和年龄而异）：<br>男性：约 10-15 mm<br>女性：约 15-25 mm<br>解释 ：三头肌皮褶厚度用于估算体脂百分比。较高的值可能表明较高的体脂水平。</li>
<li>2-Hour serum insulin (mu U&#x2F;ml) (2 小时血清胰岛素，微单位&#x2F;毫升)<br>正常范围 ：小于 30 mu U&#x2F;ml<br>解释 ：胰岛素是调节血糖的关键激素。高胰岛素水平可能表明胰岛素抵抗或糖尿病前期。</li>
<li>Body mass index (BMI) (体重指数，kg&#x2F;m²)<br>正常范围 ：18.5-24.9<br>分类 ：<br>低于 18.5：体重过轻<br>18.5-24.9：正常体重<br>25-29.9：超重<br>大于等于 30：肥胖<br>解释 ：BMI 是衡量体重是否健康的常用指标，但它不考虑肌肉质量等因素。</li>
<li>Diabetes pedigree function (糖尿病家族史功能)<br>单位 ：无单位（通常是概率值）<br>正常范围 ：0 到 1<br>解释 ：这是一个计算值，表示患糖尿病的概率。值越高，患糖尿病的风险越大。具体范围因模型而异，但通常在 0 到 1 之间。</li>
</ol>
<p>通过查看 没有存在那种明显超过人类水平的异常值</p>
<h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dat.plot_all_barplots(<span class="built_in">df</span>, hue=<span class="string">&#x27;Class variable&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/023.png"
                      alt="photo"
                ></p>
<p>可以看到 有糖尿病的患者各项指标均比非糖尿病的患者高</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.corr()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/014.png"
                      alt="photo"
                ></p>
<p>我们重点关系class variable行 可以看到 Plasma glucose concentration的相关性最高，为0.492928 但仍然不能算作强相关<br>尽管数据中的值在真实世界中都是合理的 但一些特别大的值在进行机器学习时会影响模型的泛化能力，使用IQR方法将异常值替换成边界值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dat.plot_all_boxplots(<span class="built_in">df</span>,exclude_columns=[<span class="string">&#x27;Class variable&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> columns:</span><br><span class="line">    <span class="comment"># 计算 IQR</span></span><br><span class="line">    Q1 = <span class="built_in">df</span>[col].quantile(0.25)</span><br><span class="line">    Q3 = <span class="built_in">df</span>[col].quantile(0.75)</span><br><span class="line">    IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义上下界</span></span><br><span class="line">    lower_bound = Q1 - 1.5 * IQR</span><br><span class="line">    upper_bound = Q3 + 1.5 * IQR</span><br><span class="line"></span><br><span class="line">    <span class="built_in">df</span>[col] = np.where(</span><br><span class="line">    <span class="built_in">df</span>[col] &lt; lower_bound,  </span><br><span class="line">    lower_bound,            </span><br><span class="line">    np.where(</span><br><span class="line">        <span class="built_in">df</span>[col] &gt; upper_bound,  </span><br><span class="line">        upper_bound,           </span><br><span class="line">        <span class="built_in">df</span>[col]                </span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dat.plot_all_boxplots(<span class="built_in">df</span>,exclude_columns=[<span class="string">&#x27;Class variable&#x27;</span>])</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/024.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/025.png"
                      alt="photo"
                ></p>
<h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X = df.drop(columns=[<span class="string">&#x27;Class variable&#x27;</span>])</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;Class variable&#x27;</span>]  <span class="comment"># 目标变量</span></span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X_scaled_df, y, test_size=0.2, random_state=42)</span><br></pre></td></tr></table></figure></div>

<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dat.plot_feature_distributions(<span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/026.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dat.detect_skewness(<span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/05/18/027.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">std = dat.DataStandardizer(method=<span class="string">&#x27;boxcox&#x27;</span>, cols=[<span class="string">&#x27;Number of times pregnant&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Plasma glucose concentration&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Triceps skin fold thickness (mm)&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;2-Hour serum insulin (mu U/ml)&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Body mass index (kg/m^2)&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Diabetes pedigree function&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Age (years)&#x27;</span>])</span><br><span class="line">std.fit(X_train,cols=[<span class="string">&#x27;Number of times pregnant&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Plasma glucose concentration&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Triceps skin fold thickness (mm)&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;2-Hour serum insulin (mu U/ml)&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Body mass index (kg/m^2)&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Diabetes pedigree function&#x27;</span>, </span><br><span class="line">                               <span class="string">&#x27;Age (years)&#x27;</span>])</span><br><span class="line">X_train = std.transform(X_train)</span><br><span class="line">X_test = std.transform(X_test)</span><br></pre></td></tr></table></figure></div>

<h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">models = &#123;</span><br><span class="line">    <span class="string">&quot;RandomForestClassifier&quot;</span>: RandomForestClassifier(n_estimators=100, random_state=42,class_weight=<span class="string">&#x27;balanced&#x27;</span>),</span><br><span class="line">    <span class="string">&quot;LogisticRegression&quot;</span>: LogisticRegression(max_iter=1000, random_state=42,class_weight=<span class="string">&#x27;balanced&#x27;</span>),</span><br><span class="line">    <span class="string">&quot;SVM&quot;</span>: SVC(probability=True, random_state=42,class_weight=<span class="string">&#x27;balanced&#x27;</span>),</span><br><span class="line">    <span class="string">&quot;KNN&quot;</span>: KNeighborsClassifier(),</span><br><span class="line">    <span class="string">&quot;XGBoost&quot;</span>: XGBClassifier(eval_metric=<span class="string">&#x27;logloss&#x27;</span>, random_state=42)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化结果字典</span></span><br><span class="line">results = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个模型</span></span><br><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models.items():  <span class="comment"># 假设 models 是一个字典，键为模型名称，值为模型对象</span></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    model.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预测测试集</span></span><br><span class="line">    y_pred = model.predict(X_test)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算准确率</span></span><br><span class="line">    accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取分类报告</span></span><br><span class="line">    report = classification_report(y_test, y_pred, output_dict=True)  <span class="comment"># 返回字典格式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 存储结果</span></span><br><span class="line">    results[name] = &#123;</span><br><span class="line">        <span class="string">&#x27;accuracy&#x27;</span>: accuracy,</span><br><span class="line">        <span class="string">&#x27;report&#x27;</span>: report</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出每个模型的结果</span></span><br><span class="line"><span class="keyword">for</span> name, result <span class="keyword">in</span> results.items():</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;模型: &#123;name&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;准确率: &#123;result[&#x27;accuracy&#x27;]:.4f&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分类报告:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(classification_report(y_test, models[name].predict(X_test)))  <span class="comment"># 打印格式化的分类报告</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * 50)</span><br></pre></td></tr></table></figure></div>

<p>模型: RandomForestClassifier<br>准确率: 0.7597<br>分类报告:<br>              precision    recall  f1-score   support</p>
<pre><code>     0.0       0.79      0.84      0.81        97
     1.0       0.69      0.63      0.66        57

accuracy                           0.76       154
</code></pre>
<p>   macro avg       0.74      0.73      0.74       154<br>weighted avg       0.76      0.76      0.76       154</p>
<hr>
<p>模型: LogisticRegression<br>准确率: 0.7468<br>分类报告:<br>              precision    recall  f1-score   support</p>
<pre><code>     0.0       0.83      0.75      0.79        97
     1.0       0.64      0.74      0.68        57

accuracy                           0.75       154
</code></pre>
<p>   macro avg       0.73      0.74      0.74       154<br>weighted avg       0.76      0.75      0.75       154</p>
<hr>
<p>模型: SVM<br>准确率: 0.5779<br>分类报告:<br>              precision    recall  f1-score   support</p>
<pre><code>     0.0       0.68      0.62      0.65        97
     1.0       0.44      0.51      0.47        57

accuracy                           0.58       154
</code></pre>
<p>   macro avg       0.56      0.56      0.56       154<br>weighted avg       0.59      0.58      0.58       154</p>
<hr>
<p>模型: KNN<br>准确率: 0.6558<br>分类报告:<br>              precision    recall  f1-score   support</p>
<pre><code>     0.0       0.71      0.77      0.74        97
     1.0       0.54      0.46      0.50        57

accuracy                           0.66       154
</code></pre>
<p>   macro avg       0.62      0.61      0.62       154<br>weighted avg       0.65      0.66      0.65       154</p>
<hr>
<p>模型: XGBoost<br>准确率: 0.7597<br>分类报告:<br>              precision    recall  f1-score   support</p>
<pre><code>     0.0       0.82      0.79      0.81        97
     1.0       0.67      0.70      0.68        57

accuracy                           0.76       154
</code></pre>
<p>   macro avg       0.74      0.75      0.75       154<br>weighted avg       0.76      0.76      0.76       154</p>
<hr>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>由于我们是要预测糖尿病，要做到减少漏诊，因此我们更关心召回率，提高召回率，精确率不必在意</p>
<p><strong>随机森林的优化</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义参数搜索空间</span></span><br><span class="line">param_space = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: Integer(50, 300),</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: Integer(3, 30),</span><br><span class="line">    <span class="string">&#x27;min_samples_split&#x27;</span>: Integer(2, 20),</span><br><span class="line">    <span class="string">&#x27;min_samples_leaf&#x27;</span>: Integer(1, 10),</span><br><span class="line">    <span class="string">&#x27;max_features&#x27;</span>: Real(0.1, 1.0, prior=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">rf = RandomForestClassifier(random_state=42, class_weight=<span class="string">&#x27;balanced&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 贝叶斯优化搜索</span></span><br><span class="line">opt = BayesSearchCV(</span><br><span class="line">    rf,</span><br><span class="line">    search_spaces=param_space,</span><br><span class="line">    scoring=<span class="string">&#x27;recall&#x27;</span>,</span><br><span class="line">    n_iter=30,  <span class="comment"># 搜索的步数（越大越好）</span></span><br><span class="line">    cv=StratifiedKFold(n_splits=5),</span><br><span class="line">    random_state=42,</span><br><span class="line">    n_jobs=-1,</span><br><span class="line">    verbose=2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合模型</span></span><br><span class="line">opt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best Recall Score:&quot;</span>, opt.best_score_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best Parameters:&quot;</span>, opt.best_params_)</span><br></pre></td></tr></table></figure></div>

<p><strong>XGBoost的优化</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算类别不平衡比例，用于 scale_pos_weight</span></span><br><span class="line">neg, pos = (y_train == 0).<span class="built_in">sum</span>(), (y_train == 1).<span class="built_in">sum</span>()</span><br><span class="line">scale_pos_weight = neg / pos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索空间</span></span><br><span class="line">param_space = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: Integer(50, 300),</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: Integer(3, 15),</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: Real(0.01, 0.3, prior=<span class="string">&#x27;log-uniform&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: Real(0.5, 1.0),</span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: Real(0.5, 1.0),</span><br><span class="line">    <span class="string">&#x27;gamma&#x27;</span>: Real(0, 5),</span><br><span class="line">    <span class="string">&#x27;min_child_weight&#x27;</span>: Integer(1, 10)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型</span></span><br><span class="line">xgb = XGBClassifier(</span><br><span class="line">    objective=<span class="string">&#x27;binary:logistic&#x27;</span>,</span><br><span class="line">    eval_metric=<span class="string">&#x27;logloss&#x27;</span>,</span><br><span class="line">    use_label_encoder=False,</span><br><span class="line">    random_state=42,</span><br><span class="line">    scale_pos_weight=scale_pos_weight  <span class="comment"># 处理类别不平衡</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 贝叶斯优化器</span></span><br><span class="line">opt = BayesSearchCV(</span><br><span class="line">    xgb,</span><br><span class="line">    search_spaces=param_space,</span><br><span class="line">    scoring=<span class="string">&#x27;recall&#x27;</span>,  <span class="comment"># 重点优化召回率</span></span><br><span class="line">    cv=StratifiedKFold(n_splits=5),</span><br><span class="line">    n_iter=30,  <span class="comment"># 迭代次数（越大越好）</span></span><br><span class="line">    n_jobs=-1,</span><br><span class="line">    verbose=2,</span><br><span class="line">    random_state=42</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行搜索</span></span><br><span class="line">opt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best Recall Score:&quot;</span>, opt.best_score_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best Parameters:&quot;</span>, opt.best_params_)</span><br></pre></td></tr></table></figure></div>

<h2 id="打印最佳召回率"><a href="#打印最佳召回率" class="headerlink" title="打印最佳召回率"></a>打印最佳召回率</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">best_rf = opt.best_estimator_</span><br><span class="line">y_pred = best_rf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Recall:&quot;</span>, recall_score(y_test, y_pred))</span><br><span class="line"></span><br><span class="line">best_xgb = opt.best_estimator_</span><br><span class="line">y_pred = best_xgb.predict(X_test)</span><br><span class="line">recall = recall_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Test Recall:&quot;</span>, recall)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Recall: 0.7719298245614035<br>Test Recall: 0.7719298245614035</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 年数学建模竞赛论文</title>
    <url>/zhihaojiang.github.io/2025/05/19/202505192025%20%E5%B9%B4%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[
<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="55d834f4c5aeaa6fbb6fb1910b0155a970aafbb4189a9ff951dbb6d292d5e8e9">b31553de3a5ad666f9ea67e91c817ff5bd03d225e12ed0e3078d10f2856af3c4a2649d9cad95808d4e79e74db59f8879762b9bb695349aa9b7fc84cecbc9f49515bfe41a8b7fe6cb0edc6463c6dab44be4d450ecf04d4ea5028fdad18c2c02f89cac55aea6ba0a3ff0d8ced35678d9fe03a3852cbb1759a1454ba0d9d19f1dbefec88910c1ae80ddb72be8bb945b2e9ab2487b756f99a0562f3eb9e607ec41b19df3f35e749bec47f5d563d9ebb5c093b5f677cd03ed0b1e3e7152d474d934ea7647b7b7d7eb36e43005bc3d4b08218ee1b183ca69e21511f19c7af2601275364d81093162e50d407c511c70f77154d8959d50dd6ec4f4c27dba28bb38dbcb78499223e529b7ef573c263cc83e9a6877c6fd82d007a034214ea16821afd5185c7bf913d521345b88a22bf27b6133515d733e1b89424b6249a4cc14e2ba55fef22166bb91eb1af3d3b9cd15b83238d6a9761d9e6338d8261f9d08b29d80cbf5fb068fbfeddc1e44085c228b1892e32912964d2b045aa0ac6f015969b397a8659cbaeec4064bac274a4e3f178779ab111f31a2f40797a7e8f98803a2e2095cedf7c51f4a78794cc2923928cddb987daea100f0fb3ce299d19162af60c7746b84c1d10791c96f9b064afd55c4f3e11ea6175ab17f18936ec15645aa14f7b90dc6c7fb2f761de50c2dc6564d4829d85250741ae7be4e7954b1774e6332ab8f677cfbb8556124b2120ab0e76843618cd3025197af19e9907f901c980479892d8fdba819fffbea44cbc5a22db5cf82c466597a240f6ba38c03e5097675f208c9ecd9e0cdf4cd6ea0267f29a439bb8d026608745271fe83fa54021dc4056eb48e342f1b96c13ad4406655d10fd37a48d0424447b0f55dab4c954a4dc52277ad7a1717ae302e1d4ea85f95b923e5f41fec946ba52c12166f5000f05c13f7b393c3e4373e7a86e1c75dc370b87f12c0a2464b818baab0d5eece8d31b19ba3ce6cffae092634d77782605299e0872ce9ae85793361a1501711be086d09d5d4929c9512f456d77f04f9e5c1025f37110b359a71846112763e326b18cb8c1e87bda77f3b4cfb8d1cefdb5b888eda7c79943d5de07bdadbc6928d0bd091eb586ae8953600c0fe4099efb11f184381f34f6db8e5872a3ea4dd8c073911df87616fd0dbc5d91a755f62e5bfe29819b2ab5b40bd1a7b4da7be9975007711631894cc2864e9d12d0c472f5d76b19b4dfead13c50adab991be01ef057ca445482a3f5949206ce768d0028b71d971f401dc669ebadf0b5f83010e6fe97ec96b91848436bda2cb2a9aad7208eea59ef18bf8de5f1964d8aaf4d659eccf16ac1c77e6502f6b228bfc377d9ec9795623ee67e6496518200b068b89937a758c2dca174a4edab8b1126939ed9d45ccff0ef01242ca887df1b89eaf4db27c00480a3d60db513964631cfcb211423289e154fbfe6a555ce7bf791060b6d49ad37f6fdc6f9f9123242efeaf699d312bcc81749db8a5ce0cf6b2bffdc22262cb90d3f28e29539cdf87e6ef68ce091284dc15937431df5c3d55dc422d7e47c14be2100bcdd902398497f1f5e6bd8c4c8c55d7d2aeb66c0e712b79a2acad3460a42b02eb4897923e24e73bf0aa18e0673a324074bb85423b250e1c044f2fdc9bc67633bc94415358874977e38156a0e5be17adb8f76e841b66b75f6fe8f1c66170331679ee93068fac8e7de194d048e33b316cb3205831accbdd6b3da79f4d59021f3d945e3c9f1b3dd62d8ec9d486bc7b97ffae26c6d3bfe6c8f702e8b68b3f809914958e54bd2c27111cd669971fa657e34551f7f731c238b032b85f8daa33c5513ff9a40a7774193304dd4b4d1434db6ad7cba62633b37bc81366b28d8940de655229d46974b692c2dc895f924d7164e5615f8699f2a88d8d71e17759274a3ad901ee17c06c7e65f6d6cf5cabfb2535521882d447e7cb94e486094d70d59b0ee22cff1cef6af07f3a518828e3f5040f0fb7339957c7a9e6fbeaf4ef8293a4c10ec787527a6e9a4af788b89744cb4a27399b68f5d0f75f77c5007a4c5f2c36bcc4a374aefac72bc6064db446097640b05799d28c2738f69df075b4da04a8383a86256afe26e69baca637883cdf426bba030ab96f77e5cd0cdee148fa02b6fa74b466b863dee66a1408454cf15ff4354583eb51f8fa701c9b3d8fc065dcc4a3f221d3fe2507d57e46c92d2c3137d4eb17201898e972d8d5e5cf18edddf39fbe5f0e7fbb48d31376cbdb1878f98126f15b243d8e7439f321ee5bb6a9b9585f3cdbe55d623ed17deaf7d8c5475a41707d9ecdbb2e2360d7b4cd2775246cf7d5b41b7dc5a1f211c55f0b0a4d3c65182b9e662264852f96086fb331bc7f30786a7c0efe33f671de5f3d0d62746c24949749990fb6799321083c47c2cd072218be0c2287ca1e1c411875156ae5ddd243db2076281c0ace783f6829a8733f0a86902a188b8c59c8c96da9937d403df079912741e226bc989d4e1f0a66c74f3870e3eb23e301caa08efbe8dda841dd2a8a6956778b49118acfe7524f75f2aefc2f43eccf6b3acd0e1e577ede68a95307e7b48b34a9afecf93e29244175188d2ca38106ebb9e0fd28a19cb84bb655bcb12b33ccba3a31ef675425841bcf8d67e5646fe7e906f7cd7edfc32f80648a4d269fae62f4aed116e99bf428f3afe9ddf1ecb1f8e61f80ae615ef952b417b302cf130db8847da513e2d94125bc0f01393ba32ec4ef96f195e329e3d3328e093d8002bd112c38edd6eec40e82b62bed185304ebb359965215006c30a8732f5b3964f6d4c0b04d080c2b05ad5905f01f44d8520256a612304a439c1bcf803f17c38ee55d1bd16906c54c6e4908370d8fb7717ea4cde437c325fd734ea3be4d66b37bce2237bae77990a296c6c925422ab63a03fd27db483310f74084e381fb972164bbed0902d7cacba0d8a74fc70d79d6684539fa29ece14cacd66ce190c84dfa1da01135d0062118f52ee4ca66b1d40254c0b4798ad3628497739ee41894d78efd803c54d20ad96ea8215fcf9415b9fd83cc6f186dbaf0a881ecdd463a4450c93b6dd67d7488ee5ce53af6004868728bbb036bd08522665a31d1e06fdf427bf4104e6b47b64d4001c0481608b3ddd1984237afb28aed9c6ed593f1c4847390d54e7630e054516a8798c5497d7f102353e3cfe1cf9d9ddc029c027ddb1399816b08df74292add50f5465c7e09ee46dbd88f4d77df2105358b031e72e5af30860a9beaaea5d62614359e845eac528bdd311115c61385933f6ee85aeff07d1eb405d0b06c8b7910dd54beac4a45e86fb55a5901c5d79bae34041f8ae7d10353ebe6d1146b62ce4bdb4222bd68fb79f2ef26ecdb5300d672f570f7f30a85eff40313a96dbd6c748099ac1aae19ee95e0462e2c3d15759ef198b195542253ffa1a5b6900d22ec954c251ca652b654efbcf986523f5686cb8fc7da6929db4ecc618b5ba3cbe90617107018e37eaa764d2af74a7ed7d62bab1df5641bc9546eb1999e42bc6888df9a50bd764e4ac37e1c562ebf7b329ca11137eb1deeac071e124e2ae70983d7d2b4687be18ee66dbd0ab6aa7b0d8a1c48597b6d3c5060136abd140b8a07e57a269de2cb5385ff4a157a34ff5206eb452ff1e0dd61aac0d60578fb2d75f9aeba3d8f75a307bf1a187520d5cec6d7b07a7ecaa7bf5a25cde406c4c2c6bafca6a213792c81f7762527a9c56435f9f926fd4cf35bc36adb4b84df75bc337cb78651eebf614dc1a61b8ff7dd79f58fd64d8d82fe0c4bb24fd5845201f2b6e8ad2143c1bbca70d47a80b3f99f0660f8dc9f67f6dbae8356bf3dc7007f8a97a1546a522357692e4b91a9aa2d9e472fd29db4e6410f5e2a8379f8365969abc2d3213ce2e26b1da8a9a1b22d43425fb8935bafa0d92a26c6bf43184f23f79321002a04474149caef5b13445ee8c2cdae6e381263e711cc3346b9f59b99afa2ad11556a37d3967a7e245ddbdf58437ddf8dabfbb6f6ff4b5c09d41ed0cdea14a87c93080783e852f6370d31c8bdc9bb41b44932169ae9c5a5697500b64038f8871197b3de7f5a6e89cdf372bd97465738d250db59c00e71a6b47d81b85ac8ae95dcbbf05865e70fe3d7f9257274985400557101808a2ba0296b5a3172848eb25906365e1073d656435ca2b72b39d7a689cfcb9c95d1993f8db780ee5e5f746fc0c2c581e92e52ceedae15177d14ccf799ee572abaa8370b03ed8e37016a6a166b6d90b156712012b442898029f28163b1628e745774dd33d638558ebea3d20f139265e3db8bc3ca952ae56f65f4e873d286c36ee89263b5d4334f704c77a39e0a028a11e2ca90d08226178d05116cd2f677869a21de356b18864689e6cdcb309a7dfd9abc2433b51355f8690f1b75c8f9d08b038a92d8f1944c1df75f149998616e80f360426a64d4d6695a6387dc2c39b9796b1c0c98f25f6ec088deca2c5248168c95fbac697901c03dd2feb01475b1a4453e91b4f56483869e42f47e191049798ddb60000e3fb129ff605b9e1719ed4e16368d1e27aadba984ebb990e195a60cab666e86bcaf554289468fb8fc21c7067d074a7fd308e197dde9bf3572d8ecc94191cecc73d8fcc3b9e2dc7505d2e75c1922ca1fc23917f87f79559091f472323255ee9fd2ca23676dc992575d9d5564a147d4ef82db95049c3c7219a50ab8350eedc4e88f6e370572d598806c5b155e46797e8de60b30030892e001ed955d4a19579bf785fe4a2f00e5a7d65b053635af0420c72f7512636563562b0358d864dcac75f88afacefc91c93418f0ef4683f089c7ac8f1642948dd7808e5cfb3d68308941e6792dd541854fd65a5585641403ff6fcd19c586803121b63d6e7e960a77699e89733f0205bd7bc11742ecb65cbbc73cce427e6213dd2a887b589cce742796b776d8f8edbb31dc63ed5ad287e02047b89118cb338766cf15e34c2c9be63bb3be3074bf686ae35a2ac1fbdcc7deed8ec42e2f675511cd5e9fdef4c823d30f1f5363d60296282d0deda001f1a09b3a2f8201e2c863271f6e0087de9b69164453c831d02e1ac864bf6d27fae3e63314436e59026b0f302dbb76f19edf5a3da168521d2bdfa4c29ea018e09abc8ec3bf353b359ea54e5697e635eb3dcc039203e2a45929857d41cdc6f2333e6d4f8e12f80a80e8148386a843df9b5c2dd013b6c22fb9a38cc55cf14607f20167606360049778ac0124094aa11ac2bd0d261285bfa5b244bfbbef03a99edf02e0f92fd799489fcc50a2e1d2b5cb355c0689e0135757a5a660c702300322d2be7041d8f183b7a48b35e9eadee2609d10c8f0840ccd2096f175f9008ec245399ba60064cfe25b5e2c9b8f133585a3640c67d5eeb9819ad8c690f7648fbb008bd143adab950d46b1cd524b722e38c7b3fae38a51854360b2f1949959daeac959db600f8171fabb7a3793387d41335c89d019b9cdc5f8aa14ed39fd861e3dc7f4af8edd42a890742e8d46e7e8d6fa65c9cf9e764c7c6a25051859f92898925e86c0871154915cf5a06ce2ff58f609ea4ec1f8fc1a54f38ae34e33feb0dd1a90bd2a2c7eedf828f6ca59a38bf003f293158b3fde3936c632a1d283b81b801605e01f15eb0f22bcd182b181b25f5cc034212ecc59b709d8e96586b9dcda360749c207580a8f9a3d7f22bf353848d8b9af9a1d53b381dda28068675913b1f295d2f825e1e3411d67f4f7b0bdd850539a626573d3072d1504dccda45f4d55aa5cae2399071dd87ad5ef8d0b556d81cc9493010f8d0559b52276d7b9a763e21dc3925129472f04c69ae78ca897ab68d903b1ce8392de8ac2cb8c3ca72b5c7604d0c49418eb5e808f6675f9a2df81b3beedfcd0290d4be74d11ec6b06c9eb3582f4332aac13f71a9d57975784ff3749334ce2da10cc619c76c1155b96f51b7b58ec41ca1b86a2b8191357c8054672a95f1b55ddbf3c7b1df7035b1140c9c77886b2101221e610c5b81289d19c3549447f1c13696b7da0bc9bd1027f3e6870249c7bbf60c0b4e5076eeda42369c850a3fc052f939ecc0284b02b0333672d2d8c27ac20821a45357fcf005ca21355e1a01dee519f001c0a8cec6a49f27ae58135a2ae707306a7af0d9ed4ce6173faee0beb006efca5696fc3021145348f746f6da61d8ed0c7d580d0f45548f8e1fe6f4a1238a74d270d4397c0923eae76648bd3f60aab9844d5a96f12ae302a5d88c7c9501dd94494ac6c96fa9b35ec06a511ff2b5dd5134db2c9f84e3a7a46784c6b0ee4665b96d2e813c6209795cb4be0ea0f601f7505124c7a09c0f9d8e06132545beec848407e38ab29a9f249c67d7f33c808c5c6e7dd4813229d348a2b6b1bd3077c64c6e3f4c6264f4c6f6a024f42567e54aaa2b024c8019eae540938e718b46df0ded77e3155581e8faf58d2d4d47207fe2ba56b56446ac41133145b4abb190a24f2b2dbe572395b0f0f6c820ab28626a3e7f885ff1d26c1283f180df7824fad6dd3caf48855634d51fb6d8bf46f36b04aa200f04d48b6a0f214582dd0af50a95a5d5b13bdfac89471c0100ee6719f60b2e5fbf46f5f90efd478e82289f42d06c80432b4e6d2bded70afabb79cdd245f0564de68cc11d1a8786cd358de5d794b9ebd0242060ff87560de149735fcbc66bbd9cb9bd3787885aaf2943d6749608a21225b4762df0080a47bf71b0f6e6e5f96c2cbcf2d74a5e2c2f840166bf86bf4cf37504bed3c4576268c59a3910595232f0126a9d737dab27458f51b37ea10709b97cf43b78addeaa012088e9d35c91780767f43c8e96938453451c573e7025b5337b70271acd9f5e3f1abe296cb10220413f01ac28fa7d37f77257d6e5f899a644c3de100a564cfea54a436b66bf787a7aef37b0d6ee6d3d825b102b1f7e7cfbf91f3211692e1db44185f911facbb93b6bd24a19b389a49264174f9cf20167d74c3262b4ea7f2c69f9af2b153eaa3818f393f91079e10054f07828dc4a6b4418ac13ff41f0e6c3b42a3ae001829c6fef7bd0e8cc34ce8d11c3f99dbd525a2fb1630057a0128c23b3fb321515499f42ba027e59f2f5abd6cd36a7439cb95be00098f62217a378bc37bced036bb0bb9ffdd100bdebb2c645078b05890df831facf7eb3e7cd12de750b25218a8dd05ee087cbdd39c01400901174615f9108c041c16cc98c2802402039b016c93043f73dd14bf24adaeac5feb72cf704f6be737213f57a5083262a6dfc63f4d8b24e6fd8d4b5f79c0211f032e16d6189a65e2d0b555aaa7aee5c3a55ad7d26a5ba5dab648f8008d33f9dd14cb27589d702d08e5df57f5196edbd5f7f1b405dad572de1a0de71bd98b95129dffcc24608c6140e8927ec4f3b2c05bdc5e86ddf3040a20b9c7c9c686dce27c3d6d14572451a6977a8805512842addd0af0498e043c1dabce0a2358d8c215f7afad0c0c74e2a18ec5702f45bf940308b9ec6da6d4412ca46dbf0a1ed8a4788a138ee46729d06982a1750f58b87b32310e4c53543d05567a455689537c57a9b8a9dec4b7160f91fbe092cc9925d19bd7c1979432d43452514607f2933331b422dfea1690e4cc8002c0423208532cf35b23225c9627c545b9887f5861f9dde919f11431967df1100a4393d01c5855fb8b79efc5c368a41170bc17496906bae589e5dc68f42f96dfac4d8eb12a1b0663fbc7dfd1d75093a5c7820dd3a00769bc96e5d9bff50b60f1344d295a8a734bda8e0963f4e077826efa36f2f9d176c04d1288c0fbc4b6253de6d03e637a4972b9c7ca8f8516ecad69ea43dcb6cdd81bc39fc64764f5d6620b5096fde3d4c878e1a7b81a3f8aaedf373ae02e1b64cc52ac514d415c7caf6f1e6c5f27215b38613116049683587b63e9bafdcf0f835d1b9fea015b25c1f886f4ca80dc567f30edaaf80f6c4c5b16df6a86047fdcfa5d916905425e61327f006d56ac6949679eafebcad2d11ac74486fa09ef9eb2613642956cf120055b47fb030efa6ccda3a7268ce0544a8ced1cdf7a2edfa559d8160e46136c2a8e172988df04c649e4c32f4ac33bbf7de4f654e16adc5b6fb2b2376c65970d7f1da705b1cca0c53919339751615820ee38c27e68bae9fac2516261c3cafdaad80735025672aa6b6b7d7cf179bfb4c565759c0265608ea64a2751673857a697aefa353e3244ba6b3d637f8854d5e832ac9680c66124dd7ecb93b877ab0a3209f9745a172f37001bd723a86dd4b7ea3137931ed6687449e034c3bfe6991866fc650a066f689c841669f759d444feb8431970cbfa3a78d9008c855f3c1aade061f9aa87eb4cadcd213817b74c8b39e3c7a8aea74f84f227dd216c43eb8478fd2ce7ba4dc8609f4dba6120eb36ae81d9bc140844694ccc990900bf82ed118f6b85f6fe2f00446734318448daa7b3e10bc55d2c972452ae0592d1baabe3a4deb616395a118ce7d11d245b596cb6fe5812d00477a1de9b64eab6e09c7f286dbdec9e1ef8ca72301e7ed3ddd0e6fbcf9f2986ce2be215aeee04d011a3d506179612b3079955a6e564c207d87d958d189243073fb6fbc9d64726f091a5f7896a1341ce254d9775740bf27611d48a7572c140dd8e2528dc6698dd909a62fecbff524d60e667a58741c21ef9f95f768ecf9ad5df92825c53e30c3c5cdb87121b2fc6ca96d479449ed8624cb68bc431df789a54a0efd01f5361d994f44edc206730025235f21fc91d9cd3e068dd03a0432f9008481be5c84d5a3e074be2ccacbba26fd694291c4a371ab03114a7558957746ecf9afd94de8f4ca889857db7c35254e001754c153d0cdf4cba03d8e62c3333d4300157f604d185090876b66c5ca75e7c8be941cf2b503873f482d685b128710ca668b759c52a624d1d2dc160becd210f84f0a1963d4f11b709a77cf3335687bc596fc8321c992f4a2e5127b926ad57f90e6e470a4e3a6c4f011b397c7571f1f8b2a67c465823d9920d93a79aa1c36114c55b4df11c024b121e7aeef7b643e98966fa8b356e0f2101f4f9d0791a8fcf9c17b8f5f6a41d6544ecfceb3c997c3337c3386c0ffdfb88397033ddc21a41c4989a4164f9503b9a8b05746ee363cc3a51268f4542a17c998960a84341e8946e3c0c48feba11b0290e0857a17ffb3649a9683e82be92cdc2a08369729828d76a51dc1b062d5348300367bb01fa5e90f841dd4d02ae1e01be7f7827fe6196c50ca91441a3d21d4552d1bb9d0ebe53c34f2dc100e26f805f90f6ae35c7132d650f63f51be218efc2bd9adc55a56f972c85f3d51bd288b5c0ed40f9f79ef62f2f2c635293366409ec2250225198c8326e8ba22bb18f2749025d6fdcbba471ac4d5c0c290e5123ee2f345a48e47f5bd4e418543675115b5dfd830c2d9bc8253a5f3006ad715e26297236e6d532e06c67d25dee5f6ede7fd516f982b55b969a4ad6dedad04859fe21004c3f1a0ddea09319a45c737a257fb2d09da9a0a749201aba7c99dc3838a7589b0a0724a76d22bbf1e3d61c1f307f1668d1bc8cf6a180ce89388c1b535ec0842fbd5b58f9f949cc7182eeb3fccf07992513b1b5625c42b7b15f64a5cd79623de537fb0c0154c81f3c2605aa75d8a45078d232aa65ced289d550a31b2177e0d7f5688035f38e06171cf6d4eda05fb000f15acc7fd851188411b77eb99327742b3f4cd381ea14f542ff645750d35b57d6857e4b4ab67ce71ab5c0f608e5a85627d25d6a040734c67d54c36566133fc0b67f8eb7ac8c657732319774afa01d2d704b14653e371f16de656b98013698908553f87913131081e5947d3d00b0685a346dff18ec549c78d7d7a9b4bea914b7266ea9a50a082bf389b20fb6f19b6784dd3dc4940574badd35da5511b234b0927820aec41b6e57093d966a4645da17be6fc773b54983e82508f678bedb6cb11522f29cd9b45975a759557323184e36bd278585874269ab4f63467f45698a1aefb3c495d36cf46bd32b134498b3ce585857a3c209191c452114ecdfa650078a84d978df4f34b07fc5c9f06aa5d671891737aa4d95e4c4ba49f00404366d57f948b976b4e942fea36c64957f8760518133a4df491c592af68e4ebb36247145b3b4ea2b8ab845bb1f502a034468e6b2dd413826f88d6a0a7ceb9dca6b7055708f26a1ad5cefda605078d1949b0771121a99c256862b8acc34bc28afe4937ecc18280b09c75dcb5dc2ba107f0ec46007ed8c264a46f765833917353aab98fe4e1ec26af20d64c83ec050f795e44726cb464b4da065f8fef3d126f7141b84058c614705b7c379b3e0e1f0f09b86029649a7a158e712796936c40d3db08ada79720bd68dae71535fda1a83b745502979768ccca82d0000ef6222ea81cbe519fb0b56493a36eb41396ea5098989297c774dd604244a71ae13b5f1027b87435e26bf801f062712dfb3d4c581ff0fd0138e7ccaf11bf20eb5adabd3c1005e0e1c05fa8fe91af7cf05e1381e44a3c3e7cf76114b8a157d05f19b21189dd4a2c59d2537f3cb59fe8bed9c89623cfcfa3788e35aafd988c58889359d6469501e7e837501d394c0b2ce117182319b9c74415018fae2f6a749644310d14f522034967495f418127092f26f46d5adba12b48fd03de939c8bd6693c8582ea26f0f1c466e34ada6142c0953850ad612f9dbea6d2e14009688253c03b1e49aed3979557b2b30fabc6e1e77455fdff2ff8da52b0cffc5a4a81052491e1e48c734c798e1ffb864b69c2193ada23b3f04e3d57c9753b348ac25ba3e5c89ecf21f6785114cfd8cb4f434a029fb840c728fc1bc86da32cf751ba86a4308a49bb9ce7cba971790a9d70b81aa1f03859a709d2e3060043ab1f99d3ea8f14fc4ba3c9c3857fdd22619f80ddaf0eecd6d376301ccdd090f8788f1ac0696b75eec99e5be9f3eefffde4be372c23bbdd8b101dbf363852c352f12319586a8db7f56a09d32e5b5ee0daaaaa9327747c3e97423372ada6c423fba35392b93e6b802371c6cf4dd29fa77e0523da1fa1b5514750ddc281ac8d5d78a11c176c42c9304261e4d978beb7ce0a62eee0102f08ede0c28104bc528a7c723dd85fc0a4365460fe05e8dfc520356bf93f8c9b70ea968f9ce2fff71bf962e32eb2651ffdcb4d863acbc151563e2e7b9f9febdccd84051d2e904ebe0d0c256463a278ed5ae394db902698b5104b46c3484f5a1d4e3c0486ec9ecb2a3565684a77e2379f7d20acff767b8b836faa594f8129ed7e2858d6161e317bae5c1244c1a39153167864294a0aa89815447d863548a7c0d5991abeb7e0af3f51a9d8264820b5759437afa0ba87fe7f8b4503b592a00d0ce6f16d6ac96ea2a3959a1561cae10fc6119850a21ca6eb800515e512b72fef9afa24157461477748da9364d2f3272f68108d1ffcbf1f5da3d30626ddbbf89e278df35fedb5f1ab04ca27c259cff3cdf422d9dcdbf49913a10863da1717ff9b8ca4868d30b7ede5df37ea127f3a2c19f6bbb35f0300aee23c64a66697ea6b7374a5e7b583a4520b6944c7ecff5c39816f09e7920f4748cb768f61d2ee0c7558bf0dde63014ecd8bb5a77f2440245e2acac8c873de5a836af4cae37e0b588fd24cea5ce9e4243b094e4faddaa4d1a28f94ce38b2ad661a0028ec00f113a9efd2590dfff7ab20adae4083718b1c47e2c9ae5766889211d56314505f904c3f73a098e1a0914b48f4b7bc568f3ffb779d8cd4067d444ddffee1b95dc6134ab76599e1eef2624e3286d20643d38ffe19483e81c38cbebab910669371b70229944ae81d7376d91a4562403415e3b364e500eb04976d4515b011220ca4a135d4bfb923994f83bde60d0b5ef66ebdffb51f54c8a8e960438cde7fab0121324306e495b6effb3bf1a6887e271896172f1ee6e3acf4fa9d446a0967db30328967020184521cdec683bdf70f0c04eb188e0ab3e2efd7e756116de22655e2c39616cc363420325dbc5063298bde2ee86547c63cb6d2a13da3b1a8c95cc6cf244c9acb6cd83d72ad6a3d127855ea229caf4c91e3128d57a2d8f7e141a62f4478c75a91c8096803e93ba8cebea0f74203952c47f3c967ed13451978bbea106168be59bc3c7f8fd9bc374981f3496decbe274a70d1f04cde63155c22e97673c2c72ebb60d114379e9fd8fef72033386f546e282baec8399ae37bdd544ce66816636c94b962187bf20f1514475eb7688ed84b77cc204ec55416e0ae996696bb6fa0b279d268eb2124cf2b69ae4d48a8a2677ee87f80745e435ac055026d9737a2a8433239441dda0ffbd758bda38d69b4eb26c4137d383b459dde3d11d81badb034673445aff03254d82eace8ac1d1a07fb347081e8b3e3a80947d34e60d5e3c8796c45f9378cab99342c2a4df841cc708e10561533e3e4ae00f4e673bfa72a4b87a43e56f52446f562ee3d334f54ff6ecc1c0ed75b5b2ad8e1bb332fac954534d79ff53b17d60f6fe231ff7aabe0b233c58017a7f6ffd324760c15d44ac6d99abb42322555b165cd3f9631fd2921cd24b43da3c39414f017b8d11c44f12b26c76fcb220988ef725d75be4ed4f327b7f7335e4e7f9ac3ecc0166c2d66f104818ba5927240b045f9b2d21eb24186c5ebfb81b9b0089f9036ca666cd0deedcfa968c6f374a1f0e81724146f85e6d2f8d32abdd24483e69e1a3094b7974af68da1e1fe172e7df4f22ad8f2e729b9c19f2a85f4589277e416066a769b2d5ce51c1028de087c18135e3708c24906e8cd8b6f7c1f69dc614838f51d6a436263cc7efcc565204767468a94d32cd19e237c89ade8326cf3acf73e64fb058ed943bfb8063116f41b5a152d6c7c7ef7d440acd43739b2f1d4e30ef134a14e675ab811f8c28c6828cdb27c6090cbbbc91e0afcb62e8f9ac8c10d03d0413c150ae0de169a633ac167c65e2d0441083dd5c34b05605407dd83c6bd4351e319e1e969c17ff5d62af659140871ad1ab6120690dde902831d7299eac9b346f9e0c19b39048994515d272bce903af6a409e1534bb27a57df89964d79bcb4c223204e1ea61773db745923c8f11caa03ac988dad429694f3c0c7d1bd93c1e257baafffdfefe50a7249b1777de91d563d26744505f6ed554d20b4beb25392641a214d6296a07b73baf0c55bbed838df8bccac45deded614091474af19a731e15a3a270a070098fa4daad9c24367b839eb784097d87cc3c7767f2b381e5824fa8d35f9e052e0cf60d17f4c4671bff5068b4a25a7d79e3953e5956e6c0179d0bcce866af289908be573409070371703e4e7a639a8d506017e6e6cbe0ec025e94ccbde091a07e11d8a29d07cbd532678d83f09b5917d8527402c933a13abd0d24e8b69c55bdaabaf6cc28f1ce440d85149621c441cfcfbf4e119a9a67586ae7e0366eecbf09766da1b1d57608d33e5e11dc2efe638e7b66b2d237fac3c04d01a096602a9b392c4cacde11b1912382b036b8475496dee57f1dcd8f1cf964f89cf5e0d1fc5808181d78eb5900af9c03407e47fe72a80245af585dd4cbb10acb01af243504840a7e3be327bc9dae2cd01fe0a085ac3fddee65f855e879071163f2b4f8a28cd5ea289a832578c1f523c3621dabfe439c1f253f661caada8ba7289030cda11744af43ba2f26491c0eeb592bb833e55cb0b94b9cf6d3865674d89e0138904fa7c1139b58c55f7fce79ffe8d35c1c740cb2903da8585f142a2eefe2bdff055add588f3750866562161551eb393b496628418bdd70e68e9b2e304a6579c60ee3a158c52fca1e8c9de246d7bc47ba5c7ebdb495e1f24b3b4bf1e3c64b5671f6621bfedfb6fe062e39754555b5aa9445a19c3b74ca5303923d781f07313cb1cb8e67be9022831d0d31c164a49eefc2872a67af7da2072f4b7491dd055569a09e7532672d3eb17ddc9cd949de4afd6970b6950f6b1b3b5a2dbef9d65876455cda1743f57dfe7c4350d7625868936ba7e930e1e096410b8db8b21e98fb38469673c73eccade60b5dee5f660e77bc7eb0bebfcd0323545459732cf2d157018bd6b280c44f387431e9ef58eefa4b49296c23c536e46fbbe1d66a672ecba36c456ff724ebbd44323bed62d192cf19b66fb3955bd9546d8ab4de5060e0b298e96167b30699c7e23c66485b32be88b52a75041bb663f1ce725e575cc378ae29e8748c1871e18c4d371cf4abde774d8b9270490980d694cb713ec4c02028caa31367a0fe81a7f62db3bd671be0afac844fe45850ad6b963995afaea430f83ae498d2836290d8c3ff6db4c92173fe7d1aea7176622ff6964b8dc681b9b23abbd7b7d022e86d0e12a63c0140b22a56e33409ee506caeb3a28ab95c002289db31cd696d8c60e5abd4f889d4664ab42449ab3d87fff1dc723976fc54c7089e87c406412256ae94391cb786692a7ea1bb9eca63aa8483d973861f93e8820d7559be624ada504d9f4dc7ddb20e45ac6ce8b5adb40da002e68f802fa87a696e3b611bffa2930dae690e033bc608f0f846c4e323a25b3dd62d7d7987b14e26798e549421eedd4acb23c4ca17c5d6771aefe38a3923fe315333c26547ad9c885a619e207c692472a25d3543852dd52f252afbe30845f997e8965057a867bbbc3b0978acb2e956071d8b12b19f63d2526f6a0bd49015b1f58d1f4b61de918c4933c5c8e9d7c1aba4b9318a5b0eb0bbafabe06a8df8c8af62102cdbf2cfad3ecfe8290a50fe68496cdae0305adc57169970b27ccbd0c36e820ffed818d0b65f6266e7bc8fd49ce350d13a9658ceef00543c828d8e4f76bec09fe9668de9bcc129c77c35fa763e4ab10973cb2635660ff6b41658adde4decc85709829a9d06faeb753864c83bd206bfb2e37b8b244668d17ef44f950fc5442899094994aa14974d315e618ca76adab567f80d90d22fd57d7bb9bc3a2467ba15a3d5923fb47b6bbef061b605942ccbae9c51626fb2945c20b26d62765bea87ed39e4741e3708b4cbd296aabfd70134fdcfd7ef478c05da4a7f13f0c8759f196a95d19b9fccf98074551cbf0e72656a54ce5b93443176af947b4c4e6c9b2a958d344108ef1a1a0ef7c030571a416f0f3b10308fde45d7cadf39c6ce2c370287b57c66e329dbfe23c48a764676e96ea8bc85849087fb389946fc2bc3e659c3eeb6a03fb54f208b0f3122d0d327d4703142a20d3765b377e0a44b6a31c0bfa1f8e794ea65df66b694976e813ba7bf6424edf0be3fda67fa567b72062f23d66efa970ac483687f06621f75d015b97855f17806a14492819a0f1f9a3bcc9c4e44fde8e6841ca5c69bfc66ae58e62bb5234bb2c5b506e53a09693e0d2853dcf2e1a8247434e21dc404361485001852d727bd2a300e192391642c0f7fc4ce8a2b68f6637877b53ea0de93dc5f9b8743e500ddb66502c9e62f40fce9186535d5b014094761600ecc39b7258c45d3e99ec023e23019c0102966c09e63c2eb7e74099c4b007aa70857c9082dcdfb341ddfe6cb96786d2c534c09d6d4062f0ff0bd50856255c2f69ce174df6403b4924a5481a8ba335df0daed73c3327984d0fa5de2bd5250dc51e73f4f7bcb2a7138c647fd58af9c2d730d1e1929870c6adb4d249b887263f1fcdacef9acf5c2137e60d04897b5296bff1c207d173ca14b3dee51b62a5a11de915971734d2422100bafbf6980f6b45020c0c8250603e0d88563bea54ed79b4fbd91a9b4766079b976bfa7394bcf60e3fae00395af472cd6267a355c615a9e6a3ce85202fb845fc3db5550be88a769fa76727e704bc03d009e54bedd25dcbfcd2097eac84cf2e95d1716c536211fbf7c2e38855d6b18c1ace8e65475b4632a48c22a7fe6fc296ddd01e8833894d3eec342006f0eaa96fe5725c5d9b84596535310db3c115a9809a3d07c220a86d6f43faa43d827ed2787e3fa53df290123ebd8be1443dfd9016713c9533980ae21b33ed3edd78bbf4d0cc6ce297f5d140631fd79b1531cb094220ba66fd2a689d0e7dc453fad964ece483a07634233542b9ae0750bc20f5a65866f7dc7c822a3ec49c2e110fbe08c424e62fe3ebe38ba8751c4a11387b9de7d14036cf098deda700682151fc383b8d7e0efa1addd14d9735fa8231fa7655ed5a7016ca12bd2689bb8faa6a78793fd42e3a046c85b8199269eba42fca3661f48e731f4cb2ceb6ca1a0498863b6d8836828778305f5e20a63b623a951dc73c06812c4a811764f238730c0285eeb8f9632b4b27f91036af39bc3d4b86ebae54a5a1b838fb136f22e1542548a8b0116e49dacecc9525ae4f9bfa2bbbc466c8f6b3f7e4b98dcae7b1e04d319bffe865cc88883ed781d0f6fd5f0555e858d276229eb123e015acb99eac5c9d7f540f4b9e0a2611b6a2ff347cfc3209b2058043558d2d8492abbdbfd28dc5fc1ca8627383740621bf276a66bb6619c035fb395b955467573affb379629aac9acfb31e093cb71f5e43d83dac760ff5590ba80a38a59500c1265222a5693b94be419cca0d9f084b6d5abe395edff97d8223c22e72acb1a6d00b2a8ed0c93c943f8ed4ff75714985edc98c1424c1e63fcd4613d8b4dd84ece86aad793b268d62b004b5f80872dacca84a9ca52f11bd1d25f03813e0b1703b180400554e06e548ea0223882e7c921634d5074623dd1f090471a64c272236548d6f7a0c5adf3ca3b1459665c4cc88ace9ed53ceab016af9ca6f87d09e047ebdb39101515a8ac60e83c4fd0eb341e0ff94df53b8963c52c7e20e8a457e0a7e4d2be8cabb617eb6884847174da7b13094287a7e2cb8a53be3b83ecf83cefb8828b88d0679b511538c9eefc9adff98d16b54ec2e90201cf397d4bbb9ac4f21ae44cbf48c1874b6be6ed762a30e9d461043f1b803b96b23efdba422bbae2de190ceb6513f3aa8e87abbd8bc9d364ca629c3a997e31ab095a9553110fcd8105886f68e2ad172336742b80f42fe2f80b2f98bce9d4fdc1647eca54010b09bdb7274f3d73562ebe2cdeb5f3abe2c39106f4558050f36033320baa923a1db9b0ec5d7a5901b2fa89fe62335a34f8e23451ceed09dd4fdba7e49054b4f5022abeae154eb7b6e54a00f3373f793795afa57d9af5b6d63f8b705effb1647200bf50f78650678f2f36015f0cb92078914091dbeb0384ab47084738bae43a9c25638f640440718558d6229c52531f95cff267f79d013e3bfcaccdef2d40fa0da68bcb63234848bfbcb07978267f120075cedb8efc24c1a4228fb90e6d7424fdda960af5ffe15fe8507535f694ac34f4f84f5fe9b6f3ad411bae065a2341fdb2b7dbd92f7a251e71ff8df3ceb22c76343be482c4c5c6ccb6c9a53ba355dce8b3d0d84c0a68f0213e31c1441fcb6cd367794254aee70c19e15defb2bfeab00a070955c6022def874e45ffc7ae9aad0fb9a3ea2bcaa1d303d4fb503b78cf9284718b1d62a1a558e0658bbcd36866f885ef787ffabe7d7ee7aab04362d5466246e28a62e8c144c0880a446b532f9d2ad8cced62615e7f9f40a3a50ccb50e4be5d77026d73996b838e88182f1244405b6bf3e6bb2a2113ec3606ff856c10011a2858441172dd8e7f9a938f56dc7daf79157ed44d54eecbc7378cd000dbf74d5e3303a0536e9e136aad8de056da34f0d52002ade571986967891348ff6b0aa8e26949793618b7892254ba664c8cc386c13d28edba8df95f5d2fbc5eb1d9e72df594264e1686f963e45d413e31d6556f8be62fc7a9b9e334e848b91aa77f51ae1ef7328b383a737f41fa9702c574a0d7189b7772b13ad25ebd4d47fd260bdd5eef3997aec37af628529b1837931aa6ea838953f73095b1445495bd12004c45d56b196e1e77658b2a050b589ca8f78643bd7b4fb999f79c535b316a14c7b0c026d330bd276cb1f1222816e975cd39e397a236c0a795a57a0cbcdea1124e710e62d087a40db4fa304e33b95b6a23d03a33d6edcf185d825ff3d2d937a796c08b547cd384a1e8aa494e2f1e8d5296690f0ac34cf629e12bed4a91f39231a4000e65dbd9c2741853ac6d6f0f71af0781f648141318c6d3557f5c04f962e4f17965515e049e7a514b931d24d55a6558f84b5ca66de804c33545c9981fc2cc5227416df01233fd767d51ac7f63f00411f5cb4dd52e8a363a8f0cc68140aebfe06975079a9de9f3ab7f54519ddffb012c7aa211c56c9332c5b3e2e84ef116336c92e8e7cc5d88ad9e69931b792e3c735610da1bd527f41e5466930b1b8b4186b6c457d39e3265482fa6b314d2cd9c2a8671d82f5ac922d7b3d4a285715a821e7e52774455f7b466ee4cd73d07a422c205079e986e9df1b4bdff9d8abf73421f6d99f3c29db804a6cc647948faed20f60b6c204a2fbcabfcda1fc05cfcf0679a97e64509f1b07546a06d63440076a0a3ffbf564e16784187232ab4a382d07330e15286c8b162756d1d1e74d5f734842203b8925131c6f51857c45342e8d5e1825384f1a3620bffb631060e48af4fcb4c8892d6cb555a0ccb6892c90edbd75cebe714025151dde25c30a8b2c1c9797562bfee14bd3f3e64c84e4a8ea5f7e10e7194a79fb9875e76d55d412fa305c35a26003d6bda466adfc30bd6ca7e19571feb73262ad6ca4b77aaaddbba2ac94758d37c59c122b282e5f3acbae634c4083537391d4cad98736ab252c1d3d238be60ac38ccd25a3815d861d09d6f5e511f75832627f9537ef020a2133fe0bbb3507fbef6bf86444a3a7bc5a9e167fb25782ae1b160c3e4274e385539ea16bba79ede00bead326e35c11fcda347ec3f695f15bbaa9c75d55946d20a3ecfac1a92d1af13c3b07783fc1a5b67307445fafecd6f33753a56ea9315f985f15a85fab0b4e782af07261575c05f323867e4e5629597925c9458e76bcf1d77f9d11ad56e0fe3be7c89968f97b2dbc236c1912a9faf50abdf2a13713bdbac9d799074a87add23891af32ae0f83f99cd7bcb31f47de41c8a0fe5160286ab34148a3f41623aaeeeb43957f0bd386cd46c787a7bb8fb5984f02a1b70c31356e0ebd68a7c845b34c34297c79d8557f26514a9e48b231df619038bc0e96db5b168821dd85f6601afe73bc967b04432299a9fdd14fce11349836843c241b71b64f45df9e36ab5ec283f0f0e11ec56d68172f8a3951faebaba536ecc220de4aba318b40102a0427f17d5db7951ea55c71cc3c463e13c7dea530464ba7c294e657cf2e2431db0b17ca00ab282c5ba17876e8a375f69431bb33f90908de7b2990e22081e79964a532a186ba6e54716346a6430998abb62e98abda9763cdad789955a88481c6be732cbdb222f8c9f22c9c5e83b8dc7eaf2d2d7aa58088932c3c3a89286fe672d5e4463a2a0b0edd022f51905a8ad1b405a6a405d5c78c59e2f1048f0080f55093efee7923c90dfc653668f03b64022889024a3ace082d600e2141e709ee5723a82f6f68b299ebcff4853a80cec427f54eed543c0e3249ebcb74d6c9aa6adfabc52f038cc235b431a6eb7378c3c40d7155935858137ff72d51de100d86798d827c1d1c9061341fe50c9659b47bd11f2cb3a85fbd628da6081042be2eb1230dd16b1c2750f55782aa19eb4fa01ca8869358193e2771d9e97830007b9c93e499190727e523d067079fdabe3e4c6b985d70fc11e98de7da74b4c4f46988cb8616fc3fc8fa03ea486a01ddbfc7d206346c1b34841f2b68601f3f19082077bbe72b86e7ff7c905b18a5d0ac73923c859dcbe632683069ceb67d2f0f11f804b7167dd1d2295987b33eb04f3b2215dc0e8cb52ae865c357deae0ea351925cb64c9d05413bb42d8b694020192cc2414e28898b86117a30d6e16b13e79685019659ee5189f6958e6a8d15a6b5a3f68bd1cae2d4953dae6d109cdae36ff33383bb22dba9039b9435abe841b9cdc6ae32d06c3856bae47e58a09d286c6b47435c6f18eb3f73992621b6db41f1da9763ebcaa5a99097259c096e4b1063d2f67712ff2524b58917ef0dba0eef0fcb1ed93f01679e28542e8321beb0710e2ac206474222ebc2841ecdce2adb0dff1ec7f7bc6e35b617aa989bc20f1f92a810658ea0ef0ddd26b2fbf5c608bfc9e30b1cb8ce703358456615fba301eaad8f9fad9cb8352e2c4e0c3f3f810e306a0481b4d5eb4842d3f740dc2a35d0f974676d96980b7a6e6e28c790be32bb0490ab00fcd9ce0454ec40a02c69655b6ecdb2d85eeb9185db81069ec93d96b2d871d222a1b12a43daf3927987626fb10e7df48376d235f2255ccf4e42437a953cc5096ceb880fe39b48536b2f50806274b4c048e3fbd62a612208b505d990882f791e15e1c03f24aa3ab5f10c4c0a7432a274108949138600d11a68af7896853b6691741d2f508fa3c62e5b87ed00c502168730b1d00fb107ccdda89d03abb079b5bb014f20a7181918610a10855e8f4c880744551f83564f0df253e110bd5104ad31b8a5dbe1985a420042db6a8b5eee80df1476ed72ce64f964ffe6b47de5656d922ed16abd0c6e4c5f81667987bee48fc1d6e9f7a7b83f3c2ea5be83ae09c723e11eb5c6641b14e396848d969647fc85d3b107ef1ef0cdcbdff5ac7730d44dece033de524c07facd9065816a2a9cbc8fef2c56cf421c354041392eda6d5662735ea8077f0cfb504a2fd253fa9c68ce8c011fcb7774bfbd11673b62df8b0bbc99b00f6ced7036c110de99a8b13156a9616ad733f082a6d1e3afddbe73fd6281ca403e6c2ebcd083e6c9cf784890e4fce6ae2b5bc764ea047a12fba22a96258202b5758ca94aca4702a0ba53bf55dbf539e18f6941b4ace413abc58b1ffb374590ac998eb0e1612ae24e686bd73d09fd8da5dce1b0617477cabbbf2be564929acaf1c59c0a00d0b3553414556a437b566ac1e7015ba52e1cced3bbc5b64e3fb5cd798ef4745adcd8bba5414191c17e6be5dbef6d289cb4f1abf8071fb20b7068132a29d6186b742be52d2c874de125cca200759441c0e394b5cb9c8250b691ba7c0bd0d0ef71bbe6a74213b248dacae9fc7be1e9b9761d68c048379c31365874a741012c81c0e483866bf824c016522668f924bf9fde2409b592bb0ab0c9455efec648d2d8bc908dcf71d50d3a27d5c345abe31d7b107eff44e4b19ffc0eb206b45fed4a9d4fad5fec33e5c274aa38e432027ad7ee2cf103e708499746b3255ef6e912886b01d86c113639aa50bdcca75b27e69c7ac1c71d2c8a68a9185fd3a87cec76bd79189d6c128b3aff807eccb68b51be648f9f85916a90c7af1b7b7a8545c6084913d76946f7a4faa2a9c118e0b23216894a1cf2fb67f7ed0fa1d50ecb31c7e8d46add6aa9cfcd3690bd511480938277aabc45bbe58d91ab022e0f5d0d9c6ffeaf2167d0238393457e6b510505981db55d68b55bdf55a4441a6a4fe674cf819db9ff08c9add66fb8b7ef4789d60bf5a5eaa16d564fb83ee2755608bfbe81401a5fa73cc60cd3f9ea07c7847438812779682989083e188abe637f91e3dcaff572ba12dc480a37d066b0f934270cf6aab1afc17ff74c208003bb820b34e6f1a53024a9d362157fbafc9d3e5d92d3ed0e9dc9a1947c351740394a0689204ec73545086dbb9a9172d1f9bb2c18bcb495ab6e365d79e3ffad30386684a75d9e4edf24fc05eae63d9110795704796592a4ae2df6db80209943211f4e8b74f4883568205a139a4161ce051e31cf281717af3e294f72e1399a417025e08553a18cde02c9c1e0530f9e44d30a6d7080e4cd593680e375d8125c0b465494ab8c6c590cdf7b1cd9d0490a9b0eab2bbb858807b1208eb3ea06481b5605c3bf7ecaaaa623073da56f0fd7fa33f54cd05a10ab29b3a4150264d3a4084692f003d2f500ddb380a057c7a4053001a8a62c7eb209904053fa1392cab672a4650ebe6dfdcc44352c482ff87f8663dedbfba6cdb7210832fb6e36261d9c0a76b603df51307c7e6374da8a3a29ec38fa43b327505302375f1f463f12a301f0dfa0344e5cc1e0db3cf70d36b8ac6e4b7f371096d7edd8f088639f50e2305f6b85aabfccb14575afb0632940ea667865d41a52ec7abb7a84054c0a10443e9400e3bc6f73bca567cee9e80b96144a6e0c3e2db95d93612ac81c9ff2cba9b03a4d36e8dc43bf9e3c0c65506e4585e920739b581de7af4f4d4dbfaeda75311b529da6b39ad0a9332851a07371541ea8b32825b8cc95f43ae9c9953627198720296d3b3188f6bc488b55033f9091c3c9ad8f1a71ecd4f66b224cf36cc1f94bb9a68e2bd42dfe7af6317e74a93dc99f6658e4c14d2b3f5f17ab7dfb75b96121804638b1aee8d4a712cb93356beb50306b104c5afaf2d1b07c0996af83d045dc1fa8cd315fad51d181111a59cf518f268ae684f545fa1a6c1028a921b08f456d7e30c0f9154a976b86e9bb22e701d43ae3583d9d8ede64e8bbc9afc22140a6396832a409d4266b34c17991bc1b17e68b312bffc52c5390cd55eeefc08bde3792d023d1ce0a0f6f90a18d44a261dc3f5e97e6e3da27165d9a0905b4c95b40eaefed29c14faa94018b7d76e462facf5ce04569238bcbb12323684acb466ee602438843417450cd3912e5ae2a680c24927b3994b28af87a1151efc98e0c311e8a02da5d29d652b7dc162f94259986b4df2c9a7863efd0c0c9de3546731c268d484e9474981f4d790794f7a3788b4772c1e2f14d6a16b68ebba9d0fc14fa64c9fb2f8fc91ecaa8c5d6ae2898cf686145128bc993c787e7e3379f5cf9ac7f14d1b94c65782f1f510a7f3b6a612c4a8a4f6f3c1a255d802f020037cacdd1d335d42a362b82eb69ad7ad5d35e069317ac43ed167e846974979343e79e48a435e133c80889871c0a229fbc7e2c0a08dd6092c8893f9edc2e8416d19c449b123208553f7f37d3c97b9deaf77deb1e6a36c42b13fb1d32668181649992a9832542bafa82b37688cf1ca28ea59367f5d14dd2c57c17c2c93ecfd40b90c41b37c30ccf817b780964f0682bbdb3f0aae3aca64fdc44c61912195693e36132abebb75d077d242a65c316771ba6e37a3786e48cb74f963c6c6bb04be1f632d5e8871e9c95f976ee5696ac1a945ce123d6e35e89f292f23fd6147461ba8cae0547a98de495e2345494202f2db6281733a261cb609118a9919e2bc50ad057cc3480235c7a3e72891cb036ce09ae8d545563bf50b8c8faabb165b178bf627678e3206022ae99f064f85ec9e07c9a7888067c2c7ce1806231b7ab76e7b90911f8267207dd6745ec07752fe35d9a43f13818667d1a65c5f320e36565b7271dce072ef0bb9a14890bcea68ccbf5c2b02cdaa71a62e843ccf69d0a5802f22ea53dd503a9a97bcbb26d21e66976ae2e4ecea55a6c8dc9acce46a057ea348de4035e89f10e2a0b4402f59f18c5fb7b6f9d1d993cc8ef7f2164fa32359b0433c9cbb68b2ce6ffe85c4c3955ebec574467dca1bd3114e0e36f1ca784a3ae1568cdb678ffa0ae6adada0a4036d77a8f41fdc5777510a4fbbed610d8b47c60f891e8c8eef841287527301cbe1a7d11073515edeea395f85e33527826eefb2764a25fa9fd4c4637d2ba433e4cb8ca8de49b5c308506c45d265bfb7a799dc39a567f846ff7d6c215c9df49f8972f959db03b7bcbd097865b90771f0634f9c544a0ae550f24cb833610dc001fd4cad8688bf8d34f2d1686f16b7cf63fe74f6f0975489e7f4cee442d84b01de2580c1f49fe85299b487d283c08d969065bf2fc1f4241d5f2f8689a75c412942c05cbdd7e3976a0c870d620b40a04aa1e17de34f283ed102f20638da42005084026e82ccde094db540934adb74c7fca29a863cec3a63d48d2302fb6211bd2967efcde0802738cd167a98a6af44401043ed0338ec5256c2362ecb2b73d5de4a71f6c974cb66d9b480f13e43fb7e3a29ad0e2f0a9aefaec921dd43f8805e83f4f96f217f3913fb1387f83c07075902c9423124068a5173d16cb05a3328a79678ac63e25898eae683174935589c1644a674c060e1596faae8a75da5b469e1575b66ece5289a12145c3a4becb3d953e406bd9aa49488395e382016570fb4ea9f73c24fb7d3b8afe7ded8d06415861192e4d3d52f2e3802bb23975d0e3884f032b27dc9655ffc2ec46c2888c327108648628c0532d9a020b1f7ab9a76be1f3c7a7147ca2ee5263f6e3fe2c6ec3d865f6e1581430be16c9024d1ea8bd9cf93e7f1abf78938c67337075fcb2ad699a4a2650248975fe640b49e12753daec39212da7fba5488576d4f80765877638ed3fcaf0114f2e9c6d3a609aafdc4ba082b6b5a53e14ca9df3c3560879b1aa8d8d5e6c9f26eb92b21f48c89abec4d14c216320d131b44ffdba52a67339058e31bf817c2721e38a40101d26c8bb37cb82adca2cea5fe222626155da24b9dcf7807ce550b9696f03c564098efa098a28ba72f8264df585beb63ac8e31519b3683949b724cc438c012cc29135eaad2aa14748e9211e036a0af8db6b08490be30d183d7c06ba7ee674460cb6630777bc17acbe38259b982292f2efcd850baaef6b2d2a7f52bebf39aed8664ab80834b2cc8a4c0a96cb5e1d1ae519f73a362d64002390b4f8132ebc352fbf36339be250cb6bfac141c639e3fcdfa2c229d7021388a3ba6377109c204adcd18174505fc4f5f6c64f296f6c464db6deeb4d1c06bf3cbab9c6b5cb920be588bf285ed1e09de0e02bd4b7c7e0bef70832c8a3fe169aa7eb9f685e7290dad73f20967d306ba0a1319f9a9af1ed92751032211c9678b5aee1bf241168c61c848be23b5be6166e334aad7c0fcc6d6cf98fca0827cc8e9bcbe11e6c7cf646722bd053300105c46e51480a9b79fff232c66c0d6bde54918623f4631ac1297adbd9d4d87519329924f4d785242af029ce30eb360a236289b9da6b405ced12f835d2ad7c5399d87a922f7fe485122bb058bd3f73b93dd73503befd4889dd31433c199ca34c3b828750b7c77ff4ca5f80dc7cecd329af6da1344ee87a756af26075d4f0ec831265ba429c884bbe3a5863dae477cb69690e56cfecb1d4464550d33f8ecf71cf4525ec55eda4b535331827b77eb2ab465475628aa2e5b94ee4d4cb61fcf063eb4371e067a124132e5a979a9e36452b3a5abfc1f6e5ac75f4728c18212a1f693a863ef76aad26f5fe5828088bbc6d37dc4aa052835fc467749915480edb4603f8eebad9e9b5e79d3b65818ab59afbc8b0b7e5cab5b5fcac87a6421616f7a36537dcf44f3156771f2f3ae55f2322d9597957d011bee87949369bea77da7703ef7c18aaa36125bf6a6431b19c817f971e3fb616ffc6bb6491ff4f21c1dff0c95b6bf19aacb03ed19f4e4e142b5421c88410a4eb9fcab2f33aacd78c68c92832acc1041cbe8875d5f0d74f1e3d21470b6c64367dae738130e9855f1ea4f1486628781aac8c5b7e0faf0b81c211e9e57c2949498c1cef5d157abd07e4cb646e5fe9ae140974e98da86e2e1e32daf7ff25be6d371800a48d3e8408cbbb2dbb4c4e6ad2b4c940618afcf0ca261a03378d5b9a747156866aeae5a04a6177f5b0e84d38a887257ca03cc0267fc1d035610e2c9db9be741fa582174864274f15ce07ca37dbaa06c1b110d0c05a181c7d366fbe062f1cd6e4c8438adadd77295dc417486ce336ef254f4c1e7af588e585c5b02a1b7d7b67196c726ff4b35326da0f0a2bef8e7c6e49e22af2764c578c5c3569b02a3e9d2f3fea78996112753e20c19f56c6f236b5ee9dbe21a256ad0708c6483c5d47659b2abc16ad5212b86a7ee1ce7679dbac2a7e623842c9fb935d1f211ab3fc8ee7929756adad80db57fc80849f5391210d6d18c8454f982f5adf16646cfb4099644e09ed9abcf88cb506b2c9c3f4fb53dcb2c78f781190f118782cf74d9ab54c4f3d8d4b426f2fb05f22397b7d3cc7be9e4e9153d62a716cc5e1ca5e3fbf125b89ae3d3cc038555665091592e768c0df926e6d804d4bda1ff4f02a84cd0cae016fb9f5360c966c2685fd39be8349a01d7f2a1a086dcd16d70f871fd75fdf2c7e821acfd34dd00ff53b07269b2a8f1748a3d495c4717e7fcdf33234243be17eca7bfde3119b07c1bd499d5aa4f8faa5c46bfeb5115727ad18927d521b052767d4ba1e8d3adc5fff75945bd17e1b4b75595e04bdafef18587b4765b0b59f228e7ea3cb124dc32e8a0b4dd1f43c7f6dbdfdd5acd7605b91f67d640a348f3a20995cc4fd870bc41ac679da17e662f9ea39f4c0eec7cd11f4f120f444c4aa016e2cd2d6fa58f03da5b2432837e7eb02f7c921dd054485e7ebd04b0a1cd6e3c160e5ea8b2bcb9275782bf2ab52221b48fff3b8fc2ed1f3acca65d4389d94348e221a3006075fe23bcf0e323d1af3b2ab652408e67158d509335145911e1e898fe8b982395c3d1e377e4a3869c0d982ee10294e22bce60eb2dc2021fe0e7a3af2d8ecaf9c5cb99e47cb667ca9ea60783e7fc3f0e0b190a7da8b779752f99008428cf2b5bd61ea5a04a52e258c881480ff5247f41bbb06501a8513fd84234d6b857b01852120c07cc1346e8b83dcd960b30136d82d119ef096dc6f394ce7451ed1be370a410d786500f94ef0bad8b7a7a14a2d161b9d8e00de7e6097f58561824438d27e3152eb04510a150a487bdf5ef70e243952b31d16f004d9f66d83422deb92d44139af1ac22bb69976e71f9366d2fb4a8aec0e439688ffd4d43245a268765ebcf71451ad35b5cf859e96b9fa24097f3644f85d197d44738be56324634d4bd1c0a59d2de624bbd161e58053cf13ab3afbac885d21a43b4df9c8e891f509f95055fd5473d5c2729e04140a625349dcdec98eb1ead1e45197c6e85d1cce8e8200a97b29f252bfff2dd5323d071304447a3b657ab9f3b5b16f120dcbe04af1239f50829c1d196379aa22df1a09d0ff9067ed75f0393df36927b641c8dfa8517c4da3e5d90bcc4904763ab49127e8478c6b41a5f9bd205e31665d7bbca339e26316b18b5efd6048a3b51226f2ed0ecc5313ac7b89d5c86e4621d73b34ec24b8f80225d2bca5e582569978dfc12571eccb5ad93dc48fc360e367b00bb308f7fdb6244175c0971bc1f5d4803542a20ba698457606b4ecc8e49f45483073271a9f7cb23006c178eed21f77a6d3a3ca0f8d8915f6169454d2df96ffbceb6dbce0d17d6d4c75855c747ace9a4df78602e59ab0440e0709fdd55201b72bb9bfe62e650a075a7ea9215796fa823edee235232eb8e706166e432ec0a19fa61607f30d0ff87aaebea1b8bd361fda108b0755d954009ec54fe6ff63b3d625739a4ac6e4710f4e2751c3f72e3d1896e627fea556a3657669df02ea129ea81aa503af79746207cb11497abbbf53911728f5b781f2614086f3e823ffe41582756b77773a5b20adef4e5d1d5ccc444767678f35b9779456865114aeee2f53e9b1c28fb4e06692ea50356c5a1c56c877c73470a23350058591c00caf631ed82a4e79322327e3863818f4a5428df8b9dd268db86b8adbab13041d8c354a87ab87d0149a81d427a4525cbaf3399571de1c6ec0db77b3c652f0a31c97103b202928f6a58f99989764bf1b2141e95ebb4a01795586de3fa1fb72da5c715cd89e3e58817314218b5b6ef5897cdf27ee5ada581a71fe65591c8df3f850900e6ed79f05e0d71547fe5f7574827f60986b2482ca4be5549eae80a0364c8ece5f5ee1a6c5cbc559182360c84552db3e9afb392d40883c3ebf58783d73084b7fb5ce87bf6ea8fecee0c3184a59c09e3637752f1d256d3435a87c692f6e5366681b0188c19571eadb1c24269e12e315d2273d24ca387c42d1edb4bf695518ca972189d7a980fd43c24f0c0f48d02ff66ef29348dfc1dbe0f258cf3c32bbca38665c4f91b42f6ff39439306aeab64e2bed29dde1ca399e4b969d6f7066cc19f80309709bafdd8fc2b8cb1d2cf5285b2cc602e96f839df86e37c117aba9ab9907ba5736ce11a47f00fa03e8626da0119ca3ebae1513557611bf5f1a8f7a7f1fa402c9c1251bfe2da1eb13f837dc08ff0846b8372c061e10792b3624aa54794ba820432697a35597a5f8c36cec51a84ad695d56c0aedc81b94215a8849738ba632b8c82cc646c3533d31ba72997f7d5e2689904cbda63a99cc782f2fdd68677d78b5b69a2ec0910376cc7ed8b413be1285e2755bace0c6deafd98c56d94d48eb3b6841d30d693899c81a55b7a7712b6edfe1633c8bdf78b44eabbe8c34e801bd54fa73aa79ec82824af817e48d659b92fb7daa6fef67b5d1930aa0f6b822834f25076edbb39f0b1a607b092e41db98b8e7841f1290f7fe5a483b54f1e6177ae3f70fd82c7e49ad60df8d1b8a32b74b3b979352d5b5b528206b62f705393bccf50f8681e91f54d556bb7ce2776ca784e66896a8b04aa4693f51c0ccd5c939bb3d11d5a681ae399052cbe3eb1b79786446cc14221094e1778fdbebf6f3baca8ff8851954fca4c07878703509fcd608e97f49fdc3050914d3391db100be5ffd580ac14fa5f01f36e063d8e2b019a636e23e7fd83c5efad61e9ed3fac8a9352e541fdcabdeecffba68d9194b222501e8671b375de3d676780f5445d695c864d71404c51426759ed8ec3c6e091c7c036383a1488ed8bb07fd225ca5fa8e8233314f2019d30db7bf159e3e430ba28f48a881b9398023812374f5dbb08c631251997480186027f90ec1fd5c4289824d901c01a08df304f64f5eb950aeaa09d525598a29aa7b431cb1d52e82db27db7fd6198d980d533d6950cd4ebe6cf376d9761c42b1546e77d3a1ce1c276a00ab3f7cb969818d60b6a205159165c702e8c0f88650345416c7dc13f82bc9d73c0a02d0cf7d688652608ea43e82771a775ed55d8a708c143d3cdebf0a69f5e25b1ab313cf31bb6ecd7737e40289470fdadcd34f65d5684d64610a3b24f91982fca15fe4df824586eefc0b39453a455c89c9b152daad68f76f5ee389684663a2f6717872404c7123c30b866ad2dd4c824ed9c7d6182c4a49d8477e337bfab154995212892d7e2767e53911bc092080e3a2f3a11bb3efd8d4f136537917ff1e84f04f54e7bba9471528cbd739d60792c9cc237f5ae97e2a4ae715b6f2150f6ce195efece9c8e5cb8cf80e92dad33aa43dbfdae3b10a09380ec2295849ca0223c11e44f4e88bfe36300f670db47e848a38fd1a84c07d790470ab66f07db38f1cb8d7525e6105f1bd125be0b499649003f89e2a5be657a62990343688d9d153ce3e69dc6cfca3e27dc5c416cdb0a25870508c9d2823991066fe5e9bc3459529efde70e6e6a1e60c3c6bc5e610ea5548f132d5bb50a88591c833bf7bdde5185267c8e975c00945738db036bc6518d132efd3db494aaf805909f91badf7831dfe26499a689a05aca99644a2b2cb8b907e865afa3945341bfacd22bdca4ae0f851a1c4ae42688244b6d8eaebc4d71c6dc492eb1feeae3b61a7cb2ccb502b7009584bcb0440a098d00516c7aa4ae912fe90e8fd7175a7537f077f2d83744cab9188cd73332fb37ca5df7952d7ad66e039f6c45f7efef0d0e5bbd98c530f6167f353f468e226f8ceb7583ebcfaa4bbf9a3c0b8f6cf7f30c5e5c9295c5fe3cbed24a3c653515c3e5cde7330f612551825ae7b8f821358e4f6c0a47b8517f2e98cfba255fe8c9bfd224d53b0e169809b3f9e05003a433108c291ccd22c76e995dc2d38bd07bc517eee6305d4d0d0ed94e9692530ba3724e7c6647738656f6f31d6e7722f98dd9afd36ecce785b899a6f93650fe4379f36ebf2346f6b4b62d3c0650c13fa0a847e1d69c22a0194442582f0ae0683059a8340cd255983cc1ff0123d10fbdb475c4483e3327fa04b2655c0830b0a23ab3e1a00645bfec084a07dfbf41afb120e9037917cd0f4369398fedaeb6a8d85f201ea1bf749fa8b7b8ae7a60fd417617d852609a33d41b2a3c0c3a91e744380d44b226d021fae7d4d34e8ff899830edfa7b602ab853a57041fb0535a0b4f9f43a2ca8e2db45b50550b2066cb0f51bcdb5a15af75d3f7dc740c4c2fb9a191fe3e0c5531d6423e6ef7c3c043061d77ce43e2fd238092a41a4290cb2b3c7280bed3fa60b894400b1d442b2712aba6f121e1485c4782117c6f8767baafc13e677973ccaee4683d9829f6d547b6d1148b4eb6a7f4acff37031590b10d066aa0efe69672c9b8f72092eec07474f3ae5ad0d15092818dbc1ac89e7b31d1db5096372584ee9694c731c417ed4bcf29699262504429c5ced887a2cb19acc082fc86f8ae48b7c0519e9b5c8b87edf965389a1f61d0de7597397db01d853a7fe2515100b6d4a9068b86b021410a2d4721892924cb5a627c7cf15fd2064622860d53111d159c8f1ba25f2213a279b386eeab0b8046cae198ba4f968d0f887def65129e169d0070923d79c9650321fa9e2ddd40f2e3992b5a33f660d825db6efbf0a23555b3c2ac384d5dff86ee5c5d6a0bed4fdf307dd22297cd4a275fb6b46b2728474463e5e7e14bad26e709c4480c5c0e9a2f87b05a44354a453cfd1f38dbbea131abcabe3da6d9e9b2f3b2da47806e09434f899e6d398ff526348b383469d6d56fa09c8aee96f75895727584c70384661ca78ab6ef182902197e1139c7ebb0e32949151f0c89ae8eaf6f32a7cec09dd12545a09fbe6f05b0346504edbe9a788be172368b3e17d1849f767fe3ec721da94900fa945cc19dbd3fc3b6d0de87d0afe77c1384f5fb128e4e1b2e438e80d2c076be44329f85a409627e7b00321012e54fe3c3bd350cdebcd45df6dfce4088d2003647275a86a6259e96f8c05337c195ec494d0640d88d1571412f254dd91d576ca69c985ea232c402d088a03865181b1c3913c1fb6de0b67eb1f61917810f0c04c97ed7a5fa850dbe424d6dd2512fc5b136d278e3fb2816803927f2a88a069a8dea79d340ccb1f7dd4d60ae8a2a379c954c8f8a37d3b8b3b0a6be5babb201906beb6bde9208f48a08d7900f79a2c21d81b9e9126e8460bd81ee78b4f53c626843729beeb3f0d4f4321f771f85291293d17ca03a31d59474bca0eaa74f378e9f6bb908c83171b1f8a82674ef4f602a208a5beafb5d8a9b94d8ffebf2f38366407ba690026568eb241e6a0c0146924f3ec673799ce319a5c0c7cd87146bfffa0fa0fb65294bff9406ea6657449a0abf11ca716564d106b1af82b17947a655aab07370cc627af38345ff3ab3616bc7e8ba917e5fad1084c0b6e06f2a900d268ed2057cf65864ddcdceb4103d306b9ef320af562704606c354a777d3ab0de9c75d54cea992b49529b0e86c6539f6a613ab7924490f25a24106da52484cfb69282944d81dbbc7d9e7fe3498817514cf0c43eac0044679e57ac135b961dda57c9037dc9e763d2583f443105e1f6aea54a00d5119a4201c945a8a09edeb769d833c541aab7a6af83dc24360dd02c498cc141ff67579706da375aa7686a4fa2acfddab3e5b4144fb7f5b2dffbc37c89dddf2dd141b150d65106948d44caae090d37b262497896e7d7877f551d807d8792a9a3750db1e685a20679ae5b2f85832e63f81acecb78ed19fecdf08c5a31339c570bb3b3680b9fe06d630012348ef34b882e06cbdbae65532717697540fc8aea70889b9269bd0aaedc5dc10404f49beae347aade7df952fc8cc060caa327d6f16f4287d64c610423f3ad6ae486b55bbfd97e5dd844fc740572c00f87688c2c71ccc66c00c707d5d98c7fdcca1264dc45e4e2a3bf74fb4cef0487384811aa01cd66afdb5864d02f03afac24c3e5fbcbedea6e57fe638e5bc36d981354b5a2d959d5ae20f301342a4ca11842f16cc7d3ba507afdcbd09974d9abdf4cc9811d45f9859f86aaa8e116d9b3f64049d5457f34bb006bd4941933ee8f21e915d1e29229d466feea5b534273c5b38028ffc9aab8549f15135f96dedf79cad65f6a5a8a82181565a9bb6eb70ff903ba2800529a98d4746f30aeb177653f4e8d170d079e26fa05e886b8a7070dd102970c1901e571d2a7c09c056eb5d672eafc7d95ab580dbdd19280e2bc7658ac136858a29845e7df24bc6f81f21f8f1587acaecf672b7e86a4b809229ad8d8ca3bfd0ab655dda4625797d090f9e7e445221fc3b6e7cca67910dcbf05add0762a73fab9c615a86124cd8d24ac8e248f7074c165c2dd4b6ac2f93dd296c0781af07731c4ac7d3b0892b9e8e87da336ea1aeebfbc57e2783e8ff5ecc05441d3dc0a04911b27ffaf3539fccc990f70a8a925cf2d420eee8e81a09a0906e5e4c4124bf9f159cd24eacd0a5cea7cb4133f1a55d4ed897e88fe953b54c73fd54d5338e99b6a2c0d345c846facc48910d8af7c333bfdda462d5e999ee8e210286d11e2e9624d522720a818479f7cb1fc05cea30570e24fc2ff8df83fdd568c0f0b2db1ab436ab245e2cc58fb56fc3153fc5de0bdb4626f33f817691b70581e9db47ba52a9a1d059062301be3529023a017b64f5bdc602c211f2c3510aec30f169d52f3dc3c465eb9ab2f7a9beb5b3cf5e9a1ef80073667a8df0cbacf7f93049db8e37341976f914759814bba9a6220bfebdc1d480f15181b905b0e7cbe2f47e8ee5cafba4f05fd62577390edeb3b1c92d1c7b9ae5a1864db44b6aa55f3f9b748e20e73521fc96001863922997bd77f23b93064f05e6b1de9611a22da053f10360fb353d49e7f0de41af005909ed8cd6f0d4e61e34ac037fc5d7d72d386c3f82f8a7da80721931513ec70781252a26046fcb38f5311b117c609a319dfb93062411e044aecfdf9c15ab33d47d6e816cd5564e6d38ab3441eaf4861399bd414925131b49dcd9764e91b04ba9da054120fff2110e2b194c852d0ed7a3876eea5e245f01d58adb1355022e24776f1398383647743c41439ce9ddd8d2b0b24ce5ce9bb8d3ad472c9f41b3066f9e3e0de8fd3e3de5c73a8d788fd1fc0029f87565565919f448905c1642e8f7c9a7fa93da3aadcf6d48197439b902b9ba4ec8ea3de750587c3b172a3612c8d7e1fa62ef80865456a1ff3a2be8f78afa78b71b761e9681c4c7673c855f9a4cdef50e6a491b0487a82600cd30ad44bac3fa5104b4e5eb6fa0838b38b376fd30b954561ae225f8aa9cbbb6aadaf748928adc04daaafa06c2c448c65f08546457b96d333aa177c6645377db49a0e61bc6f1a938c5cc19782f1b90aae16b8da50371e5d124b5ea8bc23bad61367db1ac9e84ae06f840a355fc16d712e97cb5a769f8fdd2fea58941a98683c66c20d07334188b7d2b839281b076acbd74e47c0bc3ee95788922d90eaa31ae0fffa9569433cb1a8f08dd1283491ea9f3e4d4132e066e6eff0dffc41b9f9d8ca0ac7556a6702fe003c4086bf801ea06d989385f26cf087e0a1cafa088970e91304db0bfab388c5361670a220dffa1aced48d8c804d0c74ceb49df00fe8ceea9e65d2c3694d435fb02e7c659fb51a441f884eb9f489c3881ad2542e45becb76a4ecb5cc67758319277d4d5cfcccb10d2800262f5e228e72539a6efb11dea449109e0d71d7fa6e788c0db273f2f0d7f0c516854dbe6ef3bde1ed78a24677d0801d8d2c9d769098d7445f8c9f23bae70da4c63f67ede132c9f8a27ee6644bdde4e40419b1436afee12f255074a751c9bced782e56b589f05e4a9e7673747cd54062e901ad56b38081a44f5f88944fe4d7158e14046c418c05052580779be12be8ce2ed8dd3e595b966e8ad3390397cd887e4130c5a214e1b03d2c96a55495c3739c09636757a7d92d427aec1f1f17db23e6f78833e1e21f55fb2d401dd7cfacaec4b6847e0815c232b7f562f108f64085d825bd22c86313bb964ecfc0c7246023232287bfd78002dac2b5712d9ad9c49c3e845724912f641276e1c60daf7677083da321d4589e7f219b9413d2e9e32cb022f17ad092d295cd927abeb36997d09b99c0ca3cf4ddc449094b49bb780dab242c7e52e404b7cd0c7a23abb03966c888687f32ddeae82104898f9d1fc78c53415d4fcec2e042774fa6aa392c7365250643e73f13b839d1bb9adcdb83592277c7c757d77615e34f754d071edc0ffb559e755484697c571af81b8006ebd55a8d252a9327a098036dfe9b0159f0930f7589492524ec5e85624ed22378057b3f2e6af54c87fa167f7a541e8cc939e33b6cc0ce2e1944ac19762dac2bfc30ef0b6259ef3b547506b183b4d3f1d459c583a4c9276bb38e10fbab9e0958daeae41edc3cbc4685be47e84a8ccd09ad6dc583e7b0364a3023a74250adcc163431b34df0e3321fac3da9a4d4cb2cbd33415353d91d872624e2baa6dd8c18703d8d4af9e38444970b98c393393310b9d9c0e01db84444246b1757f9ec25529decde81e206d8d48bd9923607a16ee5604f59bf28156bf97da63863482a15f4ee29d2d14d43ed17c1d01a6d5fb56c4f58b19e4499806e763606934c3692f2faa4df8d60a1a3c311668f6d555117defc2dba446f6b4c206adcc37a258ca8f831577286764bda71ce1bed7d71a979b0feb4d4b168f93766341eecc397d062bc1584c6a6f078ecc009394ebb84a75382dd803d6e9789ce12a18aa09d4f2551f4ce27015b7821116b6946198d8601fab521ba6da46d9fec3fd18e7fec557f86d4bcb85bb61146254f6edf8f056177ba69b8177ff49346cf3a220bc1300550fe83b65962211193dec54b058fe4072e1da67ba8cad1d273373e843cae3f1cbd24b066d6331f3fbcd8eeb2e6a589ab1e5df3d991acd8d9b8293b844ee878a8a70c0566152c53b0dd8d46a08e1d9807aab8bd31c49f7e9b8c520868a1ed0ecf972d7a18e1fdf69d09e03ad57ca9bb95621560cc8b41a85368c73d348994275cce4d794f9e282b1274c2f1228d2c687e84aad477a707d2748370314a9564473c1daece6c00606d191c10a2929629f03f40effe27c4525a8af1aafe36cf450aa7cbe39e7dfba71cc3c43f9bbdb9fb887fafe0f99fd789a955516975a7aa85f5fa1027a17957ded5f489bce4582f33387b8253c5c57668b86a1b33115314c0fd74673986c99850d0b72cf70c7358e795feb9e6bb8a8090401956b888ee3d56574cd2a2dcea9265c26a76729ec2a3c017e2a7bf7634daabcd384954839ccefd6aa20be882ca8dd333642ae3073ec9dc404e8f361e1907ecf2773ae95656f09b2c4d7a582230c2419077ed14c517f32d0295aebc800eec0f300abe6fb804505727158a7b0d7fee411f5d46790b47be59cf810e668f7f5ba0c6efe84e449a756bf3735107a97aefd84148feb73941ae07033c61ae2c0f44eb962cbca1c6703c444b9bcb72bda82b8549e5f2198e91d7c1c2085f965a49cdee96928e9a2b391b7275a8faa9a16b292334adcadba0d03c16af888e763ad8b92e580ffeb0347f977f176f136726d03f8585f2a48ec53cc5eeea22f50d56a6fda008b6ef16539e6744104e5c2fea6abdea2c413e4c7012424b2ec98a38e9b784f67e5813bf000449debdc1af9e1d52eec1ed6ede293f4012cd8a66786b6342aab71c62d10630dbcfba485e2094eb346273c723173dd01103c719c80eb17a88ecfe77d67885ff78af0c48fb2ce5f49b04a3cb3147b1f6256ee705043d134ce10d11b8e6d22feca50302815dd7b6459891802f02d5bb2c03a2afad4897710e69451e941f8de0ebc66bf33e6f2a2c0ac84237eea972c90ce71dc81fc4246ba46e7aaddc5a184272e834537f627ad562d5622e31d4ca6c9e09131da63ced68410e454c2b3eced92a6124722c07a9a54e1056ecc0ea0222d5f3dbdc46804368ce9b5c47f3cadbef4c8a63cf77acb07e9ab29125e40c17bfcb9d4b0008783bb26c2ad2d771435e39d6af94065144f55b271b818e01493c53df857bc85d84b5d2c5f3a8230436720ed5016c537a816d9a7f1acad291fd7799806be226337cbdeaadab21c9a873a52a1a08e1669804075074e0733b8424074fe8f273095ee70d347f6c4ccbb15343874d646a299d6c68ee782ebdd6b3b1e894fe0d9df281dba401829775a7f3e9f31dd492d71cfee15cbbb6daedacd582bcfecb3088cecd88f54a8b16b52b82a3924bcb7dcc4a442d9d04004417c33963bff9705ea97acb7a7949a3ca121ce3cafbe47cfffe402ce548b664726ee3610e8bd15b434d9fca4010f483e11be5f4a17341409ab3abd05bc68d17416adadcdf9c7f7d7eba3728423b20bc0ac5f1bba0573b9bfd55c6719954af14eb804a9fd546a747fb177f466cc6b37c8ea3bbbf9b93cd9cea9d37f59fcd49a4f8768b680ae48c9ffbf5725c621b77a76ad8a575ab49a94f40eae69380ed5ffd3aa4f4d975f643bf572532389480a991c699c8295292ba02a5880f43675e52eb391a4a2faee56a6c4906cdcddc12ed266c6346015611ca76656fd2bf929dcf9cb6de05c4c66022427fd4fdb6f10242953e197fa8961409d41cd24837c38e2438a6db4413f7015c61f60bd2e06af2c6f05b22298a00a140f9816ce546f128b310e26d71075615d3a57a72c9a29864a4ed91d2186be2c197cc050630464fe3cf13034a946132f9f677e4b8d7d1bb03721d3523bd8559283e2c3a2a67a90bca84d2947455a96f3f81f116cf00efeecf99015172a7982759f42523af70736f9a1b430c8984ae80ee3ee3dec1ccd8ffbf819bc06566adfa6a2675b9e18cd54240b22c8002b4288d4acc83a1a0e04a2ecf07c61375964765786639397c7279a9b5933bee7475992dc0a9e16e440eb107e07ccd3db958c41c7625783fb7eed528f79870e8b498455558ed4b532e5bf0a48bc11806c2645eb34b5539551dfb6d84576440a6ca384f543d27d7647da9190100e99e5cec2a282ef85e47ca5bdbcf95245b4cf85a98b4973a126861aaaaa240297929279090902472dacab33d9df677160be3649db8b89bc5fe739fcadac27619f8a3316a20bc487a77b821939213b682d7970e79998e95148daf831ad8a5c0968c07cecb17ff4ecf868a856161835aa0208f089331724b18699e3ee46b52a3f3b234a4f096a3021bb9ab898e54df7600c01e0b376223fac7c3ba86137b6d62b77e96b45bd53d5478378bfe1a22f6806eb722d41c96aa3b270755de76b175c435e4dfe0ff2e03f4044ea36ecfba463d87c8ddf0dc982eb19543a835ebea93de72f57b8f09d33231f119fe7e863eba005f24bb7ca60493e27bad578d8e2f3d4dfb2b08efa7ea7c6fca2162d4dd01b37b15864841a86f7838093d646514396a0f03ac4369ac8b76648a26e21464f7503c4f5a4cd6083e6154aefa4b51abcab9027fa9b376449dce710873ab2615e3e06cb66a225cda431ff38443e5d012d5ae505b7a54987a4ca73f135d045853ac89a9b600bd885b2565d1f8477e654da1754c0312feb26ae218eb8df369ddc3405860714079957b492a9f5e7db84504a3431b50a13f1a73fd1bed1787e272ed8bc103b142f265ca97920e0bd40402b533732c924d49a4d1ee4a70857f6a3677a7f3b4e14dcbb8a0fba2645847b9d766d00b6d25a5653c4423761a633a224a2e1f2fddb538c15b196964ddb44861c8fe9b453ceac353f8290042d249407d26531c2a10b8f7da7cd6bb9088a294eda4db4c8b77aeb2ea938b4b8ddd1151a26b683a8636458cfaae3003087d0c971c1feb7da65fc1537e5ef6f789d7a27d87428f82718713c288ddd437993b328c1068ba754001e1e3d40e2c899023db441fb9de04dbab6bfdc1abca536c73a19d398659a781ed98cf159a621b88427e5dc3ec53bae5e5ca036050655ea4806db205a46021a3fb6e124f69c7acb5fc5845b47e0ccd787285707f5cb8738eaec777c702977d51e77fb5281f03c6ea5864558da5ddacf86f148466c040dc8b595275968f8f59237b46b8107a3d9d4cada13ded1871b3b23c042a6b4a0b5e5195178eaacb5f3aeac74c8a7454ee6bbeda05018303228986071237d22c71436db281e4fab61200c4c383f2afff527265f2b95c633dc9c65c76b4b4fced28766b2984c96089c0ddae66ac5960dc08a2a75dfdf4437acc4f6c9da4e71ad09709eeb0b369f693af29692a359936ddcdf50fa9b77b52d6e384bb7e9846f9070f3dd4f27fc3f875e64f0e17850c1b9a37c47ed3b8636163b0f0b35e63ad291519f5ddf5d68d3c6f3f1f864d19740cf03ee0de0f10157ae1b1475bae60c28b702c24197fe9532cddbe6a362085448ce2992f9f92788a4942235fa5862ea31da194e5cdeecad19fc4ff37065c54e234df7570033d0e75c6819fc12a833c7b4e3c7f1cc6f640485b5dbf00578b83ec2e9258d506b519205872c4552344d63104cbe33a5a7177966cc197418a96c3779ce24acea1a488ad7d1d902486dfbf7031338c06191298a8e486ea0290133119bcb53be7502e83e6ab98ffb291be7182157aadedd17e7b1e2e937bd646ff2a1e1553b249928710c0011656b87e6fd418606f3a93de237781269a754e2a706fdbcad285b19be0378bc839fdd8a73e01abc07a23499b093888f2f62e0d8bd3088bc3509be199aa7ed940a453ce3f0d534c0342c76b68655ea361deff44a152623c1b56809c52ba6b8127681a1fd9a9d5c50ce8b2ba6992678c4fecea2203b8a228aae66d0c75ba1c9185e85a590c55557846e35cfc140fc833e7a914ff62982986c23991b3f0d14e99d7e48ccf7803e55e12274122ef89eb4917303be6041ff2536386e18944d0133cf24cf533654a78a73aaef80c5b19e9c07d4e0ac8a2716263717dcf419c67afe6df509cec0b68106f965682be639cb83651ae1891226f5eab9c39ea805a91d1ff68fb353eb4875e7cb2912591c6927f643aa86b9bbf45e7365945e1d5570c1a38c7b4e910c04658632c3be706ce027343eb36c194bd7af33500a40a0e032e406c0dbc01981fde3a1d16f08b59c9ca37763b5cdd87abf16cf2be9c0e9d79075732df42311273ef5f6087f84e0c5cbcfc135da56d0105b2eb400cb65b7b4eacfc9abfc2adf48d1bb06dc8b3e1e71bd90aa6ab445e00cf80e114e2ed79e0804f255e264537b313ef9011ccd804b8ff07d1371ffa204d6bbd13052e525f63504b7bb357ed082b385c472f13f82865eade8b7fa68f5c35403c3ae27ff08061a936906c2abae7415ef12d4eb5f032ddd1598bf1ff662a6ecb736fe6127e37c6364db917853a7fd60a58e6d2709c9d31b43d2ce824dcb0e3e747ca2327f2f933e487d6c16de0fd6b9c48b611f1d114aa3e61e87fd334b1e711ec261f2b68fa818199814c26547e28390c6c5d0ba6caffe66df37700dd657cf5deff63510d32ad603a4cbcf96f47edbba86ed98b1b2804a11d5d24e08fb7aae3a27044259321dc7808218f44bba35c08ddfe32984d7be49c272db833b7a8ea800b524c07697fc03235e4fea8c37080cbb5eea8ca538c2287140c536d23bd7ecaed138a8672165a1ac7b83add582a366cff3c348cf6c1c37b3b4d722ee20c9426a2d35ac03fde9fcae7e381927bb75b23c810a2ff1f718152711fbfb228ccc9b59eb0d5d1e88775fcef9319e40023cf85b1850e3c0cd7a5aa6ee9fece1e52dc4724c578d4b2dccfa8d52b4a5a4f1fee3236a361d51f8cd587001415750b8d4223ceed3f58a3faf23d2aa289dbb117051767a8582508ceac50d8858bbdb0432fea94715e56815b0cf375cc4ae795e5c412ebc74665f479ef03649a0a85e9876da880f1f026bb0dd154041596fc39340c1bf89fcd03e140a3b2a15f2d78ea5caa02d5ce6085fb1333e8fbb8e9221e058fabc6050fb0cf532c46d01d9ebe5d3ffdd86535fc11a01f705efe1e3456d3da06ae4c2b410dd0ac7836b3d3772b78b7e0f3e78d2d97a81036cc1decaa79f54a5c2467724468e5bb96700cdf0ed5b27f798ddde0219eb20aefb96ea58389bd3bc5ac83865c1e86158bc55a726e916a35c4b8724c67da41ddc27e6fb724184f810b7332ca7b96018b9f5fa31bf542865c9cf85dc42a8a1ec9fce0cf914c075c7cfe262902d68b715e3ca8391ca0c444c98d05c466f2b5c0f8284713b021fab0131a10595e9a24ea8eecb85c75fadb16154e302a062eb78a8cb884b625244ab6179b559a569b4d193c403a7f78bf8d32fc69700e504aea4019777226fe5c3a88f08e6984efb40b4f2514fa8d1cc3466ed6e6b82367e56cac1f8530c18feb2a43cad446f9fd923bd1035a2c15dd2a44815d3d46ab719b856e85e0b25efdbb88f34241024e4da43b4d1d28469937de88f28e6804d9b7d64dafb36cf48295190352ddfb9540c4f91bdb6f57220de4ee48e8df52ca6236ddd6ed461625f113f446dbadb22cfd37d8c91f2d81f97b25843d863859146c3b9e7516719700d9a0be34fe58900896648ee5b8c92dee73ecbff8ce9255ac3f1560061024580a39ebea14469277306eaf00db85b8cde7a2cc26eb0c098442da44f6aecd76e40c60b671f5af79a64b1f02cb1c9bdb6a8638cbba94c59edae7cfc0f75bbcc596846b82fc79e07c2b14e20497967351a59e7260987d8b6498288545c6786fee635744fb7546334658dafc1cf93fae4745feecd08ce7957e24afc9e309f3720e21648716035e7926bebca3fac54ce84113f27a5935ba626822ace6527877a3426c3787e3dd4162de114e54b82417994a201a099082295d001f06768b803f05878f0f80213180680cab0322e46a96bfd854a4b021b17f5ca9b59b591168536acb06cf58b32790dc2a1d3d9ba7efa318e686e66b0f2534c5b432b334225d6b1e34d8ef924ff3e3d2ced0c11ba46aca6b0b864d19068d32b76dbbb2f34ce1ad3278c6eaa7db21a3010d26510094f8d546e4ecd10b37ef4b49abc0d606e7263257f09797eda1e579e57ba8c10379f1fb7c2976c3f17dd2eae5b3332e52417ea1e499c1df8a4d99ae2227d8aa9c706f0e9a12a2d60498feab44a3e7a5306f3c1a7c729e5ddefe689c0d7bbf8a427437dfa92e3b42d820373bd24085810f0fbaa366fc279fd183ca468fa5d4aca8b2d61566a64cb8d33e6fe9f4cb76087891b537adf843e0eafb32d2bb409292d47ea10388e8dc64b80d876cf8af3ff42c871f6d015735345cb50354876016e709c6afdb6329f23d023401c5d7a3383c70da07056d1c2b4186755ea222f02a185c249faca6b459aa3631070cb182e8ba199b62a6635d388063444eb9e2b5fc1807272b0129fafe38c05a11abbd42f1f2e50f9d71560d1d12c5b95f33c6866a36c83288cd8eaa5c539882839a17d8105b8154efb9581a68ecb55b2b72eea3aa6f809613e1d1a5ae549d893b510ee5cde0418e8b362298b40bf3272eaf7f8dd61aa9276f04ecc2c24d59d2e401238f6109d53192b4861bf4c551d7ff3b843e47756c0316538b270d9fb566165412229c9e3b2fa7ea7d9d45b358c921a24518c7f2704a70f2f2316e205a872103f63de9525ea7bc0155b71913b4918ebd8559048341031f9ff428f8df5733903999056f675661afaf6593a2571b2cd4d6cab19aebc04e3eb9dd11a168ea8a59b3d624dbb8b6c66ee5cc6bed6ee336e11a94894a45b875d2b6df8473ac33bc52a2c899bea7f1934c10a6b16009b099a9c81555ad465e686b85774fe35e86898e32ba62120c35a8cb2467fcadbc06473ccf5bcbd39d2d93e1e1cdc4b726a06c95e1a45bee10a5bc418f448226373879922e60a0534e82d75e287ed2d8b3e2a89699e92de61c8070bd552b0b1ae7e6c44647d4adfa8ef6445409b473ea749d04c91546dba0104ae8d31ec17f51ac7c281ac4a48bb6645331b4af23ff3c10c9ae9215261807b3d5ef3842fecf2ba7c7c64fd49febfab717210fe6a5320de76ff303871f0b319291a5b62302653d237bf9badc5e13172d5d813ef37e5e0b45ca51ed10b1ecaca4e06937c970d102f518ae5d073e89ad06f0bb6af014a6e3aa6695f41fa3bab05734fe279ab6af023dd4bc59bc490cbf778f7dba94c1afad893531b92d127373563510e7b9f6295b05c226a37cddebae32c15fbb976cdbabdfe1ef18ef308ea6796c8a92df6ff0cad9037dbaae80e190e71e3d58b594b8f525354ba2a941a1a41d14c800312eff22bcdd4eb37197f68d375ff8a1c9f066031d303230e976e7fd0d29744dfcd06382b1ddd57ffc041babeed24d8055a3684f631a2630c7bed937bf514a0fa74afddb99731dd353db032c877a15567ba57373e3647a46f92bb96b5432b18b6933a46800d35b15a77f1d4ff747834a682f0271b7420337347179f91cb9e2a80721fa6c259837990ed0669ec93acf979d71e9b7ae1bffdb6c6b1c04b152e1989a0b7154f74352e42f2ad330890a0b4f3629941d5f8333cc947ad6d5ee15c9ad125cdddaeb617d2357f9c0231631b5da5191846bddff4390d3b6c39d43e893a1cea5baa142e9bf72c118a987c278ab23b2dea5125a65bff2add357105a78a6104398343b15b9586223030dd4f844b54a29df0fa979aba3cb97e629ea9fcd01bd760c9f3a5cc7750678c3366e2579dd61df29285227c2ce63316e110aed4d0d8787b09ac87323554af96de51662c8ee8aa0e0979576e3fe411fedc7b8dacd71b90e26bcb7bd08cbdc39855ed29f5178842973f223072249799ef55c0f909f32f27b43045ecc8491ef6705e75a31f4c84d2cc990a40e5d2c7b9bbfc2028c70fec90c5c401842ee6acfbfbe066938fd6fdf13d7f88ecf6a082a43707b05dada8dc154be3e13bd06f0cf9df7f4c04668d4c137ad582edc9887ba2615f447211ed6f94d2423ff1d3e771029bac6ffbd89d98b2437bba53ff903bfd1c78468dd5c5122c53700985f1146222cf149fbbfa793d46fcc2091e01d54c3b380da56ce5534de30c3969c4ebb38712b6e968e5b1c4d29e97675b0ab3b8d8e20b60bfaff73f483f512b269c1c9c88cf493c6610a719daa0d414c0de028dc220c735b0fa42ef3922a1f08edf037c577f67223baa419cb218fc9dcced59b857339e0ca15bc919e5aaa42a8f3269bf0baed178a902da3fbbbb2560c8eb57fb3b8510effb97706b7c96014c102195baf981635334a76478961306a59d26ccbbdc8f125b352d0f8b3a7c99172fee5fe280ac1cad4c16a50cfe80d21716c05076fef24295a569c1bf04ff8983950231279937d84787b04d70da6afd601e792d3a9f1a3033a82363d2c8bb039624f17912c01617c2bd4f7d5ca1b1b39f0ceddb715e05b0000d6d087387cb268ce057a1355217c6b910434fa163bc904e803d4afefb433f50a21e87cb21fa8c6853f8358fe4dda6ae89172e7807552026458d8c9ac4f5fb9b99afdbd7446bc1fba99672222eccef78e8838e33b77b69fc81503f024a431a67314cae47a17cffe53d93c98815a535648c88befcda78449e0b3158d8dc3bb16e03cb1b50cf0a80fbe30ca964de50c9a341eb2bed0703f05949845da0ee17c08166b48022deb23a269ba8a79d2993bf66f2a8a520db1a7b94567eba5ee234bc16e9770e220820ce9c44611b947188165e79ad3564590b97d481d3495481797057798a8e290407a184fffe7a5e5f6f99297f89ece40bd349d4c22e41981a6cb2d8d11cb9a7186cbf82d9382edc000e749dcc065da86a76cdc80131c23701f23c4c3e9b25b004a3ab421bc8bcb31567f21e3e01ffd709056a29a014cc44c16a3df9a5bff7892b175c8da27ae4497f6a7acb3c6a08835c7b3ae8454695fe7795a26f9d2f67ac044dfeadf5312cc3047b47b87cc25b931debe60209f467a18b5b24de54fe000bb58fb09677690e893aab1226752e55030709f00b3f674cf334773af9ff15122e69cfec1bf948c49798c74775872cb0ad84cae3b3837c29fbba1301805074b533f771bec2565d7276b5c32edcd894a4cc88e83ff2a5e614bafe6d999a52bf1cb09a3cb04e1f3d6ad178049345bcc89ead2d3b1b0fea6bd0ddc46ca986ffc432f14d9575c644acafb7a75da34f47d88d3b63cf625532c4522748bbc609404867f6d4ffb6d6b3c03fdbccce512b39a2b8609989d6a850db8472de4a8a71a1744ddc23afcfbeb2d037f239a78b3ef51961beafa16719424a3ae31e460723bf2d3d4e045b03d07af08a22bf4ef500cb49d19e01a13b7a297fa968f7d9d1d48ca58ada330b4eb28334b4a5e079872097b7315862f7f66e9e042e01eec5ef42e98237e821d3d5b01648957e2bc73929a94a568dc3351b8975b9886c0409d9de45fb7365799645ae522671304e19ca958429f833b88f2c1992e29d771772cef8a81c793223f19730540437dea17b90dda5d540f16effabdc9cd29dcbd95ffc9e99de2173b07f058a8b17160e1e27d173d09b24954cc98c3d80995fb181fae3b7ae652d45adf43d5ba5822fafc040042b0f289cb3474216e05bbd83960b8424eede360ac818dff67068d07fa510c83b582d0a6d004715a0d5aaea6de99f6d2eb1f73dfdf3a9cb7343544146b650e5e5daad7ddc5edf999b3bb7da16841d348f314fd77a253d447c4021d8449b42e14d86cf82a4ea689faf5d4d9a5d70ba39c9edd2e4bc6ca013e908de3045ede217934f0acf9bc770af9a27dd86e8cf3670a2b60c0c3fe1f82fb4334c740dc776f0290abbc13edc69f3cb324bca7a330c619d2d129b665788ef7cdd7e3315650dc85e13823c9494ab024e64970f77262d15b292b0ff7bbf98c65257fe8bb7fcca94ddb45b8ccead85df7619d91b49d87bea39f9c4c1713fcf0f6daf55506cc3270a42c04c344163ee260941d462ce71a373ffe81aec0a382c7f95101cf5b85bb71f47c86b7420617902835b552b1102ac97d463a885c4cbbb8d93be25a77046ed63dc045185c07493988a0a5dbac20408f39c151855a48616005dbffbb099a2cc1dcc82e1e01046bb88051342fbebba95a6159494cb3a0af101277c821dcefe4ca5d77245dda8460e8b9c2df94d16bf0ebb84b2f681bf9252038dfcb16af8292e2cf3b4ef8148bbddf606a227e0920e33e734974f6cab36d9f298f968094a36c4a01641c5ac1e58dd4728f3d033c95d86406ef6bf0014a7bec5098e23889a2de516dbbcd8cd6f4b405882355ef9b5ca19d9f987569b7ca822b5dbfd97202ce3e0443e0cbfba589807c44448efb977df2107ea5f80dbc0c8d61f13396d9ae93c4866c6bda1980542be35dca124de604d6396b6af3aae2f20e415c94c19abd962a3b828c0a202bb70b5ffcf1d1a65000640bab7444b767210373523764159c07ed5a93a96413ff9d2605e5ddb72991c763a4331110e4c3331edbb2dd6f252a2cecc187a35a0fadf0c7f7ed6fa34997a349bbce3574fe66630ad68cedd102d28f10cf6a1b0e6f1ef21ec2bed3c4da010c820b8d2ef88c9d23d05a3fcacbfa72c98d1ec5f09adc659b7c6ec9c10347d609c509dcde405047c0885ab30e594819f7658a076701fb72b79126bfe3514f5e342b809f25ae604e022e59f4b54f90d4530605f9db10905939bf233b8a1d435a69427b8335fe832d31ee02c04f3fa12db3eb63776a5e4b6bfbb9b9403715a352b5575627aaa72ffff08e50a135d1efaa83791b5601185a71ed6e728130f0c8501ea1cd0e9834cdd9021e1d542915e94386da4138806478046304c711ac00f08f63a94d903a0d7257f7482adbf121053ffe864890f93ffced856f66a5e272161239ea62c7c19fd2ebe625fe121928f3b5b84746d44dea08139060fa08a2a30671d9df9510a5c15285597f09a0df3f5c8e5229f973171e2e5deaf2e92326a5163005604d619e9870c1f1f0ab3ee9975f17f9b29f996f41006fcdcf712a4eeed8bee089650d6c5cb58a60ddc2ffc54511f34f0fd186d6ae1dd22bc424c3d4a92d848267b05a21c52b0cbc42f095760d7119bd714e28c7174117be665fba0202fd657121f61f48aa2f6456d2282e1ecb78f282d22c2441231d507f56f988c43e6fb20eb0a9198b74b2210226beb093b244f8d54497677d38f06ec006e22866a6e0ec9ea5266b0608b33ad06c5ececa1e0984c9d9afefd810a52c3c47823897c4e09c21bbc5c4f09fba26d8292afc557e6de3eb9ddf206b1727fea3ed2ca332833f2350095a0cb0d1387a63090b35106d046fd7e9c782261b664f78c92df5db0fe0fb76202b865f6a614171aabd98972dfc6b5d46924833682d1b42e8e03f85a135af8c52a55032afa03cfbae0a0d5b3763cdb052eeea2a50439be4ba92ee05b8d0d63b3c19c6629efedabc2949b736eba0023a597351b8238ef1900a1472a77ebe56b8d97783b0672ef75c3d32b9821fee2801ab179c46380f1f3aaf4602ebfdf79eeca9bcf9b0066db84b60aa1052790bfb74c93c6bfbb90cdaaf791957664902e4de517a89789ece7f4d7db628603eca5543837dd356cd957a60a6e7874fd8d1ec456aba620f8aa5fb602a1c01c1f914558ea27fa65ae9f815482b8598966824dbf9774ae9875fd8efba92299ec1973d434a6f93c38b50f351f78ea4579e6937bb1d9d689e30eb8511ff2b70cb761398d52be4696f5bf9560fbe8b640db8b84079efe2b88c822b2f1772cea9b8f8ff736a810fa81062e53060ef268cf87bfd2c33913a5211580ea35e115783c2c11fd37a17bdbabd742fb784d87e66a26e8030a448526fc2bddd23d4a96b5d78f5718604816c22704c7be2cc51b235a19298e7d0ca45b4af9734c9ba647a47bd696d200066c2a775846aa1cafe19443ddb6da96af423e7500f63a11de585fe467e161e9e5a447749ad953791530c6aac9423f7c7d3814d1bfb1e72bced0019121129b30094e8d9afc6a80b1656a7eed8754eddeaa6bd20f3e3e4fbd2eb02868a188e92bfecf4dbaf056a12c388e34511f02063126c504c009be8d2f0365df433a65410d8b06948e6e7a17ad925a363f2a0d53c412617fdd29d85cbb2d3af20931ef82773d59a5699956241eac929f0422170906f83b6d5f81a672669c02d5cd3f19724dfaeaed0e9a38c8d4512d6f1e66c68e3b4f648de9fd0a58a2ffa9fd6d3e2c48c74ddf54147017adec969451f289abc6e537ca4be5e82f7a158a152558ebb98fbdea0af10a99ecc1b749a50e5517c9c918678235b5e2fcd30475aa132fe3dab6214292eaf6c646f2b44420560e438a238bed55af5488104a23863e0bf7b8df9dcbb2b2486667b91854fd8186d3a635840718c1152737f955f1b67d5b16ef21385e6b861bb0a4aa813ff08ef00996c81b51a330e1558bc32503bd8ad34f810d2c32ce7d5ef3374006f3dee1c56875c1f05a8cb71e3d2cd6d632177c26a0c37a6853908995883ca8b4f78bb54fb4284e920fd10b521973e5ed81a3c11bf70c119a77124fd75477af56bd654c66c4997fd21c720ba5dd9e21843556e5e5fe838f3045889cd4a2e63ab0cb6f1ad4ae78db27b9491a21525f587d90d65760283ba265f52b02fa194c9dd8e015fff484f1573b464cbcc8af9923d5ffab07abca697f0cd08f0eafebadcbba00d742efb2455c0268b29aa7edccd1f1d2bac7b8f7ca67295900655b4b5097e303bc72bfb4013297674a342171acd787b4966eafee6091645cd026a4d67b824d782512b16f14c37721b8171b99b29d6b4edf6323a34ad8272b92e5b6a80b95488acb6b7cd29755228965f6aee953c82238e0c316abfbe346409ce60e9b76a2d11b02e5a7183c3e3485871f924e0740e6866d6a67b1a608c31a10ac1aedf25616385bb435a05d981e65f3003ff7cd6c794bc4c1a20996cb637bca264535d8fb704441c045454a6cbcc03f7f0d030b734cdc19a0233b2f2def1cd3c89cc9f771f868082869f1708decb004003cac0481fd993051a6c1bbe6a9dafde884200414c4675a20cca37de86a5accae3e564ec4318a7bb7672a2900c6c0b48cd1e0734235201f902b0dd2b9e810da52ee59e8a0316ca6fb194c937f821a5d0e74566d65abbcd6e7fd50f456809d4e025025eba7043df33705f9db5c811a432fc20acee75da14f26de6f7a9491455964458e0620342b66073061085acef0edc2e757943057d1203b5b0521f1c705ebe2ccab8ea131de22f0580d606cdd78c6d57b8eb3448dcaa8e83f14fcd6315b967963ab768062df039a9dede5e677647d3eead709325c1ada03ef1996af6581530d4d8e8cdfb6e9259b10578db2b272031962d182baafb1adf31f56e60524f0aac271db7bd26e6daddec01c8cb49894cbf888e67e31a0e82d8502de82a571a32c02a2449746de01d1168a26cb5c39be866a29c9074417decb34e9a7cfc1b1f189f651fc40ac2b8f09d53fe95408f56384d7bda28d424542ec7a1f2cbdec9762cfa419e4717b1059a81b59d4f04622e7e20bc7c2076b4377aa9946a70cb3c3a10a35d7a3320be4f3c58ef813dfee2c363d530badfe708f1dce550ecea69327d9a5f420c1c4fc1ca809e7a75d93a6318b9f589d0dce6caf05687db16fa93202b899891790bac92663bff426a4eeed255f6795fe76a5aa21e26e6f2a0e45360dcd7886636db5d8d760e83d01a202071e7fea9ccbc103a067b595b83e6ed5b54536eab01bdf11e14b194f7bfc7d89e55611c26d5e071b0fc9b049973d416a8fabb3228b4da39a923a00ba3cf0c7a8b979e0d4ec9ed6318fc714e125631679349fa290aefc06487d7f77d6cc58a1d1f912c6e8aedf284a03ac4fba6da7c667dffd542cef5a9f328eafaca986fba34549e84be2922f4e64a877b0cb18c8d4c5bd5f1c617c6f96807d3957ee6d32e967b8655eb3e29893e66b6061a9aadc2fd5a8ff14b62624861717d38ee84781e825e6e0ed8e48d78a4df0c43f03ca4c328a2d3c702adeb4bd299c4bd45301517f55a456ded63b05d13e3fca0c475cad551f1218f802eb2a5435d5a25fa0b8bde4d25535bca05ee92d7f0a82fbdc8b971aab740af0b942cd7b9cc86bce3b06c7963b4224c32604d1292282d75a76bda6023826a32a3dcb5d804b01e833b68123338f86257f1568defdace609d47d84415824c926e440990b185011240c507436b2b550be24ffbf82f8ba867411d6847ce07a30ec2b63a8b403320d573a8736d1c751e197df3d02c0d97c00a993fbb376e0f94ad905f5c80979d15c0ac93a76daf65f988341d4396976658ebfad5161bc93d063f44021f9eec95157c664fba7ec915f884b818e341414e7ce089547e0879d56cdbd5465d1bab14e998c5fb3a98ac198e44e55581778eebb22325b70689c8f052e3b890deeb75d8e6e377ee0955971415f2b9b8b55e6d74064227182c9a3aafcf2fe4dab1d90f34a182304201933b22156b65d68f626ec44b4ae4fd03f5ab8322292aea350c971b06b2d2ebf290ecb9974fd8879cda7a8076c5950cadfcc301c54f7a045be69294778d1b32440e309144d3e80e276879acb40bc3e7260363ace63d432cf1ecaf2388befd0ebcf91ebdc1ce73ab9a68d93bee16e1abee065cc7442cfc2603aef12a3def033c78f1f068b71f642b1d3c63e7c6ebfea880248925c864ed40e55db83ed9f8105f9cc21592ada175adac7227139f6402c8009e6901ecbef046c8213c47502378818940d7ece424673ebf105afb8259c6d7f4fdd6854bb40976ef6a4ad95936ca1e18ce51e3aa9a9e7ace21fb75dd853126c1de85b6a455e92bcf997d6915071fc89b5f31f0b0aa81f23f4c3999283c046570620d42a8dfae6bb75611efca38416b011613c22a199e5ec6797c89ca6872baec964e085dd9d717434b8b00cf93cf7817676a4220239ebc97e8a58dad0894799f5c0610042d92897371ebd9a279905700af0e70d7ffc72b7bc2cac9509eb9d36a7d769ff97ce736b96e866bcac463b94f4c8fb697f609804786812168b095edbdeef5ab6b74a7f3f608419a84b05d03726963bd7e1aa928403102b20920e68b8afa4c86b8eaf39883bf84a3697f97fc84f0181accf5dc1445038ac87ed032ef74410b61c26acee5e28511f4d7a936031e804e5b9cae5d1aa5b7ea1cf382feb9729b72bc194ac78f34f810bb2cc2f4bc953b59180a89ddc30b820361c245a9ffb3360ed5c1954b1e9cc53613ea17632d22c15470508195162bed571a81075eeb64f61630e317d325a3de856d73ded6ee616b4c732a3d16c048ded0ed85e35fe7cbcf1c40d8eb9b6652c708eb47ac0f985013b542328b76774b35f11e0e0c3481a862639331f01bb901cdd064d574c78e502b3260152467478c2c5b612cea677af0408e85e9d5429ff94e12c5bfd27c0e41cb3995a0bffe8b74099fe7ca6530dc27f9ce95efaf4904bf38d141f59404bfe29fc5c30a56139f5ec4668a170934d01d1dfc26457aa983ec6b933a8c57143ac081d52342a6127b9d5c20c010e6d4e41ad340b06e3c15312d7454a5d6f92c6ab2f15859ffa88c9e101c3a362d79af59b50897171d1c93ee75c85b428741784c88de3921ce1cbd5902d102efc43329d93983599542b45ce67ce1b602bec97811ba6d59024f2b13e37762d682453c60d72df80ea298d2f793a480c926de89c4d7c8cd1d1eb4ebbb9614583246208287c6383d29c7fe6d0bc065e9501133baddbcf230815f0204d46671480aba5effb160e4c40878511f436cde0a65f8738544fae09f6aed403d9c8c107175c60885d1eda4cf1480f2b55907d7f00933d78aa2f9bffaef7faab3ec041697a9570e02e02a4faa384c2af53aec167571139506e62a6aeb0dc301864df59818321ac6cb532ae067b60f53abcb46979aeaa69be49f3805ae25c379d7388d7583033db4d3375338b96ee07a8cbf37269dc4d4337498b9f0f55068a548e9e7387c5c576c8add7c22ea0b0b1dad504042d379e7c4b31d092faf995a5731d6b0ce2bd5dae6ed9d52b0b7428a27cbdb22a5cb9b283c44414f1ebc9a68a9184110538158699b9c9ee24c78fe9e4d8a0d4822685dca3b501b921d9879d1cf0c1ad300a6c9ee43e8025bc179519aafb2e30fc6360e996e84091798c8faf5b3bd791b8706fef7c6f066f18f15f3aa8e59330a6df0f322700a1e5d7d65b5baac95068e3333f721717907935faae61dc941cb1c03690650f71aa460b75a778a4009ee654bfda37d984c786c5a064f8c8f066afc7a37daa5c560e674280cd9d8f7aede9aa4a9b856fe86549713710a8030d4cb58b3b0ca2d775834b00d5626fd046e6af692680397cde798f8fdb193bd2b3aa800ee6b000569191f360d6be131ac8bf0e88b69ee4591a34bf6d480b14e2c23a61d0d361c97ffbbe6e50821d327a3dc0125b3d4ad67e17aa4637658899aba7cb4a294ef2d6dd8aa11645b84a70bdd33e521280bf434b1005fdeef46ee42147c198b183afe048073997875cc47c9ecc61270a90a8c3a5363d41753dde9ea6241fe5bb7496bbc05831ace9d906c8884d4f14f3052279cdb936b0e503f043544ad00cc923d83ffb81c8d4feffc492fa384480778c798d9289aadc59250f8b98f9e5d43bec5b93defa4ff057d60654102dba7e39f9b1069c2bc8ed6b417e251c7c6c7d334d7a2ee58577480e6484d1f0f170abe1ca5d78dabb4799894a58b7062c6a9e1a61f057d1bd0c9a54348de7e09eda51702e6b87ef156d27ba63bbbcb0adc4f57db004aedea3e42b114af3c0cdd21c1e926105d69b5c42e3f30c8ba46706f0158492fec899422c3d102d0644c0ff814f371a14a301fa08086590fc6a32d530de1b8983e46278dd9249a7e8e045e6202a6c00625f4b68d58c733b096255efa42e076b3ab3ad5ff34c689ea711f4d9d4efaf2f611a56cc24b675a954b43f9d2f9700197962905d0b181b690bdbe19730e756350b2bacb5580d3224ac2f83401c9a6f43a8a6871da597f00e5e679b2cc2b130e8b65aa7ef4f6db9e1f84e8c4ef7b8f46931d9c6c9957865449610d656ad32de573bbf476c1d8a902227a7d4cabf2859b7f2b198593f9e1cb85fcd911546a09676030892a1c11f6e4b62476dbad8823159f7dfc738cc02abfe913d1472e37ecf076ba6c28fabf6e33e34e6c1b9ff4901a6dd7fb66ea91c7660d306a7ab5547010aeb828f9727859561a3cc6ec7100d0c9dbd37c03071a9d5bb118ad5baeec7fb091d1c2cf92ae6884012b25eb38a1cd7e840dc4de4953282d15538eea932a10c4731d3ff58b4d7e1a3eb70500ad030e2598cfcc1439d43d13ff8173c07d7a74452cfbdfaee6c65d59ffb6d072ffb4a85693d6b6d619baf3c0503eba1b6adb147e46b14f2fc3e546a7d56c713c68e5d4268655d319dc14e344404ab7c6f900fb43df16703767e77d50903e530a91e489892fc1437f46a8e2da7874159e854c2c9323a4c03416f5c1e67f152bcb0bdfb5348d7315c873cc0040d2c3f6cca09f1b852bf0128167c5bf3dcf765354f69e17ab1195c9bec394c6949de6fc33450cfa10ea03d5ab4c7808368bba4108e19f7da626b0333d481d673e56de1dca0e1b03e43e590fd684fe9c79bc29baef5cdfb7165a0b8cfcc44bd9167c8deddd78a9857ffeee550052cad233ea2ee88a033780521d4cc552da5676a19ea24b893a6026ef2058b3c2a76b9c26c37fe92af5388dcd8d5b6ffa5661c5af12183b63894b757c43a2ce9d0b1e6f3cf4effb7f30f39564cc15682f2821b454aaea306efe44bf0af6f2327c247f01c6637be80796ec32f2c22e77ee9b1a004bf1b091d4d593478a08bc1325e174df713d35e1922223e71340aa110994a275d6357228fb312b8ecbe1938b0af190448c5fd7dfea9283e9fa8bfeae3f11c16976e4af8aa7026cfa74539f34961f859b82769ef7146eb3bf9498280b7a49b921b6812984c0d6d94122325f5ccc3a197016fe8b5577703ef6cecafd0c907886a004d038dd10a1317fd88a50f13284c0c594b659d981559f68dd98430ea2efdf3f7c8f5eba19adeb12e1a412b11bdc57c396c3c77607f7c4027086040c2b8167c68233eafa35c60284f754614294187f357b7adaccd92f55240bf2d737a3790b694dd5174dad0e1d9e16b89b14086cad0736c4b309a9957de8d8e54bead8eb10d529327a7465784a555938b1e095fb08922d2d44f101544a8d314eb029cdf312a22a1d374bc7f1af1d8e2ca521803209ff5f58784cf092fa35c79e1cf24de0088c59c6ac88e2a88e374626831b74e61ab6dccb3de217bfc4f46383dc0bcc67e90339eceb8ebbcdc12d5fb2b556e1ff9dec2c167d3a2c8c862e9d4e389af7b54c364e1bed8ec5ac099c5f93b8e2bd6c0d9d8abacc5a9b9c2e26c42c9d7a2d9311a314758ca84e009cb66c0528f06e3442fdd7715f7834952508b976f8dfb4722c72787b35b2fd1ac90da6f225e4753ce5d7d91e265fce66676594f99401c39fd86e5e25f7b83eafed868a6e983aa8e0dd81cba3ec2a315c5e511300f6ede7ab30e0f9b09d990052fec86a02b6d170d1761ed2ae36b553627a0fececa902f89a46622af9a0353b46c8591445b43e0f617e202ac5afdf6b1fe231cf2bf78e54e6bda0a2d38bee0f00073e954d8e15fa82fbb25933514662f3b3934137dd9a512178d59e2c20114991f1e4e367f96f60d27549003c8851ec02467ca45a1facbfbf06f821070e51c0fe319658630a2623edcb8a4d11d006107235d0c9d4200bbd2bd4f8942f914cd65a8f20fa9831ddd1417a7b19afef9576d1c2263af11a1b84a8aa8fc976fed006d76d548d223a68328d587bcc67975653d260c8365237b527e151ceec5eab00c0a78d4d511e365b73e85a3b089cbc6f7e1afce7eff0bec30d89a2caf236df492e661b1f260b1516f4b0fbc411e94923bc3ae6abe72d74ae545e1686e6aa2361091ef07ef8af4dd5f47d6059f36fc3bbe997bd7158db1284a3fd1a48a760fd7a7f9ad144e5f483ed0fac16dc98f0959c8536a97fc089e65d9835a7e931817bc9a6f5539b2f455de5491844b34a3ad675344455e8acfae4b42b7054a69153d90a9df98dc29ce0a64e5e2a5098944a42b65bfcfb91e45ae9c48072f1d53075213f2f24743bd65f16e208d64230d507b025d1973a2465711c8457dbeb337bdc47fa2e1f3f320083be655aab7e6ce23ce955d4a6c90339b563b5f721d19ed06039d303aef107f56f481598c3b56c80f38cd1531453aa6c40755c2f2b2d31ce64186ae51a79dcb4633b62a361b7293eba54f3da09b6f1f8f2bb824b0a0564e05f7c9f48bc982b5c8481906790432db863a9dd90f621c4b6ec21f499a4dfc4a9103dbf6222abbaaf60b83d15ed4f943ba4fc9657ecee985ece7a598ebfe1e80ce8934c47d3c6608312c1817c34261b96a4aa4a018cac4640cc45206874bfa6d90cf1817702170cf15857e9d98ecfd1f8d05bcc1d0948c169c6e3aaf7de0c0a3293923d536150309379a986e5a745b77d3763a35f6ba4c646b12f0e8559e2f297e475fcad90acc2d550087837158e975b45698063895e6824718bd3a5483297ea36c9a93fb05605b2ca2bf73ff8708ee72db9a7ee2c45df23b4ae10413f3dd8248e75b7f5c4ee56a1a9f2f31a6a27150f56703349b3fe80ec3aff6398373108096b32131de0dcb1f034b28edcf186d52c579639a666a1888912d9c3b732f5981a1fb78fb11e0935e3cd54ac2d614ac20ba8c6e999a395a2ae8d8880f20aadfe454632d5d37ffda0eec2526c27ee5f782445333bb0296525b5a2c9768457e2f6a5d9c0409cf35a87faff94c850ec08ccb70286a705d012787d91da5ec5692f422b457d52c4909135a3f65ab00d66b18b2a75ebf5cff0a5f1419e6bacae08f64370986e13d94f5bbb1d0b53e9afb3ef994061dad2c5f637027998e1d7be5d2e05abeae7ea3db6d7c6d0845e5befbf454c12319a5555e0b08f19115ba70fd31200668fded637f62067642dc7bd3ccf6461957adf32019b74504b17d64a6e5e8af35c5852503a06c06219fc878e365a500fe20342c57f66e3310153c1ffc4634824497bf6575ca06b81d888a2482687ac225f6ecc11d4ac054898a5e49964eeb8f8160583c3c4a350f68d96b0116ff4347ad5426ffb71507770928acc1a6d6d163248cff4c5d0c96a51db564f61cd8de92f59332dff6eee677838076ca79f3ff694d9ab6fcedfc4bee66f04997f47e36fdb727b7797a96998b8684506c1c58f5430a0f67e683bf2a8de18e77788800ae3fd4397bf05a4183021d98ac3671c4c005ab00d5bfd7a5b6e78903fc774ba283abe11b4270d10389369e89f1e38c7814681d7952447150bfa14f5c3c9631df45f321ce65f1d041846464e1e0eeedf38d52a58400bc3b3931ee5e766f2abe02cee385d3f914257d97169f906ad643f09b1c96ba9640c1149dc24e9195f4e02a431916b5e03a901c3ce321181deb141b4959675e63faff78b90a729f6b6d8d3c03bea578e682ab2860e8ee3c800ea3be10a50217733a3463ba42c7bf9431dabe138a09dc00c607bb5d3d2ab55c1337cbb00a65bf5bd94077932ec41b59857983fe7566c2412cbe5e1b49e094d2af631e37318e51a287dd4d03f2f9756547d0b4956113b13c5dccbe2b860312db4fe30d043307df80ab01908c34130eb01081469d7a28c11f902ecd7792168e77aab8617096ae2eef375f79acb6a8b8bb39be54ed7c8ce429e1052023d189f39491184f9284305290c55d905f7de3df8b32758be1b1e2ea9352a39aad3e2cada2849e97964a4f3377cd99b7f5ae3bd07b352a8caba4afb34e67dbe3bf3f63675ca6e27d46402bdebdf80d6d7bf7a330ade1c95f4979f091a92688d94f65eba5cad549d81e959add6e5a5db36663d8522579689b0fbd32cb348d998326cd1df8452e0413439924cbe16cb7e6316c83e9b8eb2795d675ea8dcabb686c7e4c1c84cda756638395615017aca89ec05b1f3104c102a338ba463c09f50f53f1450db75fd793b93d57637196c9943824319d9d48d2e8c81a5fec95fab0d80de17f28ee66142c9f7acb47f145335923f180a409f5f661d644323abd63ee8f3e1de264e04b72fa602db9b4731c85b70ac45a6b2b57132169b3656d141c94086e00134bb78a8c3e2b84fd86441d4d28319f4ad266c7fdc5a0670beb7f8548521fd506f876db41858802cb4b4b8569ff961c3c5f18c18ae687a0415aeffd09e92dfa31982d3be530c6d2e3fa55a8390f5ca41005af3435c928a4884700002cc51ddf06fda811723c68cc269f728bb5e73af012e9a25bddf0d87fbd467166196763ea0c2ea04685e83b46878ae0fe1c10656b9533011f36a49285e6b9ba4815b17124c26925a66e076f4d793addf864171dd08e23e0c77e575c25db909fb033f1afc94730b275a2793e2c5b72777b9f0959ea5b573f3cb6aec984135214b21a99ca501311a02257d2d394a3c6b87070150886c88be117fc58ced1c1b517fdafc4261268a64ffeec29d3dbdc3ede63e105d763748c20abe195225d774c13711bd5f0d25a8d7f02720056de3ab616af8a7921c40329ac6d4aa6e5c2e956114c87272d9834103e230cf18afc3e7b4e67d7741a819639ceb9b7352f4c9aa015c15db627b647e8654a13f8872b55df16138e3bd18678983aa75af3e55a8e2e211bce08f17e499603e51dc1625dedccdf38a31952cf40e1a023c4f666c4122b1fa41d2221eb3555e47e91d67ce022fb3cd9adeedc1af121aaa07d48dd1ef2b24437a879953eea00b856156d294d7e68ba99e96c0882bb7c0f62cb30babf811c524547ad2e9f8c4123457ef339963aabb6b17fbfda31b0035567a701a3d52cde8419213b7e6f9f950237928995e576d0eadfc56d5e8e3f071bfe64b55f04f6152405ec5c4a68fd7502954919de556b29ec89740d507bf6ca3022f74b8b6722afb603fc9e70436c66ca3b3af428ded721b6cc5845c1207ea2b71cae076e873cfd3ff7233e382cf783123f61beb9124fc8d6de8b121455bec5cef127cdada8f1f80b78b3bb1d85b6194675064e3389e9445aff0b0f51b7aa1e3f57da5d7b92f08af9a0cc6c8bf7ae5015658fb0d299c720ae0885d6414cbe5492c2de2e70516e52ce5a390fe547e8d2d24f588dad1839f16a09f1f9753cb6d877a690ef3b87c2c6d969b823fcf8c77e25749d657f1fd29221920f8567c1c60b5f2df15dbc372d66a8b5d1464a4b8baffab37b6f0b19956dfbe29f8542e7d59e8a74fa47c37ba2b50ee7f4cdbf7c6b2fabe8daf44fb2df2c095dafcaa36809f02b0191ba316ebf12f49a65b6d31c00becec405e0db8432bcb6e6ea52e4a09659873fc54f67a96e7cbeb547b3354d48c9a5f636b6a751be2fd4615ac21735e54ddc8fe90df4dab1686e4676095d35d86b4f731c202a9a15a416fdd81d000072f7b7b2eac25083bfcc4202168d63902e944dd57be897b7708b882b04662cc26184d0ec71780b72eb78c90a0712a690074946cc32806d413f1dac1059636c5a65fa845c81b7a3fc5639fcde7e8f917ed43139d20f485281cff32328910926dd677c6f8b16fd43f4bfaab914d52b9762b2785eeb31389ff020b2b9bda3a171779fdae289adb72a0371793110e319fd7ee655ee30d4da946c0f0d11b5894cbe1fa0814b0a00faff3f3575a57ec6dc2a8236575fd2a945dc5a788913418207999e35ecb59c481a4b5f304b381ae8c39b4e58c1b0b36ad46612addc37dd3e8774e6ecc02b081db8b8e03970fe520388a6d0459a4dac2d617e9227bb10ea9fbc8ae4be3579bb8dc83a3dbce3e59ba4f6cd94fe53af5a2763a8e34d5edaf599f7e93f298fd98137066fbef4075b3e600ef2cfbe4f6ef759af4a91a414016b93090ac049466b62214d92cb2e1efe40d685329881185d7869dca4f2a197bc3f378657635315b38dd6002a134d899238704251a9048d182121417e8585cf0f7c8cc3bad23b06f6ce900784ba2b19c3132bb38a22e62fb8d99da35c78dd36131e473808a21b043afa11d13087c5639b152bbf2b63333a6b7abd45516a9f560166277bf3ed6399cfe05033b889e7a9f9f9dc8158d1826d61d9bfec01ab4ad8acf51ae23112fb444c12585d0fcdc3a7dbf25b0b0b2855ddfea78a5f13d14ecf2c5a53de0bfce2fa95a532998dcbcbca87d3e64894f1739d22fd48208fbf2124ec6a5b0cd19e4a3fc3a01c040dd6b171ed5e62220b401f70b3ea56f255c14eb076ba0a22690b19e5f768774b891d094cd9ab07f42e6e611bdd464f9c65367ec45f76f4aa11c18bc07c334b3e6be6dece20407e051add50d94b72bc9b747467923f3c7a143f6955a6f82776e930419371556370988e47f41150612f20f87c36bced9a0a11e6989a7c88c15e1a9abbbca07d3de4a6bd4cc572b792eab5e1749367d11714273e16451a6f1e0d74ad8239c38164a60f00574869cd105fcc17836e36f2c61faa34f9c10ef7a00a5ae7f79e10274f203a17f38538cad98374aa9876983f1cd0200ffeac4ac9f37455e00e43cae5e40cb3b8543fb28456b6e32f0776c51c5f8cd53aeb21bcb7e911f5f6d9102af404a795677183fc73156eb54b47e98d748293d7e3eced53db51fc0707f8f7297f1e77f2bc8e673c229ee30793fc5fec4f061059cebf4b356c03f7a363feb080335e1f824e5c5e566bf762867a130e2e82f74a5f1037c5872c8a1ecaa5ac331f9b6945496620780602aad63194e66008033f5021354a7c86976864a36f8642b8c4c5a6af3de7658da44635759d45de0a4f33334bb23d81548cec90fa9bb93a4f9880bf1355860f215e2969f9b50672323dadec6d5b14cfad81a388b08baf6d8b00717512b64812f1af8bf177d811dfffc73733af0d980bef1384890869c8caa632ee31f24e7356139366a74247425a7535dda0bbc76d077ec78ee6ec2d16cdc71ba56e9cf312e7a553cd2c580157afb03f94e4cc71c56d7501314fd47c3024e9962e818dd48d51cf93cb9d08885fa931758210c654188994f67bdc96dc3617085c995a9438cc413207408dadfb8a783d5968258a72e238c6a161d804cd0f8e452c295bd1464c82f2c1ea98f76799e595291f21164d3b67c79a54f4ded85fdc16c1158c38ffb2e0ab139307ffef6b68ad433315728f67a326ecba442d8c427380bb954da39b704fac7409beae5d17aff7ee56bbe0a578f5cc96e524f49fd02ce81ca84497dc39635a6f377646d07f5bd79709bd5715b4067d0d5a9b7520aa436655948996a126ac839dc6a52898e718c326d10daa6098d296c20cd766ca88d042e75608e7f7fa828c08b912b123b9c2bf4d8f3c2168ef9091133195e350c714e09c42f6fb2e225ac56019b12ed8100a233a901e7c7811bcbbd0e0de50ac31247c411a143cb5ce9d43cfa20a8795626e709f6bbea9164f6ffb7a29b6635275e5c8324ac5a38560c60b8a92257522026c0e145a75662b5e47a5c25d48ece59fff53ceec2988192dbd3fb900b27ec7df72adebd0f3a4cb8f0c13569e75fed472701569472666ab152a5231c73db07a597a1eb24399dae9e5f756a747b1a32474c62db5c85c5568f9118cf62013fe62a5a95a0ed9450412e6fba0257227b37d761fa5f7768d7a1c2702a2daaae119fb5ef991a0cb9df9da2b30f6c1df1c506974e34b2465f57d7b82a74070e061788d650187eccc3f9d87323552ed0ffa16f0fdf69fc74af5cd6ebf4f197217f0063f1ee0d0767c7ba482d77ef75fd75cea368651536c5c9fc661d89bc098f26b602ffcde3aea9141e9e699addf954fc802afd3c85e6a50d53bbcb6479f60afcb7b0d2fc6077c6f424ae8c4ef356fc366a263fae5de3884b737b841a249a08f0f90cb81c1bad6215a5ad847afbc2b2fbd75c4c414f545b6f55932eeb0625807d07ef755339f6c817f5a5452e35c2b9f2817d8358585bac806792ee14ae25a54f40af5b19a186dd6fdee073d2a9ce67eafc08ba34682895ff8be800c9fdc492d063e5494f67e53bd75a37098e7a840f03b1c2771d0bf722da8bdcc0658e888cab5726536948f1f799a14fd3aafd7afc22f4b8cdb98b6d1cfecfbf02f91c57cbbf20786680a59bae6803f595ecd3b49e0d6794f88d2ed456513c1201eedc4a00e2e01726ae1711efd1e1d1371c3c7fae99c0313674d5dd3a299d9293a4ebafd2a937a45d541c99ecd2db7443ad3c2d3459c90e65e14f081db4bd694934789db5d88f1ef83a79fdf8ab3c9f3875ce682118b385d7a9683263fc7bcaecfc4da8b900f3f78f614156511106c63864e9c40cf0845de0095e92bdd29a363ad3df7103cd30d987a007557a5c632e7ae3a3a490d89350d0037a198a28a918d4614fafb1e4443cab10af9098244f052b80aadc8fcae8bd427c38e6c348fcd51d757e8c3d6d3fca6f03f5b14c83657f928c9938be1789a30eb03bbc05ee793771069137c9ac033a4f850e8649bb4693f2f4c76513c642f4e1a02c57b4532f8bdf58471987678cbce3a76c379bd94184815c34068bac59cc62a38192c52ad5fe600fb3f33769dddf2a8089459102ba3cc3ddd5a385663a692196cbca4446830e82f3f381c8a6456c9d6fb9b3f04426d080d3939308801c8683984ea80ed6ff9798f2bd9280486ba7fda8130fa45dc32b8b4b447f15c9e4cb7b072ef92573f821394aaeaaae6a7153d458acd262d7e1b1e50470e4f0a7252c9fc18f0a3daada683683132eb9dac29c3d78a5e1bf22fc1921cbb79d3ea01350573a833b1df8a90483a81db5ad54863ffd249f6270d1ff2c151772d60a8a84f390ce8414b99235e68ad14f2469641bdda922d1fd0093a0e6f9a842a0cd677f2a565db7b7668593dcb1d336a91e5cf3e68100046fdde94c31335dbebbf39c12e27be6f60ce8e4475d56a91b78a91d6c3161797de9a7ed83248e1b631a880218a52aaef1227b6f39bb44f886eb7878076ca89311821a79cf3e928871b1bf5dafb3bd696f9a1a92657a02e26c08c58df3ff224394547c43fd776219587c1a4d0f0ddfece525792f5fa666643f06486c06f8f6265c4081fe3a046ef9b255d0a49d422a819ff7402d40ccbb8ccf7ebcf0450f4a65eab0bcfe4aeec94b9688a194b680111ca26277c0cfd55f8036fa01714b47fe7fb6a835e9ef5e6e0919ca8938aee0fb3da271ca0ef913a7c1807698d9acced763eba16eb8e14c99d75a2e08112271ea7e8d3355c3048ba22ae451233f57abc7b8bccd22599975be00f1c4d7911ba072b0687b2fbe8a3cb37ab0d94b7ed1ce5d3c4129a5c63bb52d4f34212997ebc68c100116f85ccaf610fc45d1e04a690baac655f1b3b79d6f0494a3e50555232769218ee23ee4cf5168f812685a4184ed284227c710cc159c3cf3586c04e6b66727b1861194197976b738e86e0899d9c3f13085fb9924382c0a76dee20946830724a9770554b5f63489602a2e60889764cf4e5c3a3b4189fec1391e4a6f4b19dde24e2f058a42a8b04de4fe9210fbec79a4e3bbb96afdcb5b521855d230282dd69910282690f045176d2eb3fd96fb1d9fdd90f983dca17d7661cea2bfd0bb0ee449a8501093e1cdf95648306ffe421183ee19508d26864210717b27032cb11100c109aed7bd4439db6fa7435b84e5b0e48bfaa9d852ef70a0af8902b8c5ad550fcc6169f376464f82d539fb14b15a4cfcf43de7ef8c09f5cdae58d322acb0401dafc9b6582f0667d737ef9ada281a1bbc0898758a4a4c02ffc100d15dcc0a7998e2853fa1a0c26a80ebadade12954d47e77f51aebd8999084546f88c9478d4adcb7943b9e48471e3924f35b653fb6056a81a2cb33a186f3584d0ab55012bfc587e3435fabfea6609763b3318724c1564b836d9edf01c29f792b3f40dcb22f55388ad401c609d6149daf1301ee3935b7746992a41abbc9b29c3dd81e9de86482cb9f0ff169aa39679bf2836ccb7eab2460a1e85c4506acec3f0a61b2e43d4d506d1d977d0cd77b0edb710a84eab14619b41592e63d314b899ba48ae905cd9d951c7116a895cb67de69819b51a7435fdc2448624a528aec8f16dfc6365e77f87c3faa8acb34e25f2535f709c894d30f1510728d4d62067b8864e9d47a6f00f237cf16c353b4f4a5c148e3b7c4d3c863f908e3f70aa849c3738e544713c5a255a033e8cc3e90ccd7071693e32a04a6ab23fbf7542146bc497acad8788dd09bfbb454eea55c7a7b14e66b140f1bcd520d4f3c9029c01b4634e61ebddfa3a0c614b87cec56ce0df09e6ea0c26ef1fcc14402a112b625bc7781b44a16844406dabeeb0d6d5a5e26a9687e60c1e48bb0f01414eee48833b4a23e0e3c60392d07816b156408c91f6d92fbfb4d8bf6e5a10b32f03c7e58f5dab76d243008ba56a3f0858f1f27a94eae871f44f2943ff521c133e6c53aa00f97884480710d4ec2f6a773d4b9ff1765b05b4f736c4be0adacbb9d57323654c4bea69e0827d232ebd440ab70fb0c44922aa5ff4dd796d85fc4286d1f1d57a7e6126283e2b7f4306171c141fb21f82321ae52e7d8bc0b460bcfca4ee06eb3b4ea73f08d6252e2752df87126060fc731d9646f585a954f08d8a70b832d1ad9982171caf895cf3e7dcf1babb6ac4ed7c8848df81617fb699149e4a2abe1d0f4eda938f9348475dbe25ab85995f1d05159b1a9a46d1bea1dd46fd48039e8d75f8eb78254bf18da6105bf04fb5a453df0201cf19c346a57140311234bf302d4a912039f25e629bcda1a39c6ba01e3e8d0c39625805c467b7b3644fe7a98e1442178dcfd792a096491d0a358587008404c9150a3d42167dddec9c531246ec9e52cf58689a387021eae841f52e295f79b5bc5b1d6d4effa1c7fed429fa67ee25a308480e31a73809d8c57bd9443df12943cfebb84b97c21586aec81c70ddc9a1e8392ad9202ac398356ae70fb02806f40a0fbaf416ececb7bc0d25b7bd87f390d22dcbcfb5ceaa8faa9ccf184d880fceb9bccaf1592f2dfc1100e3ed123a956e58ad4a545fd620cba99d015949c9472ecc24717ee912abfcd2e816599318451eda9d94b65892f8e48d9596e251756190a48a971671b4df0ede7f2c149c19bc108116fb5d772e6c84c81b74518d73bd0c7238010f4bbda3dd2112d77444833039c3f8789a01a572ad215e8331746c1a251e0cd0a84d26c63d582f31305fc49d9b808fefb4745c96cbf3f04d261e927d0077089ecb76a2d4819815f7d6ca9ea40d03ec8bda7b71b016f41b4fe642be6cef30e5d7323a49abb18f1d6133b2409d47d240db6a1bc863d1e6f5ce1e83eec10c7993ff1693ca461af22413feef058fa8004b4a8189a683359c1bc87cf74c89846131865d1da681a2da7270569654e649a6e06f9a829911a837d6c344c133cf15d64cd34e05427766392dc0b26d8c263d1b2433243080ec75f4caed94275b2adba8bcab5fe3cf37d0602899a7ea1022b5e7eecbbc9a4dea451e36d34cd37dda729e7ebfebb966848afce526493c22cfed25cba2caef43544adb10fc7afedabcdd4fef01637330130cbaff53ae7785b526176b2893f0a3d7ed2c6670cffa4cbda311aadfe2d5b6be38adf21e41b35d94b3b64960d434a21746982cb88d0fe93fe5b24aae2a30b427fce56b22439f0ca2fd8c8ff4d414cbbd522136829676c228e06d9ab3df1e3a70265b9818555e354b4fee10a2d90debcdde35a4218e592be1ea23cb94921976298396b16d0a149f1093bef925199937790d857da4446e03cfcdf108ebcc4eee4646c03cda02570f8b5f9b55a2e1e59b8a6338fc3c4ec6890147c5191ecc3feacf0e44d8ddd6bd4a9e6901f03ee4cddec25df623fe5c68290a4f255fa9568812a839c4869466aa4ef56ed244d2d79570e127cb46746550d7a0a51a87f83df38a59205b70963f215f9236b0695e1eba58e3c6091c0570138704b2a9dc276f77f2c9520e5310958a031fd7f26dc0a447f1a53a0936068369b1317b5341a823b21658addc696cdd0ca239dd3d364f25b0ee845c9b1a213b38f13944020ac3030e5eab1db15988598f36b322f585d3b88abf0324b94923c76c97f8298496b372940a836af82970ebec7b694265cf665853b0a287db05190b6ea8829a9bb92b76278dc51ce6531b50ba4007bdbcd78da1e35b7a1c80b77822306c033ed049b209e3d6ddeec37233611bbfa12bd39b3eab68dd0cb977eeea336b4f5d5b1414b2a997c9bb9bbef84a6e211fc5b8c6e9f2369db5f32ff4627fcbe1ff98939f8c2a9c22586019d2e7b0a174bba7cf6b54010a848e9ed528a644b3367132eda396902642220f9b021c12a6e98c8893a4b6e871855e2e10ecbd08dd06038aacd36da70847ac39d1ef9ae03ee6d641ca1f615609bac2b8594a50a8f9290072343f90bd76fcbd9e4f95e48cbb5b9578b2b2584eb2a40df5a85092556152c3cab457404ce7ffffd42210eb07364911274cd67ae31a585d2fcfb84e21aec7061d4c76b90bd35d2d1888489a3032272523b1dcc7140c65a58f3bd93483b7bda44b0ea682be1db09020e227a0619a77e4011f8b2abec52c1314907bfbe0edce521ad2848da57210626cbfe842609652e722c1f19d866b8109ca1e74c88c1507e5cde9ea7f2075a19cbe6f2409f37ca4e66df65f3fbcaf01688cd10b61b241c1a61abee7cd5c278288e130d9068b747a9573bd7466152811e47b0a5ad174973c2f6458ea0bb442eb0101c2e165bf6def964f66fa959325d01d71de9b93016848f55d19dcac8f417029f61128bb3114df4add765e8108bf71e9dc0e6f2148a4edd5fc185475c9cccecf2955b8dfb36412981fb93c1b2db3704554b63abe4e7148d046d1d148aa70ffe99d91c8a6b9ed31e7a7a495fb02fc4f2d44ac7f6d7d67d67e452dc939572174cd87af6e709d07988eef4c82315863baa43d6a08834740a97332533bc78c2289dc9927d0b6b7deb2be3c2f9d598757797ffe1bb9eba07ed617efa66c7ea194093f17874f98342cb8e241b5e4b0de6266f86096aa5842d3f1b36cfaa770dc9bc5b67a123dd00046c2a87c2f3f3a1ffc6dad144c6d656d77634d5b968dde671f0be945bd31a3bc33342f81eaa6d2b16e7ea6e903f982455ebb0c0d5fda9a5d16149d76624f7c538125c09dc9b6240e4e0e71d30af8d96fc8a5dacf341998b0caa9068f90de2d44537d7e2a130042b4c0123c8e0e55c39f87d2c7de4b870971d8d2d500c694b6d4e3c7a72c76882ac6dc97b17103e83bf7051bd44c0a4ca1e1c968db897d9ccaa73f39284857583bc16605b29a80701180d08dd428a7e8ce8fdfcce22efe07a46ba1ad932a8b727a40dcf7984a2cfdd6dad138ec7e898cdbe0e30895141e86173e73f95898d0159f7106e4830fe34b4f624150f800d7ea2d6ed342043dac4fb27c6e101ac2f002aaaa830c35f2400d7010a2bfca748b5d6fa9f4436ac9be12e9612a45b7ca4d8281d6c2a4e303f8db07a04824477a76080f945e71c6c8090cf1cecf050b32649e0d570690ac40a00b22a4644fcf91f93616311f0342e3df76abd4b843e46d0d9d1938bb6707eba1c86945b43d7f4e5342f69205252685855dd3ddaee0e821df4eed13b86443bdcafa1f5554e19ae33f66b6d6f5566886ba32ae6339cb40a438ec28501d152ceb834a3ba796aa91f33f370bfeddbc762cf22db56b3e06fe0b9668c17112e51b45f636794796c01e01630578004270f289876eb6398440042edf4104b9f6d2a78640012453b9c091ed6e18dcc9bc7906d1f105fb055613c85631a16c9f11c4b468d7afc51b40ed9368d0b6f428f0199894c68c52b1bda72ba118a12d6651b71faee48137a98740477ee6aeab5f1ce255cb248d39793d53995efaa60aa9ece7fdb39d088b10b67fe6d4403d4830af4d01e4524e4683b72c91640eadb1c4059e7fe036ba73f8544c587060a77bfa1a8939fa6b1d13983000f2a62b3b119338f5a21dbea77ac3583612752bd1f54c90c70a85c6d1d92accf7aa347aec0df29b2bbd68778fe2b0837b4d13eee2ab17d96230c52502a3ee460630ee620ee35e0ebc4ee0d4057e3ed953a7a8edf7dd5165da815963ba3563cdb1ded62f98d99236370f7f524350589cab61e6d4d03a021f5f1b731666e19a6440208ccd6de028c74ca3c89665f68c803c8ee76477c177e49f16cbb30a80699230722733409f1880200a19740b628d37cbf6a9e7b731c59a30380b81d9a42a6511dadac4604f22997359b5c4e01bda7c2984022b0409c969e26049b4af5486ccacdaa31e054ed6073a2c0d65fc4530541334a4141cf8b407e728c0c4cf82b9a9f925ab529f236addaf9ae238cbdd9a287e87ca830af84bb5da17e56f86833d415bdab092ef2fe7dedb72c2e812759d03b5df6b65ae61aecb312215a7d8106c46065c7ade9e39c34f81f4216db001e3689722ff94ddf4fe2166114f85e5ef44bce965a847cbef0bff35e9f80fcaf6487014daef036b3ba35c3464d94c0afca6c96bcb95a80ae290f4606b2fc350c32187a92ba46ff5e361476de3bebc3e8d652795a54a2d1e67032218ce3f1c02563af8fd2eae1c411c1f49c9d15c5e8a30a04294fc283397d355b01cd2f6f17f7d7149f48f356035a95033f5f07e963884b30d01c893e0f9719ef6736723f725e9155f3ae68e84cbc8031a5a798dcc25206ffd5ab8cfe4d8eeb15ce73a68731f578245398dcf41f7673803b9efd1c4c985be5d1a3f1aeeb811b14272f7c6727cd3c293a7d2b21083164b3158ce08565f608bc6db52ddbd2a2f06eaa517e9491a2275bd95f3c2d6635c4a397f56922d1eeb9f8722844863d15d23219d63636ece86c73f899a7899f7b4ebc64859e4e274b5870fbe62a1fd9a64251b438ffe5262098ab829db12c5a13498553a34f6bacaf303aa48f8396022f4515019a05434e7823861ff69d57f3e088f31292029a73024f0f0b4090934b2945ff360ad3f1e81c287d13de9fe5cf69add4e8c5e4f15b106268b1a64ac5c18b9960305ee450f83c7b1095532514ea9606a0124775bd1967972b7f22bc04f125de2d3f3dedcfb7b16b46f4a0c752b43b93aecae55961ccbf95ed4a0d78c61c500811cb76fcabffeaf31c1a23ff4c119958e438c12e9b6a3d4a75a85f60ae5af6b79477e7a626b58374b48d54e81da58cae84a23036ef39eea86a9cc7b7eb9cdfef09d5194c485c797f46818e1e4d7a14a7077bb26424f3157cde2f235746218e73f5b55a4df6d74a7bcb3a4795e8b1f35fae4375ef521c2973e67520d839a8a89cf2232ddfe0c9d371efd981ede8c18c8d31864d46c3837f53d84ec344bc82918fb4ecd40be485069ae237ebde002b857cba8679d5443c89ad1093fba3588cb4ea324dd236c8c8e9cab0c95add08e86e6d011f261a2d4f436838d315d5e81055713961f5025630ad91c2a844b511ab15dda4e1adf379b1dde52f43309fd30018222cf9f9a9775957b85d3fa19651f3a8ecb7d05709f0487b696db291573522fc22cac2828334af3a886dc58311c105a9ee4c29441762cdae81a7d633d9d858b90fab8fdbcf239a57862cae9f1e5ff7e5acd2b6e1b22607ab4766744a0768772613fb94198dbfd389b718ef0b86503c683c9fa3b743cf655f98cf124aaf0443e556367faa28e70b2dae764eb0f14ffa200604b3b36386fc5bb9d0153631a0aa7eb212ef643dec87537690df6436905a94c89fc7242cbcb26cbd090996c5ca1445af274ab40d80ce67161bea89f240f25c9b0204db8a44cdd433fe7236a9a5c1b8ca744e0bc676f8ee4eb008b1aca1bc51c27b58d6b71eff38df7290ad52acd3a02ffff0c99ef3cfd25c4e0a663fd3d83c791b082463f53a56111443d81169b09f2654122cb92116f371b28e40473da31239a03cc28ef54eb8cc7d05d1f9da4af1a3274fd3b99ed9b17194280ce04c27c8849ae0e150944610315b508cdfaa6493ddd1e195e4c51fbab58aaa262c6d69ea8f7b1b9e6e7857e03f8d564642e206b9b01a7f2bb40ec03773d065898e9738877d3d2fffe6e1a229ff0e220dd6fa5d2ef429d49c0853cdf9cb0d03958c10b1efaeb0d966453611de69259423ddf7a53bcb82119183a1656c9f692eb5bc1971da783b1196e0640a18a27dac2d93656ce92b970220abd3856bad0e7282006f32d19d88e1fac250cfbeaafe3f952c68dd214d8b09a3b59931d4aa55ac3a248fdc8d9a92e25bcda5adeb6f54ff38cdb78676f12351442d20386944447c619c29cdaefb8d9796892ae536d08648fd3904b529cd0651b981a5e1bdbfef18fc48849a4070b38274bd1bbe6b4e118a9f9878765c0aad701a58885e40899ab5d29cfc8ec86b01b895499e176c47f058d4fc342ff64fed1fecafa4890de03756f30c8e57d86d840162d69d8fea7b0e8c51b61764a6c6ca4fa56347e92213b2d214a6f34892742b791db4c34a191cf25f5cb28a7d14922f1b84cb10b409e8edd6670240db2b4f340a6bcdad3afce6d706f62393eba7bf7fe30a8ec0fdc8ad40bbcd47f53940ae7085b53260277918ad65622ebf57e79cc4cfb3a16c5e65cea07b0bcd9e0899aa7ae21f0e9832fc205340ba004dbb5d4538bb543e04a71255189b3378f1035e39974e5c078fe148161f2600288eee63b14d7618c5dfeabce7bbc4690fd19d18d4c965573b3782dad18af05f81d604d8912516e834f3f930dc91bf10ba84c1e4a36ab93eee0db4e83fdc56eb8f9193096b5e42255d9dc25928272278d8df3bdc5077b1d3d4ee6120c1c93661ff13032b3d8eb5aec521a7ef66d37e40288b7f4065a0c0c5b456b0d717c39dad8eb4d72c0788e75b9f1b1c77b4ca472e2a5e0ed98b557716c26e33f909d666dbd160217a66afff42366395c4a9f09c71e749b29aadcded687f9c996561dd5f3646064f92c46791deabfbe5fd29e313a2a8baec342409f022119364320e21aaf400354dcb9caf145a3d6de2582f2720f118d30074e699dd2ec9263e497d58cfa56a038f1c39ff6376ffac372ead5239fcc90951c9c816d4107c7382507e43099188fd222d8095002e9a1d70be9f44c178a6a115977d198516e3422aa1c5173fb26973c04df0bb03a811b207121f5801eecc54b0373416e3a0eaa0b19c22d6380c0c25f0b40b71949fb5e9fcfe68a7165bf93155ed67d7f023275831069d2ca7218824e109b66e5583a44ab5a843727cbab8366eb72433ec3b641f4f7a82b362e4eb431291446511b5dfb3ad86a297bdec96f6c0d75fcd0223884e1a68962d52892b30499b224e3c0dded3b8eadd47674996de3784ede9ca793ac06236d6556e50fa7c11a135826896a383ba51dd6dc809f79a722a204d1d0720618de360430042764cd563dd5f7d9e5726a341185f662a9d1cb0dbd65ca452d170d74eb8c3917cc225aafab4d4ba7fdbb3ac7e64d0b54fd3981e4a7b35df58af4575ef203b9c7d68277b838f245dc7af8fde0ed8524fda437c0f747d860804fc1ab6bdcd1c132bb1e1a7df0cbe421522868ac9d66712bc5d231db05c366aae55e378d4212752d9ca15677fc3c3736313bbbb2b21bc088f10b4e48d4b999ce04021da6dd84bac383528b2b6a47da26d67d0322e56aa739037567d1a06d706d8ece5e9097902118f47ee1095efe96b1b03ada7ffbe09df78665fe5f94b30d841b95999cc718569b2bb8788dcb63e72ec40b4030eec183f46aa0ca839a5405fda1051aa57eaa99433a81a8158670d31a371e7606aef5e60c34f6ba1199dcebdafe93b03e37aa598dca3277ea36cfdb7694d794b9b8b9d5bf57d16877227e3c110ff90d291ca33c33bde18ef7bc5d2b20ff530061a5f134f219334bc89ca0a558579510819ae4d3a3ce7fe719534e309ff4cb04c37005ef55c08e78fc5624d3e175a296bc0144a91dcdd1a3621feb94ba455f40ce8864d4c846a47474686826df91d0cee307ea1753e5fe4035e3e45b0898ed12c2692270ac180e397c4e120e9fb800f40334b7fff194a5b108fac83c57d301b3f5b2912cb9bd712389f9dd713e0234bc2c9a436b1a6a6e0626725a64bfd4a418d411729f95a64c53c9e054f91b267a0325c606cb5599faa95c016297d86d74a8806f9fd7bd144b9b5f376975f8f2b7d44095b5d12cadff6aa7d7466251883cf06a5642a4a82c9d9c8d441c27be6e14abfb33b0e92cdf1f475adeddf1fc9324503479eaf7ec10cfa06219b2b69c0a6d27139c846d702e7074b9dda5af3850e54bb29c22db30963bae3a6a9d44c50468a64c7de9821296ddf9b0b83ff4f5235f3042eb3f57decfa9ca566bc29ef6303e0c3f24c1e3bc45912ec3b985755e80c63b1287ade9dc619ba7c8740a0b78d78280c3c9f571d0eacc80e9b506e0a836d4944514d6ccfaceebd0882f1635a7bb99d7a29c1a1c4f384bfec8a0a4ac05d0aa89714e8475d78a5441e5f2787fe152bdce06d1975eaa1539ab7ccf0899c0558a2ad2ed0cee394d9139eeabf507446eb6415412f4f8d62157764358a3cce771baf4004dc05abfc0db07237d24e0d861253044ee58a21b5024fa3a9f9e7d9e9902e096d8a8c22f0ee19930828bd15caf61868b03b159936649635a69b8fcf5812e3a444387822b1144b8dd1b98b05ea53139c58bf5868360a2642627b2ad8ebd5dff809bb7be44e152769a5b892a4cfe5fd88ac399031b503b40a661d8b47dba0bd09c184992d8390be41aa566e8265e56c82937c43a79dc45df88fbf144aa096bc613797943a88872c1f82e88cecd3fe4dc5a8b4db55ce7d24d57b44409d73a0693fcc8b9c549c0463e33e64bd55a655e83f4237bd6e915f8ee4f6a127289bec60e6b18eef0b45c12ca6500a34220dbf0198f857bf1471e339c27bef64f2e3dc8cc1d9c63d33338f71111694e7e13f258c698437f43e5ae4bc795f02282cf22b4af16183bc0f43747b9918943755bb06b5cf524e4172bb32d7246f2a53b771e3ab47ff9e449c3d12566b6eee0cba3e598c1e79bb2afec24259896b89810e3fec532b9291b837d281749a9d27c51ad280afac5a37b2c8a98b2fcdffadfb4f1cbd23704eeb6b91fcb1132ff2fa7b8245afbc76d569e4fb3a596c07adf0fe2fef2b8ca0a7fc86f48e573b15acdd97d1e33912f73e7d4a07050d0d1cd52e235693d7e2a9b0ed5e889108bf9d64c7eb6f20a021bce7eaa030625c012c81412a610683b1574420a3d4746661bb2b5fc8d82b08069947af7c90d14504f6df83401e5af8adb5a0d3eec16a9ee9037f55210fadac54edb481d8f0fb6602f0d20725ab5c797a43812c0402a0c8c6e688bc9609acdb8d415b3398da7e714b32dfa98fbc33abd53283cfd29dd31996b65e684d0dc8ee03444c221e3dffe683ccd98a8772ebbd01e75cce7b895f761a56370ca1edc0bf6814f182ec23b58fa977dc98c35119a8cf60749b935cd6aa483f0f4e98cd28a791e9526b29728ed70501fc5ffb9960b5836282c580da94772398d31a7183c02dff28881464eca390167c494d3a87fceab48d13749e6be88edda9a90415aea205e1b1017fd6b67ab2b225fd80467920afe0161d414ebee85f1978a01a3a4ebbeff70e01c061cb12fcbb718476234b6133a2965cf7abaefbee20208ddfc21c7cd24d574a436840a106de3d43d2d3f53df3ef6a394916551751c77f424df19be9d2c186e30cf81a952e31edb37de62b4fc34bbad918d050bfef3f5659610ea3d3fd4ce47a54797f47e6c85c40a675a5ebda43d01b4b407d2316e34ffc1a3139f718a7a18aeb8129522a6bc1d88d406970de56322d3441da12d8cf12aac53cbcd37b6052b47a2f4455b4bc9285f3029ebbfd8a6b4ed40557ef99717412dc34d1e4dd987510c3717c4dddc3c6f49348c6fd0e4eaa5a3b7580ad8adcf72a7b39f44765b39f321d86c6b35004ff3c716b4313ba20d67e033e1a2f8cf1329a899602d463053f17c1e2163b2311ab7fd055c51bbb37a1661f211d65ff083af0932301f84c1d59444ffd262831e8553b3fe12d14541a7e2622ccf4c9f8a09614c2d413c974c49aa59883201c7347b713479540ffc8571c511c14fcff81e5e05c658a5da87c66ade6fecb7070fe25102e9b49e2075e34877bf1d198cbb899c9611b0bbeca5d378762a9ccef0ee90333a329989da28e81db800d2e9b73d98e1e10be4c73e17a365e1c179bbb8b22f702de3070ef4a051b90b578e0d7b80faaaea11c5d94ae0306f2ac778f849a0ee5f01627fe0d180577415dc4be65da09dd2a93bcd1d83dbbd688d4bb41cd1f3935815e6b9464f2afd5919ea915fba33ab534c35a884a1e724f9613f1c5ab39850f0bad18b1daa4e19b4891f7b21d6510e279b6c506c672b47b19385c7d8e6cc786ff541c15675eeeeadd7a4d3f10c0fa38abd946ff129ca4c085363ed62e3edd428e6478f074371dd700493a8a0c9670af92bf4dd46e5aa3d6db3f3194b9103e6fd50d313fd4ad70aebefd27066b6777f516c2ef23abdd7cd51473267dd5ab961ef484b1af4ee67e73aecae18e50d387dad03991bd8655f6bd837967eb902de45fe01da53e864d1e680fadc5a754d387c2914129f9d5d49795909cf201ae2d0295d6b5d19865a31307957e940996e13bbd0ad6d31f50a8bbdd37815f623b51437362b5306aecd53ec1aebcb83312a6177184d3e3956495012fd157765cc1bd0e9211154acd4819ce3d9487185a36a4a908a688144af1f20151f6200fa9d63c643a7838dd021d20786befa7ff63b205552177349286dece49ddf0cb0207ed1d21c165264c25351597562b9c74656cd9d80eed4c75881b9b1b10a10e938103c6e9d806777661e9bbf61f21953644c76c02c5fd9d92513a6a5336f4d9a174bde5153477dd6deccf661d7ae4695680c15e4ecc2f006038875e5d29d6d1c91f3f9ed7dea24825ce074b490b9458d9fbacf70bc7793153fd6fd85451c1b57308bb41fcd4cc8509bf53f102fcb0d58d54b87eecf348d1646ac4051e6dc171482cac77fc0fe91a4dbaf64c437778ecbaaa8a53c99aaac87d4800cf6a548e5a27e5d8cbf4134eff685446f46e69523d3d448033ed5e97fa43050919755223a5d872d88c8af3d4e03064215ec047459ba3d580802f7885b3f56cc5c90cb5ee6177b71e8eea453311f5f497637418a163f73bc9a69cd2103927ce8e475d3e67c753ee108b3849b98ae530e2cab7e6b593482f7bfbaaf3b6e5510115825550687962e2d90b9ff68d17da7f79ec45e493004a26bd32b0843c7dde6cce0af0f3d505913014755fd6fb50a4ca158acb16af91e74f8d33f0597c4ca79f838be8f270276310fc28e899c3d25be29fe9b235315deddfdea7354039af90afe4642c335e916e81e377d216f6ad5def65dd29a6ebcf05ea879751d7828f052e113ab29aa8fce3a1881c5b51864f100c67c04f0d8457c8bb69a77c0af36e865c3aba3dc53b7ca7ec10274349413b53f9692d18278e30b6a6d1e514e1d32bf45b4220ceeb96c685499dfb1459c6c899a18211e6dfc0f58ba33f543ecb038f9aa94a65c60c17ed097c2aa388bf17ba84140da73cb432e689a55b4b9190c2aa4bf2fb135180b3ccaa2aa19e317d13dc738502b147533582fb1afc986d98edf90172c6a6a088063123ee2320f3e647a8a12e8d6e175738739fab8af54788bca30f18ae7fb935d7d4f052048fdb76a0a67829ddca489fca9a71ff51951c63d07aea82e0e9071d118b66f8da3478424be78f9f50b644a20b504e3baa5cd767620171705dd305b21f2afac3aeda075bbab23cedda1a25192da3d54d3e660d2d39d6a2b7c8e790a10efd29f27afb4d495cb20b4552007ce26428dc281f35513096763be2a4c3c7b18d551813d92e13f4712b86dff7dc5167b89ea936a734f5e4e61db12f409f5ec656244373fca5cb489c97c941340a9ca991ff5b9316be9f9d9d41f316a270194b6e025d3a9de7095f85bb72ee3c1aefc1a7dd2e705f93ff8c3af1a62a6d6b573611f7b9080fa0961326432897182134cfe34d469ca534261ac8f7a3c9c3f59028ec972a42eb3beeeab1e140c3cf6838719e17a845765aed27a24024def18fa349be6570ce9b30d1e9b3fae4c892ec9a37f2361890c05cddf4f1f64798937c8fd05b8d32239317d19a45ae70a998888eab044ac4594379c93c03fb7cafbf706be68e11e92cbde2b7e530958972c26b45730485c36bdea3fc497e6e06501999f63f8e8fbeb23d8195db9bbda1634ea3a1fdcc98b4d9fee0da72ea2f99a5fa93592762a369f76a1df41cc9d58652f03c99ebe8b1df5e6fe2e10940f792b155c76ad430ebf3036a639080181d80a46eef16542e57497b69f49eb6ed8c875026c998f490c16f73983bf2757a20a448cb43efe4731dd24b30360e475f2d9099f1560d8c69b639a9cc62985d1f5460e4b18acacc666b6546a0aa04724f8fb14a0528de91ce557adddf00ae463b7162ec6ea1da880fe10cd0bc6ff227deb51250a4e1b6b56f0efd4659e193558e00d9330b32455d581dc802035dbdb023fc4471469ef97b4ed3ac3e1d3d276676894374745ede0ccd69342fd6f8802dfc820d2193016dcd21a1b07f1277a5a649869b909c1e1c8ca4af9d9aab9d5a40889664d27e0b0dceaa93c96963f8fca256326c7c560d3469fbfbb4e98d662fe363b735649e84bbb096c51fbca3b67dec9470504ef8ff1cc2c6dec449cd48753daf898345bca5657c31810e14d0a7954b4081ba3373402a701578f3d14af16d52389f8a52d15f80d7117cd37e8e1b67a17047c67000f7e975f19c61ba5f157e7bf2c9ae497cb5d7e604431ba67374fde8b77217b12ada1cbd754d34585e6b82fa3b868232a97d0ff9cd3b7cfedfa6b92db94bc4c6dabbe9c72d27d5a7640b7b9fa1c2d42138df8d521168a7559da399fc69e993c577071f1aa39a03c821bf9f02676db186819c66c12340afa4b146766456e3dcbed2f4af3d68fa0184c832bf7f11d11375cb5669f307375e66709363eb6844505bc7ee16628ebfc0b6565d7fadd8482de5ef858c11cb6c50d82cf5b0bc151913b663b22adcc07ab611ab42b5ecf37a3bd30db8537a2a066569eea7f312fdc05de0c929cc382f2ca317d65133a1f8912ac822c272c7e7e85b08f139f40b6daf8eb7edf12cd767acf7066047955afddb65b1f3cfe5ac5bea26020b625723a156838ca74b582c673c940d55cb0111e0fb7cfed2d0732447dd0e76dce91093c7ae346868c2cbe507ffc43f10fd789aacd019828050b1562b5df58d677cc67f6e0656ca5de9295b9cadb7f79eb30d5ec45f29ca1c4e2d73e800193f47174efeb8ba97c3877aa169f69e9639f8bf3c7e5915d31978b957dcf6b3e7ee4025dd18e8d44092866deb4860d26393ce104d44d65f2caa9d3a25e74ae6ca5aadfdadae126b1245add6609630294eceaeb011644904bcdd54408d6eadb6be229c9315dd90e846c485e20a9df75cb014537fbc7e31961ca78255e79a52669a29e6f55a077b37287275a57ce6f1b0599b5d3e6d1113e5b848651131fec07e8c4ba19884f752332cbf2c147ba00c25e97686b44bb39d0902fe99b970d070abd226c6d56bca72ac3bb901cae20f11914a11c1804ebd425b835748281d3b1fda0254e3e75c548aafd580bf063e356cb4bdca86ef5f85cd3b2d9e66803d14de69751ae24680f4c8525ff03219322d21b1292222dd632b55a7644fb63a094fb82050455ce577af54f0592bc469954049ae8c61d2508c2235fd174d3fbe347c5995207f7adb171367a773471fb17eeb31d23c733b9eabf0af670eee8816afedd4621264f27e4af3b81af9281d1a88991a07f08ed7724868f3eb961ea416de58bd1affcc6c16968b3421b6de9982cb52612029fe18667b83ea6b88ec6c965a127a1dbd5d778b974b1c0ca5cfecb795d4f9dd62e91b47fcfbbb18eafbe348170aac538c62e3fcda094fef5cf5f826453a77ae7e2d3c938d845c2f2b3137623c309321d6762710f22c9a807e995f416e33283c0b8f3a0a60398e143d96cad8055d78b3f8c0bf504461d6cd6776ed61122d08e74fe1f8ffcb0b08fd4dfd57f2025efbccb123d7e113a201a87f5ae91b5ce7a7139037ab207aa34ed796116917179ca1183da4f81a74f6708e2805e3efb70ec96de8831dc37a592f9434c3679e8d59ed33719c980befb9fbfffef55bfaf2fec1b7a0c79d978bfb7f4135dca0001f09fda024e09330b6aaf0d5d0bf134a4c243703a7bb42faaff32442259257dea101e4e2c9113e615b8ec342d81842af9573ad5e3f7e6e1355c5651397ae663cf95be7b96c76b86060ca3fa9a53487544044e038034369ae6deaf42926123888e5bdc73d8cd5cfda43a3221ebb59c3763dd194a4086d93f1453832c297942c571f7253be55165aa936f0e37bce366cd5212e23b1d4000c3002bcdcfb24ae609598d15db9d9ef719c28f805a7dc7abb2640a10c30a882c7c0b9ea1d72958d575021d6c99fdc384104781d0fe6b7f8c4b353a207cb1046305c03265d191a1d59d1cd1c39f91f6820c56ae7255d5058169e5782c882a9362e6d487fd0e18c3bba66f646cda36396147fae8df38a7ee9bb6f02fa00eb9718c786286cd2c9950ac814a85cbd1f50281d70a3e546b797906f63bbaccc0852871a31fb2ccc2349199b8ab9ac3e9eaf671fdb9b63ba71f88358bfd16af6acf7c90f2102251b065b90c4f690f7f96fc2d6589a3ebd2b3584013f694b677a0c3fabaca3c03298cdb17e1a0f72bc218d60ff13e2b10072a95629e2d94ac63699a96d6600891d72a19c1d405345402b207fa236163b0af8999087decf86d54684ef6d94afce40ea86d532087a13c93e7ba0397ffbde3e4ac354b61a46f2c737d6265b4d88058c25047f4c4a1450133812257bf5a868bb494810357db3b70b47b74f4e58755f2798e602d456e464cc69887f2ed0a0ff936ff6bdf94d9a43d5b7f431a03240ed5363249ba7ad8166e36730562b483eff364bc2399a4515e5624e5e24d2fcc593235b9e0813f900916b2b79988d9a11834ae418b9a0abdee9642c62008185c25c2cb1fa29d7d0aaafc0ab5e54ae60b9b4bd9eb05825bc7ea7c211d0fb4550c004d6297ac1910a7d118822ccbadb7c81f8c9c8192649ff011ff6417705bb7cb339f8ce206471d5f15e54bdd5d202dd5f6d5804f95b2782ebad232d8ae7634f16e8b6c28f31594b8d6524e7ee985c5ce240d424959cfe38a6e893d509315e577d3c487bdad6cb5f51d57f270007acb301e6908b6bc89200fb21655554f3d71c44fec9e957553f69449f3fe505132b2c1e549081ad8c377efa832739cb1eef361eda52d7313bc35c18a3081efc7109cfe1663cc0b2db0ffd1780e36ceaf828acee88723f94394f99cd309eb46325dd75870bd1eddebee40fd04d64f528fb4ccda28ac1e4b635e7b7cc99f095665bc64cf05c88f519cde177599cc424b435a74d6490eecaa40a193404b2137edb04f77e09c53d52895643c3af1ae8a3cef2823601ec70873cb1bc11628d49b5038affff8b37452248cc50e4e2bb45de4923480dee83a5c4b17a334fb5272ff66637ca9f6d0bccfe7323db4de669fb9176ec86c8b3ffcc5153e9ca4e64e5449e5ea5a1d3e3161a4816ca2d3521be23ef59b40e10815e382a4ea016aad4134c25073d360c54afc03e430bac798ee8b32e84a0cb98691e80a80e32472e8c345302d384309f8d621c76a2c4f68667f9e4511ad977261d00a6896371323bd841dd67510ba303b63610bb6be2f33635e9c01f2d1e22a6cf86564eec79dd4877a705aa7bf44944862cf228478483b932076f3da4de1c15dc0b7f526f4a33a5f0e0945c48633b6a6c5ce67498c12ae21062c387455c689226ebba4e6af3e27c7ab3e54140e6aafc10a25e49f1134e896b9190266b1e1e57bf8c524ee0f6d383a109edb23894d52d1b20c4faa054b5e5d5ec342685ccacafbb8d567a89ee56a5ee4368c1c82f9ce0a99017b82e9e54d30a3c590db6ac04548c4820c76f7f843b199fed5ad199feac81d820b9e72298f8f63b74598920f4a4e51bcaff96d9454e381afc56b9761fc298c0650a8d38045cec8bf715bfc53aa8f1780c4d99f05f6c1e92c20d56b2be335bb5e8511593efaddde13a8cf29cd9d8374b7ed1d137dff7be685bb017a194ef95f29552b348d6761ab61eeb6005b4b5236f60bb3637528c2211744d595955b65dac66467cfbf2a5694f19f5f2ecb7f190301759278b905e4ea6b232591cae815448cc41557fd6100597c274dfd26d6f66f66ac6df629162dee958eb809a2c300bbf414ce80019e0850eb1801842020d6a175ab51b06a32296198ae233fcb2d07c1aa86aaa60f154a8e9ce4fdc02c4f0882af7b896b53999f38c2dd2048f12bc1aa42cb2c5203cfe0e7a5c50a160ed80f5ac7eedb4f88edc3be30bcc0dd52240654f0781fba5c377fa1cdee70a1cb052b8751e2358eb98c505005306a54ffedde9b9127dd8874559fd40a81dcf34476cbc27e4122f5244073034028ba5a8b96a6dcf9586c8e9b8c3a419e9f8b2d4345ad6877ca44812e32013c49e643fbf6984c513a0221914233329b73d22b254fa514aa0c8241c507a7ebc943e64473812dcfe14f8d5b5cc56ae3c77c427ed9f5a803c39455c08e608e38cf090f2f7c2941a619234e61c50f1c664cfb41a1565d7f6ff85980903fa4ddf5be35bf313d4ea03bd1fe29c8b7637c82c41733ccf5e48cb5556abd211b12556431cf8d47f6685ff36a8bf24cfa0012d9d52779ae7e5d2e6ac2fc4a19392a471c4dfe51e0b9eeeceac92e88d75ce1a8b693c6a181e556e93cbe90a0572cee4dfb94d0d91759709fd7ece8d48bdb8eb1185db36d174fc9ebecc6c1aa8edb948a872c4ea29a3c44c6f39702f2614ca3fc71012eab7e40634525947be658b177b2a98ab9762ea8f69e85e1e28cb9246611a13024221ace536348a5669de0c806a3318d2de877d3fcf42a94531a8c6454a462111839e6e30664b619b0aa05aea0945cd6abbf2230e524f0a6079ec7e759b2a1d442c3ad611899844a062ce820936991c85f84adc36c6d165e18de194d22e215257d1ba86d8ca2b9125785add05422c3219b45c2625d95603b5a3a605aacba5d3fc62f9ac9500fa22c6ca5bee42f959220c3714d9f5dbfeaa44c07b39bdb39da33e568932b1eefae800e98df96cb2328f61f34b1f46c2f667f2dc3f18f59fa8d3d2f63e3287bd9f3ba46aba915179679c6459444a602adb2eaedfedb3cef4d590d846b02c14f79dd3c2eff4238bf0d70ecd58abafdd1659578adaf8fa35d43cf8e8016d0e991935fa72f72c17f6ff0861f1e45f303979010f1f6c6194b8379e351b5e70a5c6a62d469692279f73e04b8b96ba9a10f05d980d60d826ea01b356462c894af658d42b3c25ede7baee29761218be9a20de0e037a226ddffdf913fc404d2bae995ead6cc7d2f83a1f8ba8e3b46342f8e5df703766f52f6f7b745ec5c90d91ebea1f755fd90b4f32ab28a1865d42f1579e4acba137525f70f4e8adc7a14d9aabf16e794bd3fdcb5d1af58a3d2d305a94d2cc1dd201cc327d64b69922b6bada492824f0d0b9d0a14d99a6e7571540158fd5a95f2ec8d31f166ce8b038c87487fc217fa7cae0acb5e28a4ca7adc059a0220c8bba285df7a3139619512e9b361f53c5121a990207d5a7575b45643cccd748461e15e4453e9bb8dd915956d61d20b741b681295e5acd501f6a8c8247e6309d7e2024204db198e35095bfeff0c3167106858c256ef01bdf9e285e46d292f92aebe41933588f01149d3f494656902019d898a3c8fa6257038f81d83bccf4527a0dc6a9cdec4884547308f2c64d2bcc8970f9033320c87ab24a8bba093a6e3cf324f2882f81512ddfdc49b21c8dd34ddcf7fa547994d3b56cfc84b88f17d102914c14281e0e386a81069d85dcc401f5dbed8c7e4fbae0999c77e66286ec3d0ccddd689a6c5e546e84d8900c557a0c7335e7b817c7f8d9f2bc14bd9162d547b28b678ef51936d985cf9e7913644423a295b599da36182c4997ee4b3f1700471d7157b8298b0a8fbb7681b610c852eb748c9e2c5d7ad5d1a288f16000279e17c78f8f57db2df8f91752fdee1707b7f13faeedbb9e326133851ea6bb70dc516dc1fab0ad9a657e650752609e09c1d13c7e24d26ffc4bd3998eba8c11d408f4952d541933ee348583f016a96b7e7ad355f28c90907b1c407b08b229cdcd42ffe71d6d49c648290102c895781653ba306b6fee7ec3a484d11e8ef016673692dddf757d596277ae5034f4c39aa483426f3644572a0aeac3dc6a38d4dc12abfa9acd83c74381474fe71bb6bbbaad68844dac056a5f042a2fb5237407956c8dd545fe1f5e0dcb025c61f2749231951b57855369fc402102545a134f59807acb4e63a839a90db1ccdd30387d032a065f91e65d5f851a181164c17836e4deb87bffd6bea75935bce76a6e1d5eed5d01b847c08d90c400f41a8fb5e3709bb473db53aa87ffca98e668c97011a504e0ad45d4aea48afb154d27b7fcbda025bdf7a01c8b5e6e7325431281a19189f3619086c615466ccaf42f536dfc85119cc0c3cb8888f65a3002e8e6dacb7484caa1db2c77b5dd7c5fac48d9646f93f7a9c8413c2d143b3db172acf4c86827a92f6f8cb3a15955d3c1518dc7b701378f3dc293440d5c9ac476efdaaafa12ecb68d53cb9fdf3855451fc1b4a847a428af15e16198bf789236799d1b4453f7dba198d98fe534d279d1177b7f03d49c4aaa096707bfbda5b231ba107f021ce51931fbabf2ddfb555fddb95a6c4ab3e3f69903ea2638f2b71ba3f0cdc9ba16b0747b8ba8412dac4dc19266defb9681be2cc19752754855247c09ed08ed4c63005aeb9ea8e068371407b9adc01e010a46940516e817551a89b42c902276dd2871073b4349e8ca85fcc07380f3657d01cc6941d2cb48413a01862787d5f43794f1552b516b420d80fc561d1c480cc8fc02242b7c890388f0666ae727ad1c9b10b6ed5dd17b46139b640bab2ca76b150e462c1c2df57e1ec618c13922e6abd8592a9fa0f72613d959e5c3a8fee8027e66e61b83c79b246f935e3e09f2348384964714adc16551898a80817f29e743548a1592129016c71bccf2199d5fa970795603b3b4fa5b065265bdcf39cb82349b37a827dc75fcb6e43f4b83ccae194de4d0107ef3099874ee91e334b06cbc40dc9f806ec702472d434894d46f86bf1c3d0dd536bde995f434252107f549fbe3878cb6c9f3137647ff532c2dc276e0bd0fec3ea8717a28983f5e507e70080847658eebe35333aa897f5d4de4f03dcdc0e721d61919a5ba23b6ba77144a5f04065e34c1cd4191ed92d76993e3dc1250e33367e37c37688c505aaa1d37b8065ab217a67446f3d36cdbc78ad92a778696d50e9bebf15f74da1d10e7cef9832ce3cf35a8901e9eebd691cf04f89a7f980cc2e513847c6258c93397240d97c1496a20935969d16ae8c3722f8ef7519671d1845291ff066044c7ef06594b067b0f28bef2a109b06ad0a0c632febf49c602b1b8e8b334738cf7492d63303cb271c037ee809109f01810f9313fe7e65364d6ff69c32b85b67ef1eef2cd0660de16b5ac6e0c263a35c2069d2477288f3b228418938d32edb105fc7bcc433552e9cc5e706a64541ece8278f61a2da3d80afc069b37ec0437db84a06daafccdebdacbe307c4de518bbf094e1045296c87bc9a8cc57af96b7a4a36ae26d9dc57c8da7ec61d877d991fb29db3198ab20a66c86375b2fbc7abe11eeeb30457c830399805d0145e4045104694a982ad1b97f1e461400b5fa8c64458366faf48d9dc940f8b3ca49912e63c9ab76feb09c077d819d5fa5f3570c23f8cb2a9b48fbc80ee5b5c152ce62a5f97ace12464980a43e9f9085a9bfcaec8b7c1662db28c495be37b51ac7b0511aa50da114006e3b3d03d02503d99e6161ce7f9fc8f3e374dbfe3a3d2f8a9b8ad3cb2cfa5884a10241dcf4f6b2703a65d46f1aa1896b68a3144c136e1be3a6c13f520b4b71e9c8f65209a9903f33b041b039e386d8afac419583163ad0a61df294e9bf071da7059b40485de55a69bf7bc44a69fafda0ffbc59cd16181d97ed338234ee3714c773847bd8b8097535b9974cdbbf8e63cc962fa1c5369d0012089a9d57bfd0a002998b53f46d73b9fe61917014fb87cc35848b9f10a88fe09954613525310520ae3db2e38194dac8871998f4e482e358b0d8b7dd57899ed158cf28374b49599fc49cf28caf10d156ae00ff7055e525c26f7e6b2f4e25732b4c056d74c15521c3f89c0a4c0a00ee20e9eebddb16b8460459b3639c7b3c8381520fc5452b66791122f6f479336fb7adfef574a3235e448be3e83bc21e6f020488e3f742d37093bcc7761e507d6a411219d90614684be8b1edc4b54d9ab3253b7a09f147760f47eb6be7157b88868388424ac0efe240ebbfd0b9e44d3e08399ae6479a7fff9cdcba41b582d7cf346057afdc1aa215afbef716ae783e3a3235c709dd0b1a34b9507db30aed39ba659ed9d88fb2547a387770e12030ca1a2a2ef92ebca2c2b3c81bc0fc24fe30dce9557f9925e3d9c8bbe9c4dfd1f91cf36682abe7232a676ef58bc1bb27fe939b789ac72e20bdc0c00fee0ae566ebe144e11edd7a31a6982ab6ae9d2a7fb1632873ffb7646bb13e9dadcba563e11a4e221f620420d03c5f95e4496ba605e144e29ab3ab757f61b7c33465943a0bcf32baef39f97eb7a7320e42dcafe0e69f65b3620c3e468aafae6746866c34848228d04a84a1ce8270bb122cc2ce021d27812ea6f6bd266370a0b014b82b303c57157477ef819bf78c41e7b82b664c8ecf9fb415770b2dd198230b65aac1d471112ffb6f67019b4371770d375ddd059fd24beb1985ec87d55175dd1ab2a170da5f86832fb6da90c8b57aca5c9a3767811b854c2c5f31be58065e9e68e5e94c201a4baf907c3d15177e40939c6719d5b680321a1d18f3c3fe3004a3e7388a7a116409ac076444f4a26556690d45c7143c721d9250a7abad4f60956c9290bcaebf6208d28038d9b916097357c8cc9d19ce9d0dcf1b9eab2a0412e876690e9e3d02880be03e9764cb13e5c4d9dfa6038430cb78e35f1c16a5ca63c1590b5b6eb332b244d45b98e0899149549f05b9d16b47bed786664920b2a40d31ebb62b5bd440da4cabdd9d699aea3dc6994c106b579aea2383b44d255188b6a1bef1430a17ab1b30b4a6f0417ae212f1f5bc60e0664faa181aedb1b0c34290952d1a0c0022d78a9ccad4310bada6881039e7c2e41f8630e2882aa10005bd5b6478adef2c00bf19fa552a679902fb15b7eff2d6bbc17d0a97abde1b2019ce4bf99dc2d6176842ae6f5786381237ad2d01f7b0052e76a3e5e733d67904c584f461a8ba7329af3ce14f7260e8a15dca324829997be3d357300c48f8c9c3fecb971f4bc24eb63a66aaba9c89e4593e775320b5b8cfa607638842930ba00cf4d48e8d460d27ba907ab53e6230a95b4af219613c362256167587b14a09ae0b771e72125e2312f450df3fea6c980f3046c67986795ab8a0f3ca03e21b2d3baa4bb5a2a248114709092905cc0df94900e4bec52216ac5a8da3cd9c025ba7227818c0e11b93f231dcad175fbd411b65082cde59cf55b6fbbccdf48f187beface87a089f2025d237bb430e6c3c7cc31a556bffa7ce8a162f23ec1bc63a3fcc4724ae7ad9141d366a8ee55e17ebd953741ce0497aea0e6c0dc889da0faccb4519990ed67fadbea4da12e2ffa0d64e23c711337d7ce4fd2edd10e8313114536a2d47bec39f1094d851a13d3533040c28b2082da0f0f649aa1aeee31ccf7a40c5bcaf9f2150619d92a7e5b4653cb5bef4cb62e4c7832a41f6dcf450d679d0d2a341e170f15128c5c625c36c23aad85c639bde0b769550bfbe73ee7c54dbc855f60bacd6c20abb0e3abb0c8fb96b44968f5300aeacf60475d829fd204d1b054aba4b1a8b049f385879224d50c2ba5214ac3bed540655c0ee963dab847cda8d1370cfc1068785f042416fc2f8430c94b19e3e30963a416757f1518f7b9db4b861075fc4c4ce3b1ac85049a7ead6cd607614d47b2d7195cb1e1750041e3de47c3dd5947c9011d7c1fc11cf3d1a5b1acf30d6516ba768f8e6d0171465eb5555f2ef17c39735d0cae2c7f2b1f99b713f243c82903049ed0e770aecbc69b82c0dcf94934c5a9e534cf87a4d0b52e01730c57d9a203198cf0ff9cc1596cdd2a16d414a368e7f11d2a5761915c306cea08336d035473cb24cc014a55e17bba55aecb12981cffc7be890b334cd61d910e18a34702535e1154a7721c8623e0b323cb4888ed678b8136dcb9e6189afbf50dd58ce76a778991b0be19a1d6efab8a38bb6e5180a287bf6dd6e0853acd1c62c2f7a745685b04c91e8a64818f0e89d826e5420a14bbf39be2661ff99cbbd85154e98ab165ea9ffbbffa7aa40a385fcdd270949123fe61951d3870b254d5b9d5e9271753b8b0be86db2271a3ecb1f6f9801685e0c6ca0b91f6554e8d1460264c7139854394a2f214a85346ca316539ebe26d5dd0e99752dfa9b7b59228afa3ea5a756331b38d75347a25e9f4229ed920e290eaf645f5910c86367356bfae8d33253adc3283ea85fecbb077776de51cc02c01929c101c2424e036256b440d09bee21bcd1da5abb73174318a1a89bc8e3e404ca3a044c297fc71654e6ff30cadfba0cedb315afba6a5a18f750209f0ddd592fadb8233f542438721f8c8be3635bcd0e9a00051b488de345ba3ba6a60ccde90bac11059133917f6755b21c4077773591eef6d7209928494c030de4b908535c410e540a6f50c35de4cea454b49cf1943ccf401fabc5654a8976b481adb2526a2d897728fb280d6c3c1eeafb210905c34817b35dbc236db8d83b504adc0d0b29d2fc8ac64ce666cfc7815f191027128d79e5c4ab1083dd1967f8b942002e5a535b884174bcb23db56fdc9e997407bb6f5350afa72dae940bc165a183c2d006a74d4ff5e5fa09d8ca1ee3a11481458158357af6f5bd737b7b6480f9ae325e0784d44707049c54a3699d96700fcde7d358a211ffb51c691d31ba7d2dcbd38efe83ffa7cc0ea45197818b1a49aa595995794b90ca238a3096f21a8212f4dd65fdf1d1a40ab14b7d77d727829eab43692b35e8b2794ddb8c21316fc86055be2cb12a2029a4baa5a9ce96bec2c17b64868f9e99bba678a01195e95d528c85030081c456c961472caddd9b73ec70358ab036060b739ec06d643de0d1657fc10e83f71800a7e0be445acb7a0be5a5293d45148a8dcd4f9950cd1ba3a4f1b3007871212436ed999516a6690b191c2aca8cd6991423f67144fc7d7077fe3a34fb0863f72a0067268c7700d20197066bb37a18d752d7ce0f50ce97e207551c7d685093b00aed1d57f0d96fb49fe137d8b1b98336e5f7c70f2e7001b1e70ed78575b7b6475a44cefabeb943ce7e0fb65d478a417200389247b6b23e59f90086c5c08c78842f05c7753e8085ca59b155f0ba06e5fdcc0a6c942f31afc7bb57d46f65c6f7d891f9bda2f9f7b315761aa72a73c499157a7ba54a62a713dfacb2a40de2ff50657ee93262d6b367d426e764fd69ccced6c5d8645a6803a12a99c0f62e49c3f422cdc6ea1be64702fa94f49ef9fb64d84e17911c92a971101f58457c7b510d7fd67e892814063072788cd61ab6ced6239a5c085f9702b8a760a7b6dcf5ce3b84d2c7de8eafb10567c7b9d484da2379ec848a61454eaa57c6e22f99ab5958e147a788ae0629090e65d37a7c2d570de038ba4dede94529e1beb83f835788cf65b1d2a370f449c0ee0ddc61534abad3131c1b33e5129929eae93ba9d7927d98e28f1b939e43504884d441bab2ffd70002c2d010f49b6573eb2dc60ade4961a0ab461b06fd46ce10e70b0e09b0a49c3817d3e62c4f74164e3deedfd941eebed12570f3d25892690a3ebe7d2103632734e713be6eca7295e40c017161312b39df11e1708477bff440250f979b87d9177a0903f5cf5c76bba1faf01f1a6fffa47d7df7e6bc2ca0e921f6be6a8588c59eeb0cefd7822d74e1bbb1e41d997c24573fdfec139065612d719ce9090a57c5a98cd4b75846181a8df038346c1bc079668bef8ce74523b9e355f4d554487bc1cd80ea7bbf7c9bd8b4bbde593f05418f3e19a2f63f4ea70d2cc9842f7c1366b171548ef897569087dc380d6a311d2dbba2552db51b1b8db88ca56ab9380dabd403e5ec1ee29aa8ae6bf85c03abc69497fa0737385b090609eaaa6b726c777c24bb092d6881939fac1bfeb8fe47c701a72ccf713a8cb6dc54c5afc1cef815ee9571a77e0ce706c8235adfddb3d4b7c795fccf2ec697886c4cf29cb0c079b2ce458dc2e375b9dd2d5473c813e118735010f5d4f0a5499fd2ca786e38a9752d6adac4d4908f72df7f2abdf0b13ec133529ef0eaa70f9eb4a8d8cb27949b86c2af04ceb0648c663fd899b279972070726d638158e395fa82fe23ab6227b750e887a2a5ee504702b60c6426039b370675e1b38e0bc2815a8621a020a4cfd7a7f0d70cc7bffb8372fadf67d0a9eda42f32112a13c3f7c16ffe57253cf5e0fefd1a1a7044632f1d1f47cfb5e645812a8362e218b8a6138e8bb52bfe6fcbc23f845768b964d573776b3ea19070e804990d21ecd611e44d3275e8b0f820152a1fc9399335012ec150d81d9e7db8bb0c897bf2cc0c34cfc63db10600f8ddce7f9512011818f2208036e2ae2286266aefd77d8b5f2235d226104d241c3224589302e101aef895a321b9ccc0e56c0668c5b0920202b088d74cd918c3f5b3404f4cddcd6ba0cb836068fcd0a66a55eaf3f45f18b6385224a000e660a5739b92b045552308d4e33bf6d78cfc67bce0112830e776744f8d34e29b09526fd0611af613b07b7440dd292ca4a5b7ba808624e77971baf994cbac0d1d74300d8cb173317ff1d6b52e6c6f90d04e0a25b78f3fb2ae110c7a3f4952968c31145fdc20d6c3af6b9cac2d60a25441e9c935d970ad139f77c30b58505a137adf93d36e355a4b0623a5ce32487feb4df7af161a5024cd91df15cc89c9d19bdf460cd4b04403ea08d0e27ceb43f403a544471054703754493f911b406e6f6aed0c1f7242e560355c755a06acffad001a4a6b466babd15a90a10182c1a84c398bf0cdf383b3181f6156ee371153aa063e806cca5a97fd9a88d538e0957fc5f0971b47884784a04d31cb94604b1cd0ff79f12b398ed75ee25025c060165c3ac8b681d1e3bb98412e92f5197bf9ccc60e5702b5f8b5707404e22b1b0b74533eea9e9ec61cbef6bfd454b445d61b0a9bccfe2da1cf846eb416ca0b51722aefcd089434057ac75ad0b488ef78042d04cec721709a3bd04545ad20b42081c534f016b95d213948bd8e73709d87aef24960ba745d7eeede657cb70ed1e2f469d6c2c0c47bbcf0c844eb339c23b5b0c47e7d34d09243b36dc00c219f5c802c82c2490b30de3c326bbc9e45934b4216e8554066e404ba6b89d7bec0fb5f6ccbb20d387f714acd4a17018ba9910d8a3c716c3d16bbc213d80539ada68bcec71359cf74b1a38d3030f6a33989b6110e37b46b593a417c8c77ad0fbe1b9f5b71fb3b8a7a5bed3198fb00aa4271d673156adfb34a8edff46d5a1ccba9469cee36254511609271169b03f3b3c86e36b7afee6af6a6fba320e9f7dbb01629116467317c4d22371c337fd4bd9f369c255955a8d025ec3714ff4dc38b0ab8738d7461b6c60fa5024a6dfae8542037f84d9fdd2b92b78aab98ca34d1c81ff47c056b166c14d87a4c4d2c12d0c7232a957a5f80713c8bd79f0bbe59837c8137ceaa9f20d0ecfb34acae6e8a829ca4700788ec921a242a8123b9eb09bf1b03c4e1dc65d7054ed4f148f9755672e51442200d6ac3641aac04daac1a8b55ca204e55f0d22ae54ccf102fe28c227d527d71ac480a629e148afbf1e2d12acafd006dcffb8c7d0171986789794fadb2b78c22362508b0bcc200acc84283d6e18b4ba91238a011bed307d5b8d25a03d7267082845be891468bdd8df66872a1aa64cfac5af1ce6b72f9c68634b8fd2e01fc137540555269acbd8525c061db9ededf33302fb3d145b7a11147e9333e353625ee2ab4cc560ed87494ccbd4b1da83fe6e1848fdf4e21acec7404b35824ef670966db725b584dba1b67588f2e211d4ba8cd9e34e6e0926ba210d49d5f7d2ae6f60410ac422ed9d8369049dfeafad2799dbe722b01c876142bdf4b8fde8f737a1ead29c7cf1fbd623ed19f50a44f6403e646180982099d4dd0535595246b5381d3227f52fc4f0a89c847e12fa10f2a16c1cdfec6af7f7f956e4d99886e1bbf72b64537a29301b18ca2928d417f22931c24ab65d0106e05d5485662354c2a93b945d23a73262b0eb20030158a092de30358e3ddfd43437503c1e257b24e5e2b70ec44033135687d2c497caee4195644837c675c6b0d5eacb2197051cb0bf8d0dbb76f9c7c3f798a6bfc0cbc9ceba5bf5fffc440ff2c6ddb54615cd5f037369e1ed0213386c7408119eb9a61fa877a2be5661d24f31b715483abb7b9717f687f07578818082ac58aa5bc1df2f1dc90a5aa061a9506242c837a7a01411a1a20be1cd2584d5f0413d33b7572325fd6745ffeeafe2c4b3fa68466c724d2060e201ae093f08b2f52ea7a5d960ff8ac469e6629835b5d36ac15a58f1293574ee787414ec7e1f121b40f518c499f5a3f4d767da87f58d01f1231425fe6bbf259248b789c6243ebaed7a5752a45381505faf8294df3d61757d7405cb2d15e4183a0176c3868f085257099f0eedf096105c7de7f7bd26f7834b5c3cdbde94abad7c364bf90f3ab8aec5ec9daeb6689e46ed3a3b425e53584cc095719d88f815e523009cda872fedad824e112d76fd34dc225d11338ac24300d03b60ef65f8416aae2f8ee3d4b997b1cc7856b77cd63f1f1214b2902076a40c34adf174a1766b0de7a06c86c4a2514a839c7a6eb5043421a607666aa7252d4cf8a5bffa8e833412230ce7da0cc3cdd0194d64b4526e88912a281e03894eed5a83d42caf95442ff35ea9496e9d3478243b938bc3937f249c12c35938441d15a7ef8cc31ef8a087bcfedc27970c6c2477bcc307ddd189203e86028b3a125bf6ee2252a2f7cbf94187f14d659a2a26a95756b8104fa28294f427ff530a89df018721b2c85e0a29fbfd9f5103cfea11b874b38151ff50526f176938c2785603f83dd1ac86988e4595222483ebe8d6ced29aa8de7ed3487c02c6953ac795b111bf54b95df2d476e30bc44c4ee334d2ab790d547445e4887152bbd95696b273eceb73cabcf4dad45075562acd26375049f04b7bfe712539e37f967226c51abf412be6fd560881c0023492d81b98f56dd3418d9915ab067af77bf751badfab53bbc9de8b93e956dca437f0b93981f6ace8eff13783453911d24f3c124e85619d8e49fc4f6eb1a6c3a4f2ea9fafa1b816716b1504deea0b73ae66560ed82f9914fe168cec92b5d899344e4e2fc380a7353f2b5a6fcf72286d28193b5962ae6fa4a4aacb4f582c03e10dcfa715a3025a162d1fd826babfe4bda86596bc5468df974276a1d636808e180e1b3eb66b9030f9a08d9236b2c1f9d405baeae7954ff9fa1e0ea528092c10a56c8f597f62eaf957382fbe0213dd4879ff84ad849cdad745be2805cea856ca8e21a15c474d127f10185eff4f4a6e2bf4bcac5f24e06155c898604c91cde334a3b30ee63e25d1344bf5c4214d1a8303ad4753392e0752765f2db054f9edd604eea70495d11f36c3e284e8f07fbe9dc38d039a4a96b56755bc2f6f0e36e70180a2269a71c5364dd1534e26e1fd8d5483a32b38491c5063825cc142dad5ac4e0d5c930cb06677989166fe0a33633a6b8e40e4a7914bbdc04cd912481bb608105cd13956fd1ea1faf3a0dd92bd2f4c3bd81be5c24574c6029f555a6f660d9402391c4b969e69bcbb677d0a5e084cd431783a0266589cdd0604b8aeebed54434d5d3d70a643c5c9d88f4b854563f8e3d6d3e8b50bd5508cc4ad393b4ece71270e2a11a01488670fd48c557f5b61157a9f90b521f6d2838e9f0bb44454499db3ba27041d0454bfa0047832f61c6806199d9726c211bb4f386d1d7a38d02b5aa887725f2936d8d1e1b7f0f2dbc0294f236dd0d44a6b33426ba4f0e1b92cd6c518b19262f78b25bb0c6028fc6450e8cd846cf2481c8bf8b440ff127ba918a8e0895b33d271566dc58d6fd7721e174921b35aafdd2ad6dea5684a31c86db0f5ce9508a56ceb13737414cabc9f15139080624d3f995e25dfa890613bc982e178b71ec3f7f39baf4df65e444c69e1ccdc1495d573be6045aa9a47b2bb5b67a210b8d91216813ccc36a5c5ace1c2d6696f21027122eab537dc295d21eb161f811b2e511431045e466909c43105d7c223adbb74be0dad6368e2fdc1d9b383df2f450201dc1c1842a84c91250aa4c0ec821768ccfc8d8e018c861fdf46d74461caab515d3e63591f5336e76123959a0d6c48269e8989192aacd514981775c7d9d8fbd4b42d03b1f3b13daf2fa25d63b1ae020fc09eb5b648526320653ab9a6b8794d124dba20d8d06df5bcb615529e40ce0d4b0f5fa62a0c2d14ebd148f223e45dfad7159068578e13ec45ac51458f032436d5342ef6eeccba103554e9085670edfe027253f7a017e38b8c3cec988bd9aa3a0a18b4217b8515dd3c699cda31a437afb13bc8c055b92665a48efd29f2eba7ceadfb642a928db4db2f0acf05bf3405bfee72357eb49a1a9791373bd84c5f632ced8d5ee0ef5e2df455998ccfea819dd982dc33129e2c6ffb89ff8a8a63e173c2b7138e4146891b0c82f393432d5cd031b12eecbc57954310f8d373478385b5bc4080b1e2966e341dac8abc895275c86a5de90ceebe2c34bb1fbc858d7ac70b16f8e3b8b99dfe4fd86d60d55ce4b5a10ebbc3cebf9869aab1abc1661040ededae4159801a01956e4e210ee751f9890718b79f64ca5f839b5d489fedb0c3131fdcaed18f050a1a143d2e4ffaadfb9857fe8da83c18135e5261d5508688b3c3f21f6eaad859564fe59265935d05c7a1e7e9bf0deca91157c5d96cbdb596d9940c7734440d6813bb1ecb54f39b02e38e915a75e8d3aaab343f2a778b6651be200f3419a44e0ee7fa805231ca28dd3463ff411ea4b0483dc049819a91c3d2e3192649439a121fbd6fbbf31207da371902dc26bc28a4792aeec75a2e1c3986f11f365f079750eb5cc9c5d250b9b5632765e7719261b26da76722715c9e3478e07c4501c27d12b76862c94d42e43effb51ec4ef4939f30a493f02cbce58967c877cd12edad5a28425d03ad779bd3345882a7d5f41cd014ec4147ff3ff51588798867b0ae90de81df0e0124adb19055018bc9db276c601b0ee97dde0e99aab7e5ea46c9437b2b2b2add4d7eddaaacb58fc5ca6fbf5776029aaa30755eb7bf3d745c2c2f7c1a1ef9de4a5c6840934d6ce6538471836bc9abe0f1218e73c8668437caee96ffed455b8c891caec5ca425c363b6e2b297591f6dfcf42104f38479817a296d91b9594bd1502dd6768b45881863a0f5dc2efc864a36796d0298180590ba1b047af29cf2b9dd3f942d8f967a406373556a80db0281f6e17cf7beb91e9ed21385bdc5691bbd6ea044f183da33b81a00e303e8b01b344d25eb83489d99f5cf090db599cef25392afe3b8d36dd19c22ecda50d41d4ab47bfbf52c9089ea3dfb770da17006120269df06711417551e1dc61da9153959f64f25bc785f61ae96266d1eab23dbf3d81171f76e846941156e815f67616b492c4b526b01694dafc7f42a964461b915665e1d67577c54170756f16a24d13911005e13a5e37d6fb7ee0e01d3a0179959d18125e1bc5acbaceda7d0c9cf7b218e35726a5b22738ec9b58b2b9164509c42fff5422ed01967c43dff0540486ad9587d52c5c53437f6e24b7ab4749008ab6539bc3e3599af24e9fd09f32988e1b0801bfac46541fe9b7bf2c5933d81124b0f38339bee302313332cfd615905716ce2cbd4778a098188af0c6eb6c0a0f3f8352f580317a38a274da4e053468a768f4592a6ada9e338e20d0bf9ebdd148b8461265d5b8e450cd1e241fc73630a5e817f721d5c270c726218ff0484186096e325d198d395d5f8498c13465c7b033bcfe0e6da5ba592ee99ee8b1528f2bf1aac622ad0beaee3de6ba3f67e04506e7b3b67875e8be356ca01dd027c06e6407bf3770dce1bcd1430b93e601859b50aeab7d1e21826291cdbace7ea419639fd64cc786c5c03f629a8712134f307353660167177f6f929b3750ada37be192dff74fce9113f044e8ec5cf994cc6f15adab64e5461ceca2400f235246d303f2272b07f6334a1cac58e29013476d46b7d2919b91f669bc4907b6d5c48c5953ca128132a5213880f53fe72a267649706a02b726586fd0c8942ef47c49accd6e27e74096c10cb486f62d43d52a11304ea4a56f02d8376d38ecda9b82798991debbf136e0c4eecee214aebc44c96d3c6aed4e0baf52026dcc2f651e014b64e2e1292a8926d24d988d386a9b2d765e0032adfa6bd0d3b5b7066af888afd040749243f3414262948189312ba889241911d425824ed2df79b39e9111b6e245010c3d32c01220cdfab4184c9aa62a8f90d3385d00609b7916dfd507aff82d3a3e8161a39b203624ab5038011079d8b88f96b1b52052653854080c99bc71884bffb67ccda819a39dbfe44442716c5f15335f2a7133bca065044d5e8e3589f5e14809403d64f93fff117a9bf2ea6a1b4d7734c0e6dfe0671054475998807bc897b0242ffd7c4e3a425c8c31eec4a93f27f669955e2076e8da8a98cb37eb0f9053de17fb84b363712390056c253952156e7078ef03928c625f9a944678d339e75a636d3ab3e78113a6bbb73ec99c0cbc3f099483277100d7ed6658fe1b53febd95c7913b36fe248b06a55eae7b027d79a440c6a2bf63395530e6ccf38bd1d07cc15311c86acddc854c784a7b547d82922c84df16f2c99b396a8ed5270624d534ba7da0f976d40e8e1a752f362a88ba476e7d20e2e6d8be47bdf20ed892f840d2a42e66a666972767ea18b40776c94b386d506b2c982b60e80a8776cd83fcb95d6f2f2de7683aa177c38b8677008e2d8a52c4a12b951d76a28632292a12c5adf8a1a245361f14e2a215426038070d92ef2ceaa2081ac9ae0fcde3e00b724e3b5825c8dc1b5ef875475fda4e41026bb062acd81523dd28af20d7b360c385bc86252b2f64f76f82226ac5ca903c8ee12506be27250eb23771dbd891e59e5d3137c58b1866d50bde9c5edfffa26ddda3154b86f4acfac91b249cfbf44bbe4d4c8868009ced7a63cd57ee901b76d592ac1b3d923726f8aa7318e296bccc7c1d18147486817b636ab4b1d02d42af7d5b596bb9bcf251b75aed0d4e64357370784af47055e612d4cd3bceb13f3aa78bb9198d1be16cb5e38dacee772001a5ebacdb0765dd07d701ad9607ae661d5328e96327ec6aecbe3604ad635897de51b6a36a1a66fef36ec0fbf62f87d6ba1b38ac833d5be6cef9d0aa62f56b4b841f9cf6c6dcc0be631a324f4807f3ba30c822ae914baaf7fe30566aca40fa6726fd8b83b11908dc044fb747627b9ec16d7065a0e2bc65a4febf0ea75ac672a466f7946c71872d6319d3ff7a08dadb032439c2ed261534643510bd83f576cf9d43210f18a6c332ce7453e8937d13cb4a5e0cb30ab56f7f28264689cc453fc12a246000b85b5d15df294ccc6e2465416cba93440a7ec90fde1b276b7bd6d51afbf8900baa2825cd4fcb30a3d9ea074775e984e1309f3c02121bef6a92ed1fdde394c97b015c5f71c06a9034a2a1849760d8c9cfc15293c6564336512fa67828370322f875b075cf94910c6a3708cb36476e60f8ac00efd9415396e9f859143de557d3e7a01419e1249c786c431faa3383235802311e2bcd71107a6d57cdd4139da417160f30b11f585673f4bb3dcd085bdb75d4b714ccc9417a7890283cffe2ae4adfd00865a3e4783e344a17d56930d668ad9a7c87e62db7c18d4d4b2bcb9eab9aa20035c06dc1902885d62064385ef2caa44ed540b9c13681d67ca675954db0c9d78baf7e0cdc42f8c38bc41c97a38719ba1a7009c54cfdbeb29583f2118c3113997ee3075e72fdf9eb5211cf1f0e374ee7f2ada21cb1b78c4bc1c993bf2e6ed87f702ca53d7e6bfaa61a64d0e051cfa656857b95fa6eb3bf0c66b5c7e5f0a2f9c7f318d32a4102d457c19a5e78be85a89559cb7023f8402f62cc1fcb1ed5bb29d4c0f2272cc7213df4f3f47ee1acf0bc5a02da3802fc48810bca3b3f2b09f347910569029b9f18d7b9517322b8a990cae3d81913da96433749cc218d36c300e373ee2a6603204f271bdab04062c9adb042c2838647d7e73d137d84a214a13b3ad7423bf68450842f32bef758e9e372dd602eb85b8c60607165cb0c982e855242fb21ea439ecd49216a9a029a6384f4738e64b9235680f8c6f4d327a3f7f8520db438db024d41f590072e3ababb1ff7edbd538fff9c5c956ccb2c29d95f1885c14070c241601454449ea1b2bf345e9854c1fd708ae51f3a8107bd818a74cb9eda20697b640fe45fc353a1d533915ad559cead8fdc1ceda4cd352fd2a48704f8de33e4184c6b60b6b4a071cc9233079e2e9f8fe6dba33c9e0add14b1f94271577e4aa0b2187c9cddee0a60d914b41986ee3f18ac6a952c9e2b6012e84ef2c9af59649734b6c245b020bcf7e83cba8788e0f1e6a724e341026ccef5a3697238c06f2fc94f22ec7985a69fc8fd82de88a4ac8b37b62ea2d140dc0c53757df78569cc0324006d700befccee29b6e78426b477aceee50a83f02aaaf64665665aad9b2fe0ff39f6dd813783a9bcf1f227a28e9241360d0a9c29a2e14b855cf31c51016993ed7cdcd640a3fec193e30c544661ea3fd681f70a653c5d81362df99193b657737a82d0cb0ec19c391b2c20a288c804223b3a268bdc55367e556cf85fb10198e78c15c153906010a225d27fa473797e1a1f4b0ee68809ec6a1c4eba6e8c0c7c014fdb78168d1af2ef90f5268f7509bed7bafb90a2fbe41831ed9932df20d62f360b8885f1754dabbcfc980633e9e23e3cb712cb6a9f92832fbdb75ee423d6f1898f9f0640ffc40adf165d6f969bbad0d8911faaba1cdd300fcec72bb7131f135a36a39b67a3daec34498bca211b548dab9db23197c11300168fa170ce718593b0691a9b3f0557669df727d0980b38dbab63c993c9a2788b5017f00534190bf5dfc2a0f18a1ccad7bcb291b405e90d90db88be4f7e3c266ab98c11ba01cbf11980b9d1c4cb4b03010d373bcb5bcb290e0f56ba71e244919f09cb153df502572cc954b31b3f319bfbcf8bcdb566e468adc6ddf89495bed2877776663a31bdfbda5c4668bbf414bf2f5486b8f75db4b02925b717f65af5341f6740eb212e2d54fed86b7cd293fcfa92809020259f6e68ea883b89a7b476851fb95e0c0c1b605e7516bee29937bd0873005003a7bbb56225ce7da4fe90a1bfb1a069c384f6e510622f145b614df6e15701583344aabcbbf6cf9d832f8a9fb5513dfbbb64e8902808856dc17df70f11cd74c36e46d47b8df7d9c3e2cc916a77848bad6e290fc6a8b348c285620add47333c1f59a0f6a338aea0d2dfb4bbbe02a3b0ddd6e1053e784e7541a9dc19c7b97d9cfb4f41a19a403ce232f5460525ec0256e103f6f702ff7bbd9f529a3c59ebd0f905b2a9dbf5293f050f5976ef135cba4de1a42713c5c6aec4441819d7e3fb0717571199ae08f7f91f8b9968ff699b0e90faa5ea5ab8fe8579eada317476022f45872649c1a86c19c3ef42459ede9ea9c438a7b0866ddfcde2407f6c709a74edfbf110e50716ebfa0e903f02a30c993d70b31af3def003a7014c54c7db404b73f1d880e01e180945043c2beac12f8b8af82ef52324b01f6f452cc456018fab75199deeb53f4a65c4d270934c16f84d437a1ba85ae55a0feacaa031c81743588ff9ef164c6c96feab5d52ea42aa23a06e79956148a4897c9cc3c5c055de19881ca0d230e771142c6e0850292bf31df906866e7d8a5afb229026e3ea45a9931ef06107ec8b0d6250b75a1a69463fa30f68f6a130014940c8b139aebefa139d91f9c76f46440442a8e65526faab82120624917e9d790e871aa21023a3d623ea434cbfe487d6d119cce227dbca188bd848ce771cdb59b62f25c7c0ec6c9adb8572fa270f4b4a627ab5d01223c177da44334833cc637577bc89de6b2378cc72a343502fd903219d1a35f5aa043cd57cb1d587ce8938bc766ce6309aac05a51cbdd00cb205135d81ba899f6cba6886ee85cb1418c2a13bcab65f99d8b0d46bde0d90e802b0bd55cba61a641b50aba7d84532fcb7cf08aea7565157f8c65ac15c5f7b5cb2aafcf190b11b832eba11f2ffda598c5f55e1ddd1aa8e5d50e1f11fd56ccb66c593ab0bf558a24b068a6e2496b817745aee4b3c91531f538accd0d2433d5a0449df8961c6d177da0b7c7bd478170c3bb8f5142d3519f5d31c007b956faf9e2d0d0db876243513e41ad763e26c2e0f83027a6416fa3f427dc18a357dad900a57c09fea4ea232fe1580dc784d97b5d13b2eec2601679451f44db6f1ec2da8952e31f7cc25d1f619fa113333f73dc70b7f1f66026f0a22b4d15505b10a5106e52d375c8d4627f393e2585d7a49dfd1da35d532e777f68d3f253867f878fb0970d09327a9a664a1adf79305bf940d82fce414ac8df209f9d082a65dae34697c5895f035016c6b13daebbc64d85e1fe7baaf4ed89d363e7899cdb6147fe655510529a257b2496bd6749b083b23e864ef3ef9a94dd8d18166c14531555bb0a230d2fb07c10cefc4578338d47aa3eafd21f32b431669ab9b3c72518f867efd0c514a286cfb62ec4c61acb62512136190657f7eae53a9b4de548ce5a1b59e7badc9fd768d56a5d1aa04a85179ce472a15d8cf5580aaabf48cfb0f74f1dd44cf7058d32b40ad66911405ec54413f1e0d58da83ba8d7fefd5b657ea0899a31dbfedd176467ded71cb35fb5d6eac9c03ae78b46fe743e00707234bb968db6adffb9eaa20dd692667c2bb72dd8e2ee06aa317f5b4b687ba4fe086015b8d9b0226d1848fd7b3e78b171dfb0450e5783bebd8a00dee413f4b29c731f3d49988d35ebe7efe899d712c603c8625f4b2c9f17fa255ad91ef45345d358011eb82f98d9ad5592c2a0563a70b7aef64ca2f28871208f7f62c27220dcc2e78d464a93ff3cf0688350faaff74637e6076af816763b5e0b71017fb1cd9b2d1eb3e1a4b310b51f17f3710ca3c7be7e8f302a137f66056c021733b4e38ca0cf61270f2af1bfc3b342191d4f9c4d0f202875f1d36b0326a3ac47b6399e6a942541a1b3df6ab5bd6337418d3972ce4b5e39f8b382c4cc0253968d92f8c5ccc935ca44a57222bde4488b1f8fee6442ea7243060d086dc31a1d2e88763f98590ca005ad61b4a635e3d3f361039ee947505d14bf7dadd0bf2346e5d8dcf9bc7a3727154e1f38ba7c5dd348a1f07429de856227f79a1ea4fd6cf33a0fdd88e005fea9ac621dcd3a3d52860f1d3c94dbbefa028aea4d5e9b06df313e3d6bfec6339ee05aa94927999409ae611b78a7cf72369894d1c36bbb0ceb04aaad46c1fc1a008fc1bed083b33e5a9b03eb22e62ad9e6274c496473f71a4cd92490b6def2638e32af2e4f2ce41bc712d30c070ba7bc8f2c8b93656ecbf01269d9f15ad8859c00952a97bba439f5588e2c3be7cb326b3eacb19c978f2e83c06d36875c9bccc04c146510bf99b0bc7a4f2271782891d41e9e70fafc5413ec7198a60385e8ad9a6ef5bb2b1a006d29a0e3059776b2ba0c0d90460ca316747149b8a0b4b872bec1a2c18b9c387e8c1de28e410eb0ab8fc8dd6d7dd0f8aea6682c6ccf3377d2b057c116301c74be2cc50d7ce29cba96e504fec56eea04707442029de4168e51e3602c78b1656aa43d386188641ba983397bd79fab9c5fde886146bbcb08b1d42968ef2cbc890cdbfc0d427e38dbc545337e5eb815bc175c2c58d51696ac46e132c3a71c0d216bd6ad35603be52935706a49998dd592fcd0f7ed2e4ac9a10778a65b4d9254ae16c951c2f75a6c60d2346705b4fd29770c7216584029b761ddb92d61acd3c5cfa195e7193e6faa5856c34e943e00d591d62733183a2f40a974075cc47cbffe0f3fc919cc44689cd0e6fe5e5997e2eedf87cf4247d9af9103a6682da411ed49451aa6534f227d8722565fe54883e2ee4dea70a28dd0ffe392f3ee0a2a9f5744f5ea58f908a08b3e1ca94754dfec23419b89d17508edacbd5457472717db4e379c4ec53906831c4c079b5752ecb6c09dd01ed19af143509588143130661eb068baadf2def35ac4bdf819c0bb885b7c7858e55b266e6e949f136b6b0b88849cfc88102ce789b9ff754c6f2ab57c91d178bf180ec54845a832e4eba9c5dc1100293f994a12e376a7bab14fb3bef88f8052b5233a038b89270c32873912581f9d02191beff2c1aa3f48422296d505b088eb9adfd0ad9d01b5278aaa38014231daaf7f876bbdba4300a6c8b76634cc930117d29b790a33416f64ab4667d969343d513ef672f01f50e71ca0b15650a37589b1beb3a03eec8fcb23a69dc963a1753d833f8f0267b535de91cb5c1dcd396422bde2f3186c15b8afdb7d6d0dc15ccef29a3c1a40ee90b3c09ede412de8c93af08ddc4acde4b322f29c984d5fd75d0cc6b197ffcae38653a05f608b4bddf09edc506ccadc92d3b2a7e3cb304629520052547af6852baa785be6f58e6672165deb9f38e8a260c5ee4c78079d4746360bbda7a86bad569060695f1d50fd68cd61045c09c6755e4441d55a82915c6e935a78e1ff429bacf20fcda8efa6adb3092409e5c138e0a44368df2b6ffab63db866f85ebfbe0e37bab248544883c71564b24fe2d36ab3be170094b9bf8e6df27fd09983a6b0a2d221baba8183d9bc76720c681153909a345b6df7a917c35c85241df9ea5d5b68157eb9db316852502514c8b2489ff2f1bc0aec634a3f6ca9988770eb8727918a3e9e9f2d736e0b803a376da86e89ba1434755a5f4d41ae89499735499869a6f7534a425b3ae452e8202658599f5c19799e808eaa09e945920867a46dec52ad3781c49c253db306271f91da247d1f0cf09fa429fb1578dc23dc05bebe76a2b06c9b1f54e13bac45549de283ce0d4f6fa814918c23a3d2ad1e5f7332d7296016d087fbe89ad4c25d106813caf8106bcc392694569f144fbdfa209715376388868cedc9510b53beeda0c985ad5d829176fc09202dfffa84aee43b0ba9bcab455e5917fdd6c765574367a6a9ba31f6e67e7a244bcc754d78734fd0f081d4dd4723c1a6e0deb598c297f1870f889db3e4a90b435b24d6618199d6cf2482dc883873b31865d933d56b508a599e6825311de7e934bb1c13dbf2dc4424ee97a76c37e32e74be761132173f6a456a50d881eedd11c9973f79078d0722de08a22262fec5d63a2f8e5634eea1b3184ccfd3241b2884bf29f27cc42bd13fbe14825a3547d4f463a82259f8b456df61d78e74c586022ed6be6eb15e0cc203e78dc73758104cd346e1cb4ec6267a7b22d2bb50b255246956299d75279e250709d14d67698aee74a4111533bdaa8b599fe7a7a03fcc0ae57dded4940b9769d0cce754e2366fb71003195b2a7233dea3f715a2c5982d4c6346e36bb2d14e33b9339724a5fd766e266b0d428e1ee33077b4408cc1410e6e8ec460d2c9cb9e05bd051a600723db28d5c60c977ef093a5080bf9f1a142db74a4b4bb65e3edd5f37abcec0694da3c0bf2402cfb93357592d88111a7aef4ddf8bea856b7ffd97178c7583bdf1b3d81563ee410ebd774c861b1c9d1ed49325b70dc8f2ef56f8ef616a8ef5080a0feffe3c25ede73924f60c79cb398d3ccc8bf67d55d489904b1d1f543866b78bcaff321c78636946796a8a368b2d2fc17ba9781ca98591785af802677560a0c5cffa0f1132d8a68e3d4316f82fa635df239c7abe85d4883c7de7b82ae53ce9e9d998346ed2d243c0b36cf5d3c094edafc384d78f8301b45a8de30dee571cbc722e0a94ddfea909c0ea843751f73a5f21677a29fe606c7de1c6af38fd02169a56beecc9a52a9631f4bf9eaaff2dbd1c8f6c4987e1e13f373594ec08a0855ced9ee54fb2b44313eac3bf7bbc71886ae9451e62a7dee154c1e0983ebcb7c988c2890894947aef7135b2ebc0402bce092a9d64ec636ceb1992b29119e59ebfbd119b1f49046033f7cbc1632736463723b6c32f42d6435af9d12867de156d8d49f0d272284224afad3b03745af3b38d1578e0253ef0925ea18d24f6e3ed5e2d71d043a00b3a3b2cea7c8739f79d0b1aa9a178937d92e6f34655f15c0865aaa50e202a4ad5ac24d720b36dbb1349ad9abc705556bdebb40c5b0819064159690d16fcc5bfb1520820e94da9b9c94a08d51972538ca48e916469fa1440349cc48011e2dddaf17d4805827ca679d9139c3b025c9331376c77a46640676022da84b8673a30bb8223bdb4390d428c43012fd22096db9472fca041ed2e05a2a9567d3e8bb4ea02a4d54b0046a62363562ad55692b79e295b30d41e17515fb91005032c4de4d8fd209a0350cb1482db9b3c79e87824a82543fbb411e805a1e99519cd9332187a1b8f8f19461e41a0ec5b07b0c0ccc3676e465f9f9712638ee56f05cb52cc9b21367e9d4cb65c0170d56741476e3f936a455dc4cf6cf7d6aa326ba366ad7ee890a792e0e4d809354afd813b551ddc30f7ad75b42e49dadb4e67df9100c2142044651e91e741ffab298d866f268a9277225ac114c374d2144aac69f8e98751e81bcbec89d6c37583bc6a83c196bad7e91c52cfa12d5d6bc9dfd4f8f8df2c5612e2b7e48f8a1fe2edad2599862fb8826e521999a6c2ecaba5372c42e1702d6e562593eed0fa8220b5ae12d6aa2b28599002f36c9f428be55434d51bec72094f20ec41646057f1108e96be0db4caa7828c84dbcde050e350ef4780f3cd251ea266c5d389f618e882b2e2cc43c8325608a8c9d8b1128294d7999663c9fbf77bead7ea18090ff61f0561f52e7a7548415e20efc35ef9ee2e0703ec16cb6bfc940fb524b4256d88c2ade9c7132ffe01c2f584d8065497e36d28ad1cf1c1bffd60b9af421b3cea450a59a7ead8d3190c4ff63a0f7ea8a197ba46b76e02b507b825aa9132cbd157e3696a8d2349fe3fc2f540aa92f92662f21866ff8d67c13d83cc8281d835003bcc819093fce7e231954f7cbd9d52bc3d4795857e605c5565ee22bd27eee5b5129b98412df69349a0f01bfc2353cf94ea2afc8dba6dfd121d3c42d5349da498cb14b762ed205308ef8eeea1917fb0e2935310a344b735d3875782bfa0059dce97366bcd9d8fbe4b87e29dac3f2f7d5fc8d9250e20bad6c12c6f1ab0330b21ac386f00e2f24105d7b745405dcbcf0ed838ff44da18758ba81bda1680a662e6af41ef01d2a706ed6198d4865c4867c5f76aec88aee33652ee2155dc69adb3eb6971edda30348b4c83a755f62a3b42dc9f0a6a13ff6aac519f2d204bdf90b018fdd4f0cd8290b95af0f9acf5fd1737807b47ca03efe9e3a798992c94f1483dd0e965cab3d3b23a2c99a0ca56944c5090bf9e84cd7cc745f93204b62aa0df832cf81c2fc7b9b28a5d970254d2f7e6d60d859ca33ce49fb5b7031bc40c405bfe542839c0a811146261bac1209bd6c084eaf1dd3cc7f422d6c914276cccd76b9cc0e7d16025af2e9e431c158d004de232f1ad224fb48b69b110602d08c5d3a84e7b5c32194ec585ab4e17c698355f8f48bfdb93f0c4278e9ba3d78e7459ffdb36e5559556a1d3dc0db842017050215de523a00086b8471a02cbfe0bfae15c9d5824c7b3ab6073d0f2984411a8f260e45ec46dc0289f1c12b083ee50e4866224b5175f587546c34d4d9c1a848e3af8a4c06e83ead81b3f80ec1f54c9c234e9bb737894a641a9a91d2626ade9d80564fbc725ea79ab2b35ef39f35962879bd36921f848687879639382f3b98d19f886ef925db9687d2105b8ad0ed1af71b58d5dc609f0465801d58ccb72d257b166bcb335cdd16d2c6329d0fd0a473230932e88d9138b0820fb3a76ca2b47749d80309ef26ed19e1ce7cecb2234e13e83879f3fe4bbd34ad0afae5b55a43d1b0e7b53bec2398909949c7a09a992bef82a59126c099334e453a4107713899efde00ba078c38764782736647ed9a1710e1321c33f1baa7f8a8494fee359d0e8d91751424c3cadd6d369b173077850df1732d39a4a55342eed4a96fd0a5d11384585efc3b2715368b961bb70a7055b0ed752f0245cb06a396a4a1f75156edd6c3dcf8ac926726d7fd6a3aec605ad15eeba45d87b34c80234d51fd4f05d9be401adb49cfeb1446fb80e1348f127e4749d487b59d1e1c3f84e5b75a89032f21791df488f5f858ad52076be2ee11903db7c2b71ad42e47d148a2f06be6ce46bd412057db528bb0f6ddf977737fdee4defc27d5e1772e4348fd09edc42e405588dc2cadda5fbe07ac99f78b823908a27687438a4a0ebeb220e9da945e840f43018870afb660890d13d70e86fe93d73226a2c01da566c2a90ae9089e267635b794dabd37477e61e299ea8a4f0879c2eb624d0bba2f1d976bd6ec2d8c89a54c21646ff1cd1415742353f7f339d69a59fafaa64a36749f90632b5716471a91d2f58380cf8ac33daed8f957b0d3523f92cd5ed76ade204fa8215f88c1ef69f804d05945c85cd2c39dc066d3443192ba7f4e59978bbb2b3102371f11a5ca9d5095695224339ab8feb8e542703a6f666bcd95a57da80f1ecbe9ae9aa279f427d5c3c5f44b5f5e328dcc881edd6edc70842b9280bae7c3a369501ea5d530944cdc160e87b307a796224d772f4ee2c4da9d5bce4c072da23cf9d1bb8837f9099be13ea3461dad566b08aee6b3b5b86ea60c928ffb81385f5c8b82d9ff262def18ae53b91e0a73dc5fdc569a04b6bcd29ce1abdf1d6285924d8faa41fda5471b8b8b61015320c2f8d4e5c43a08f18689c69990d30f68f952d5daa56b4e52fc8401f627643936e86dd4ef8a5ba07943b4808c304e1ab36102509510a866072073b36b6937d6617dd648e9bb2c48a5997d5401e00b8a6471d0c33f958c8f389ad563d02062894ca45d9b39af7e0ec20322d4c3d3db325d570f8d81fc64af9adc00ed1b65e3ad819cc0dcf2cb138d25eeefdc890d56dd9686d496359c937d5ebe1b3950a296c641a95badd6299842a4bfb21c065d5ca024aea383c0312ef8581ddd1aff30db8f70fd4b27ca3522684bc5d62cbb77c15ef5f251e4a54a80d00c408d03015b8682276eebbd32671db82bf7a14784d924d78764372e2d3907a0b5c12eac997c196e43e80d850c9214064825cc4bf9ccaeab255f619def3dc1de6bf7aaaa2074599e29f6d0d3fb498e87997f28ac30bd9a8390c50068fe690f977f3055f35ce013e41d8f237a19ab15b002d350cf708e68e713c45b1c6a6e547cdef694d617c68da7d39f8bfc5dc4b74f15383ac468f1ddaf79a03cff20ad47884cf6632e559505e621ca1c6c95ad8940ad84eee670b3c4f1619d673cb6a275d0a4e7a3be6646ef8c788561636b0fd3c349cf8eddb5473fec5bdcfe13b690f4a3e79a0b66c0eae12232a791e8a13cb895532f0c18f8be92f1fafc997d81f2bf0aebba75176eb1fced5c46327d0a8f7d4350e380d0a369fb322c3ca25539113e9d98f94bc850a2dc5d9824b327e1a48c363a4ecefddc4c9ecb1738b5e95c12e018df68f1d24182f229f3348ea951e14c379c53bd50c71c3dcad3ccfe4688df5e540e6b45c213910a5ef61ad72371b6eac975e5de2744fece51e90464f47ef8081da87639c4995e68e3d9c52a2025ec7c60d83f28d2172f87234c01e29aff89e564092d7479673131495a0f622f64f2ee2d90729df5ce31e6e3993dcb5855d96d1676a80477ea06d18a103462acf6de4e832100a563f93f5429007339bb7550e8629a441cfb11d5520bdc823d8a04f9969811a13ac8d29447feeb02f8c33c47797589202d5290120dcec7089d5987eb77e9cbb1ec13b811fad087b833b132228f260c7e1e485c8b53dc49f16b2c10b3621ef4c934d47abeeebc47f59bba9abc2ffdd83fe9e1c0ee88686e84e342678755bf44e09bf602eac51140bec2530c26fd5f7a1fa4a0c7131d49e779d630018bd93a53e35863923c14ce34d221198f595b0b7085f96b88152a95b567c13e4f36421749961fda00931b7d62fb39c275c327879d4ccb2c126b2964c045b5474d4d7c0de2e1802ad163f0e303b9012a01a03310f2deeac6e2714ea5939593fa104b995a570fc5cf641ee6e37f2f3d160f690b72cb90b0eb3cb14f79d38394b6f81713302c0aeaef924b0d1ea6b09e81c86f2a8f34d2c937625eded2d061588596dfef4261052e1aec2f71c8c0a3faa597db0ca67eab6a120f3eb1bccd1c2184e6e5faf05d585246a336bf45abbd5112c6aa3029db7cd5c3065f50d33400f8cb82ea2a7fb7550fb60cf19133f6d3c36cb405caadd62c78871ae4eaee87979731a41b4e0070d9df1a89ac72f53ea5646a87118b940762851def9cf5aaf274f2e98bad8c571045d95f2f77a8a35d11e138b5604729fde80b4f7798692b3b50c1af86dc66d5f0a8b583285b4200cb2628b993d316cf59f0dfc587de494d0308ad41dbe73189c38f661626e7ac61096a6bab1514540270ce9dc2b5d301daef80741593bea33dc069b57ab675f65e08819c407cf706dfa9ce29ba580e8009e90765673394b60e135212f37cfe516eb41a0b9000d820b0a60600281ee080e0d25a6374bbdf6194cd929f56a03f6fd782671c803d5ed46a3b7b7242175f1a1ea4250141e537b7e2216f78bda8fee1c293bc12695883467e793bba7825382475e148eee25299e771f297b8e409a0125c814bba71adc6649828082c73114179f71754a864dd6f7884ccda626cbcb3aa8d020784434730ce2545852907b67fcc51c3fe0a7d8d974c6706ceac57a31cd4cd05de87d2ceb35da75e700b8e17ceb1ddb466a88ba8ba64ea1dc7680df9deff5e2e8bac724a2de9853ff25e6adea2dacf7dfbce0f64dfc0e550020678e289f717f4c81fefdcdd429fe4949e2538f90385ee5fc41f33d21a1fe0494629057f7772a87d9e5effe3a1d2570e8ac25481078620bb767bf7a545911f8c47f60ff0e604bdca79ab07daeb380844878dcc3216899f55e127a07e411a78272fe567558e4b032377dbbd3e2c7a6de58deab645d5c13e110a8850cf693916f2573c36208c6b21d6c03f99b781d69f2e77c353edf248d99570d18bb9b1cb43ade8fc4cc2f68e7a4e8ba03962693a33bf09217921963ca2d7fe146190a46b7fc29375cf10fa88da3dab0ef43075524abeb354fa664f1cd781c3733c0879468f9364b80c6ef261a494db18aa5ee1e31b42a709edce2e84c8592dd4db59d9b70d9527aa740f64e6815bdb84ebe9baa7340d64e23a4024caadc5d28b448c5761418bca9ce547caac8541210cf2895118b11e20ff8617031e7a133a15cf668a57a10eb632a8d28573c650827f5f3e669271b81ca11bbd69acc768036fb5b1f20dafc91f77490a109512df6cada4bfec3f46047785536b5251cf48d2ae4b5e27d851e83c2ebf0459c67f1a2648b04c15abb8d9db1e99a6b00ddcc892dfa44f4c1d85fe7dd57787ddb92a755109d85ed2cfbf190a2d020fd87fb3050f6b09d41dbf24f90f50ea8ebd3aaf569c3414b79300a140fd6928d68deaef4a5943c4872c1cb2302fcf53209131edf96a1dc8f20b6b16a85e800b317a927e875fee9ad6123aeb67cecc8617fd59cd49a7593b87653f91500f4bf9a238eeb384d8f9c12e201fd7d30134e167ea85cb539001380ec02f40ecb16a9c0ab64b08970bf134bb4b7ea1d51e7dce75bdac6e594175c6f2007b716d0d82f7d908b3283038dab02a0f0b90f742afd98ac21db25e082720d6996fa7a0778f03bfce5b0ce0f4b289bdc3c47198bd3186ebd9c19c07128760b404c8e6c5dae713088b2168bb5a0c998398dc6f3452bb2376d1d83b551e47f7d08e6743534ea668e9b40a872115d635108bd846410abf8926db0f653c408238b838a7cb7b6ba7c9bf8588d87750d70368a414580a866ef03d1fbbd5cd05298db2efc49c792dc59f6abc1d9fd551d7eb5af4673ed4d4895f08168ab30d7440d174b39afbc7a2aa56168def7516a24d315af19d4643bf433ce431d9aa2ec2e3462982a3aad13240af83b93256d9a9eff0066ee9aa8581e904f380be4a1926741f65968d4a337833286ffde33ad6de91398f7fedd361a8960a7317cf3bbede55f6de06348469b2adde67f2fb6395fea9a94a8ac312598a32653dfbf2820abb5cf2f75902cc6c05006fc434948bbd77a95e52add2afbb41a97ff38bb08765a44b1dbb6a256f5c38b623701ac3b135ebb4e929ba08f4137302ab27cb56f814317cf1c77c3c91a273f601cbba98cbd1348f46f56a78adbea8f7a59ba7951d6d85e679f514e4d24d34006b3ea9bf84e3289d74b5407ff0c5439d9aad98f38d001fe29e85cf63656a9ed8ef1bda65a7ca48583e3b26ff704dcdbe8467e487af7a6d63335f1b58ca317ac7f1450b0869d6ece1119c9dad85d22e00c66ce55360e33c469088bb0e8f367ae498c787243f07eb92d775f3fdcd70c05e65af052dcb2bab08eba9a0452ed099bfd444957aef2bf1f62f9d5d87ee00f167b46b2fb671d93309bf2b535523afa09e53b663e872354026a23cda4f024a635b01da6cd8f0dbd375b22932a42656511a875587cbbcf234ceab8b665bde2b86a9873bc96a46a4da1796f4fed897b945247a9de333a3f8562377a48df1fa530ef69a64908e141beb0e4458e7c335a1870700dc203adbd094c20397d70ec97576bb8bdf19ff9458bcf7fccc26d415acd386cd7d2d84ca847487221676e84bad0173e6e95ba89f55701e4365dba218f746ef1faedb4eb95fa854b92ab963b63acccdfb5d5be8e188f1bfa0b59f1f7f9da885e3ddbf8bb7852c8309fe67c63b1752bf6f76c97349b58d093cdf5e83167463fb3776bf1270159d4570f56f1d85b6485a4cddf2ff265c7dab39ff9a1946a0a9fe87d891114bc714829e8714a3361c3d98b2ff1e3517106a4a810e493cf31cc007bc7b09f4a27e0c03265ade9981fe59a04a645703c00bbbf5a5d3752dae728647420c499cf5a6e279df1402c6a998abf5046350a1a904024b08b268fb019cf0f3d1662158556b1c42cbfb8faff42a874360a1105a4361cdcbf87373ad6bc45ade88dc9e2bc3c297564572dc7172054bb84306ef0cabeebe8098531905cf14be7f6f394638ef1b4fa1deae66f44098f31e5e485d567604b001bf6b869aed96f4eab10fa3355156effa9bd7eb23363020a1c06a645d031e2f8f6c2a349ed3db99a51c0c80d948501becbe6fde709c8b9b12f2857b2bf9121e24c7bf5efcc0ef6abdedfdd97a2351abafe975688e195c1fe55fa8f7b5ca7d80b188b48eb530890bce9a5592d710555792a26db8a52d6923ffa6bc6ddea72e7b81f2d0a1f2b1a13ebd0fafd2ffed160223fa29fb34d371106c66ce1042438153362f245fe2d451d5e4729b5c671d8f52ff4f188c4d516267039e13e8eecd7969cf639ff0b1352364eb3d387e15f5cd6f96b444ceb0f9a3fa9ce9916d7a8bb3ad9090828e6421e444364ef6bb91ce9f0e3be93a6ef9b722e34166af0e9b6c6eee4285354474433911050ba31a4c7e918e415c3c8d6d31897a80209b88525c278234a115d289c6660146f6cc4af850622d7ff2ddd827e64abd54b3417bd50bf428071a1eaad169f2b0fabcbe7675416f04493351618959851ad4aab244f79075dc0b0f252f4ea6ffc59334d80c81dbf85d971497885ca4d8bf8b681fdb256ca0ca84833637defd21246402c61f30a3ecb753fc455525b8ae37cbae70a64c614d7e43cc6d784117debd033528ff0dcfc13abd2b71ce3f073b108ecc1504ed5f4f03b4d76a26e40f383a678f75febed5dee27da5b64cb9152f9a5023b609be1ecbbda25c158920168c0620a0b12e9035a404291adc8d07f6d8e07a8e487372b29e3536c0fffa52b5f28726a593f49f2a7b8515ebd0baedecf354e62d6434e0547011348f929d13b7158200eb20ea721014a038e3ea06999952afc4f98cef41d5a862e776f9360838f86b9f391260d0ebc6baad603d88ffadb43169f0678625391f306501f12cea840c7d0b4ee0b3ad0513ec3bbaab0222812416f5ad63a27abf824fd1ec2ee6d1d60c28102476ad3cd704bacb787a2558933c434913da733e50a0270b75df63544606018a83767590b91cbf312487dc44cbfaa7bd671caf4a6f6523fa41db59384f5bc2be4eb36f06c7b25df5d161711bf1d0362ae4cd03fc2a981b4d6cd2aa4065a47fe652ab3ede4ae606aff438fbc21cb17f5b20365d51de7a270dc8502a155e07999dd8ad84192282975effef769ba74f5ef33a68431cedf778d9b4e3fdf2c98a71be477cf76416dafd72192b7430dcf756d6e213a10ec10af84e7a5f01a87858f538c34694a9ee8b762b2bb8ad37cbb19545458a67ec2de3d5c6c09e5e57753bb9abed7c5aabf6cde4f36a42c692b0970a04b6ebcc1827a5cbbf3e55f4d9e4861c8134de18e35de4aadc53919b6d5e59ce4c657e37f473b47d23113e19daebc23b11c5a03a512a278ce3bc75adeca8d2ac22def00752f0b31fc637f5fe696ee591fb33ba36de11b9e2339217cb19b44b429a303bd50dbfcb1745f2adf869372d2a25456cf5fafde524cc43a885441e6fde7102da24986ed1e48e6a084ee5a8bab973a78532decdec388cdda8f54a37b0f3931eae7f48eca1a1f086cb9614afb29bd9d53271456eb1ac613ebced7ac2fa8276240f8b22649178c8c19e183dc1faed91cc1ca2a9689954e6f1a170944884ad1d06da54d1bac69ceb00be9167fa107c9c8e9c27aa34914c70cd411753a325db103912e5a3d60fc881323329a10d28f6dbf7fffec0ab24e9480e250f4a09aa468ff55def925f874eccb2f59634f1b251d0885998e47eb6146fa929f7f18cec5eca57ed6abb10fefca7d077817c7c724792689e98ad8b20f50327db6acafd58ff450fbef1c501064655b621d00d595a9254a973bc8ed275f9453de5248caf6110effd35fd11a6df2ab6d3c540dcf8e557b04cd6107c4f099efce93d12af36237123511ecd5d99d54be86c08495e6e41334167dad9e2bc0d2d97120db8c21f4b194e217771396c7daab30e4bfde378f4813d30e30b997e1a539de52e9c2bcdb661e59605d22bef35917b4b8a3e9b36fabf68b02d778007790e198f0ae9b13608980b14e55b4dfce5c764aff3d963fe08d4fac3df2f0770fb10dc8a8b12657437b69e82fe53f0e44d7aa83ba349728ab0c025bf65ed22702c1fb53f3d64b819367e5542b54cacc87da42ada13bb77b52ffee8464b3da14e40f79253bb4d71c2da74f77b196759ba0fba98804afaa3e5d31a4210bf43d82da2fc982ea5058986239944ac780a1466edd907eb1374fa0b3b9000d5c367bda82d7a689e4c9622d4b734ec6fe9a27b9c6b82cdd26cb63112fe4a9dc815dbb281d639d51db193cccd41a2daceca1e396d77228f52e123200baa219845c065cc07151fc28603135029e94176f3c164adc1165c7081a63cfd94014ccec4a17e5ccf44cd65c67fc2638d5b8a57a0701b41169a4479c6dd48e19737bfdcd74136ac9718f83f5b05d7309d8fbf141a9d6f28dda07492d1595c30416d19559adfb83638ba5f39b863d0d860d7b099666a94798bd57e4e3933c9c24f81af2661ccc700e559d3cb39ecf87edbf396a7311f0edb55b00c02ad4cfd6e25a942b80ddf773aebb58d2f599b27cc6b7d839b34f89ff980f01314d8e23b08e2a0680ba71ce6fe7787ee2f1c40452e7cfcac71c2e44861f6106f2da058924867353d86be3fbda4a625d5af22bd12ea0ad75e892cfcea9538b2c635a845e806169762578712a671b503b61a160183e2744c2f67a97dc262b97044c9f53a248982b3deb1015c0eee26d3207c6a5cb9edd70a3a5673ca6c8d0e104e3f066c08cfe6b43ec3e3b74adaf28056518d13c71a287dcedd6eed91b42c171f54351ce09f4e68ba6267b5b9afe6cd5430b582d0cf307c9fee00919dd57079354e85470d8a10d9143b97a0eaeb868e9ac4228118620d5f4230fce34924e91c8e713706f1ba16c566baff8858a7436d701f04ad9c5def7e57cbab8b17befdbf7e7e98976888d68d018d097b96a07f599848b2dab75b26ec1a8be0e6cb34f24a1664f2bdb0bebd0e92613633a43ac25496c791421d549d4a3f465f0b4b5f37d844f837deea7bc6c7ffa31f160ad6acd436fc82c371fcdf5cd45f478fb0802c67e716f4ceea8f08a5a35ab4c94304dbc985b6a34b515f5b62a93c7154f40b705010f0580fa85345248b8cc1f1800604f0aaf0253eb5c5a344ff0dd270de44231aec5b8fb43fad053c60e05e003338e22e71417cb04c47283ef95848184bcdf44d294032677806fd84c8839b8fe03a08c6670f0b425834d56c876a1c410df0fb3a9b2931ee7564b2fc4752b8f45881c86e3fdae06fb4442979883913a95ea7b68684e23286f30faf8adc41c8a2bb480823fd62a454e9f059c44468bb7a306d7b5d1878525ac8fbbd86d34695c2d92fd0503e1872cb189ecd2a0968b3f16541962a9dfd239e721e709b0a04987d8dbd8f4c1ff1d6526d65038acc213fbae0ed3743ee9452f4a75d2e77809eaa704bc63dd10b27d5b64da31f960de3f159f665af5fe8be2abd3883eb538404bd9c9f9761e54bfc5153924e7b41bfdd94a328c498db6cd58d7bc31b5da221fc23a20d775ca10f3d4649c7521ddec51d1a4cf795a86b8a70ad01d23c22b749d4deda8ef21fbc3079c3d0d7bc61559e4a6f8dae001d0262df557fc16e1f6c010b9fcf2157ea5da0b0598888047cdd54bee585f724404f49b7a1142edcbbbcd91432cf64573f9d641f8d4cabf7aa89727863070070bb2a839d40bf7de394887bdb3f5287337ce66514ce4e49a9e9aeff90e3fdb39ccec376abc55ea1c3cb81efc561e6a86badfd322343a7c65a53efcd115fbeed2d7019c9c2179d49f82d5ca777db039c22d3aca8ea192688cbd038f4a13aa98e44deb9c8e619ad2554762290ef8ec82ad6d14f50fa1a245d943373023bf6866a5128c1cb87b4f6942b5f625b48b75c6dcd79cc7cb186e0d75c7b6fc1ff796f1030eedec63cffd53c0d217d337775dbac34b3bf27d489d30f5d24609ac7d34a770b3ffd9c140023181b1e83e103d7dd95fa6594c5d2dfbb419dd3b2bcc936151e03424c8eb59c5065a939bf052ca7f82fb22784a4c11710e0a0a983ff71745f5aa94482a1535edf37fe89e5f926f4c9cb4e5dd875b5deb4306bbb57264fb6bd1c0f38da33ad2978d861c85edca4e7c5738c9521dc63adbce1dca86e138c47acd7d3e45fb9c408b9f85b1057a480c8f1601485dc2a07675e4e570bb9459b91101721c7caa6137d98b446401d72f7d91a8193ac9f988816b7b2ed645cc9acb97cf2f1ad978efb94acd78b1d7a7c004029931b66f00c2283d21231cbe5cd5250ed3b3b62f93c72be33280e3ed8cd6c550b989c2bbcb30e1dad0aece395c5cf2115968b5ebb5b9f11c62e27607944e347bed904fc24e47efb3567b4cd0f0ba7e7d0ed148a62265ce5e28d8b2aa1ee5acb783bbc810378ebafc0eff21f78409c5e4db794eb753461e22df52e5d356db9e3053d76561ba45dfb095caa3248493e3a62201253746c9e293b5442a188a94374277db12f67d22342624dbd65bccde5d60e5b488fe87775a6f1d9ec25d83c02604b4ea6a86175e3a274bcdbc8a37bf7d8c2f47d9ce88bc3f83b53592d20724770bb47b319686fc9e809685354a359bdc25262c883d3c414a77b29a847f3670936fbf15e71a26fe5d2fc01fe8969e4c04bb0b31e169dc17a44f6e257a74a0f00476d5fef734420b012f7b8b10a240040bb9a8428cc57f4fad25df9c0c0b135c291926c61df5e6551d70b5857352d3e60f9f86860e5b4ded8d499cabe85edb26c6a3ebd85ed2ff6b9650095ac8803f09dbbf21d696664caab20387824fec5d363660e177518a82d07d187073d1e6c50cca32eecc32b18a285b6b23c6153a7c05da62374a89046bc3782a9ac2567c2d97e45747cb6ab07984e575b33f10944800b1bf5d73f6aca14c3ba8c9bc82f18022768e3e7e5262bd45698ede8885dfb82cac78d17d5ea58ef011afdbf4a7e8d95faa80888a6da2780379f684112ad863989fc9ed3429fd9590659640c6055c8884e56d86a430fee47f7123b2f2ff759c6bbb0bedc1cc4124b81afd9841522147141305eae469bf947a5ab99ef16a9a5180a45ed724c18c2457bc75d2697d028bdc22d6f561e164a6f619c0dfd80923b703991624db1dfc77bfe6af1b7dc781290312411f85a6832943aad832d0709c0dd56ea47b5d45e41001e3c86921c61ec4e2de372b73ad022e401abbf5bbe3bcb182e44a2826bf3828510d5f0ab988819175c66677d670b577afb3f1a5b035137ed6348c72b92e55386103c3bba338cf882cc43951f00d070ed11c7777ae261aa0391762ad0462dd03c7cbd71807ed35b86197e6ce466f985cd82e1dd62c9685d99675062b692feca150c3787396528f42671e2e31849d88f00e89f16a05e4f8f84524d5f095c5861ece6144581e8aec865296a952ae2e197da2a4ff4df283f28232fdbd12a05ad0123b1a9029483ef5037018e29095e6115eaf91b5a698c273b1910f4cab3cad50efca5cf0a3a338ecd2de482b9ac6e8d0caf95260b093f8101f45f0f8292f01c59e3317574718799619249defeb585453caea9318e3df8bc8ab7cff04ee954054726ce0bf8e86854d264d5278e172b2882dabbd74aacdb76ce3d447e43bbd4d03e955d1b974962b00854afe97a61c0f22061c9bebdd428dc605177eeae10964671a1c1a246c4b2524e283d3363513e13b6f44a8a1582f241145524c99fccf58fc4ddfd5482b65c7e5cf7187e385b8bc90e06c993cff65d8839519a17b77aee804a6e7ffc12b45863ce690de753bf8a9cedb230654e512c03b390f184b4f588f520093b340dfe5658ed3b4431444c8201e6491be1fa4159fd3213b76eee0742029eddf926b8eb3c5610b73db5d3b8520cb4d5881bc30b80fd5661c8344755774d1ce09af6d790e33112793d0dd2f5caca55bf69702ba1db0d72794b0ab5c37a75eebf2fa66be9202748e759424732a0954b4fe589325d7a83d8dbd80f6c9ec3ec22733e63efe6031c037cf7d75c2fc25facd76e21e63e67d75e3f1a29d2c876219e3d62627d846b72623c140ac3f276a5d74f92712ebe3e7891db33a8ca39d832caae0190b0a6624a493ea437bca268b71d2ad9a0d7fdd9baeea918cd2a3565c9f8899de2c3866b95501b1130108ef1ddc522a8aed155ef675687f9a6e7c47ed392b015d1f0a7b71022505ba5b165efe8b8c3bb3e398742e2852ebaec153028f929189ed2780740c25fdaa65e48f38176c60e35dcd6fe8e44de9e2fba3cdca2d21eae18487ba72bf5f8e767d33873576c22b8aaff504202a1d9ac7ee36c2d3fd3d6ed1b1727526b507550935064d0b24ecc1bbd5a0678f3b8479ee7704da8db67ea6b404066da05e833ef90500535459da26e52cfc3d429b63fc2e38f6329417305efb77a1a487ea6e2565d22c7d56c41eac2fa6fde204b51b5f0833c8a8224c5678c946a7493078f2d6a5aa718868ae05066c5277413658ace70847ddda5ca4fcf86e8a86b2a5046ec9293a47cb262402d1fce930a937e7b393c2a2832c83fc1e6dabfcde9448a3fbb3df7b97687e8557d4c608d4c0870f3952bf225a49c9d39cf59e2ba8e72e052d875bcdd7c61ad52038f99d5e0298c65d3235848c8a789a0e66f53658c3e72d56d52c8e3888043fda5972a53fb7d5835a32e3bbeb3038804f6702425266cbc0c0529fe964a36457115c071a1bd350015831a42270237aefc0bc8fccdfaca2dff557268efa3b87e06f943fcd104a725a45ff7f3af2ea4c3c67044c7e49172b4ba8429763aa70ba9ed3213d9028ba93c4f12a6ea349e979344a546b85f69d98ae4d4d9dd5b60e264c95ff4e1ae90524f78bf4acd9febf804824904a5edd6c96267da2e0903ff3d08eab3f65eefafe7b650640a94368e6e546b3ff8b8c9f33fd2017a10de8a613105d8bcd7d32ccc2ddc7452c3176f6f37705c74934e24da77515f3f0717a329704d425f82b318deb84c40e4b496afaf5794929df5e763744011c360c664c71e4c7691805fca789864e070eadb188c2e5c048eced484cb63561dcdca3f855ebbe00fde55cda93553ebf5ccfcd0b2863113f146945d5d0291e1cf96a560d7cef103f614a021df405dae9830eb895c6706c315ae9e0861a5c01f2ef2a0680a540fc9147989d09977f11b52f5e6f16d398bdbbc68033a8eaa28c75c0016783ff08d2a568efb6ad335ec523ec07849189f819caf2e908485028ae99481bb6292f633c7a92f33392e13481c5b1a56ed305c26e52ee400fce6d2d72f75e7ed087a4989ef10314b35ec4835164c5353b7051ff4c7fc2e6b1931b9b2f164c280d15d4e640e463c66fb42fd4fad88f6b1e8261ddf139ec0789036e1ae410dce080dd273a91666fc92ee00c02933bd93abf46f7ef75bca579fd89ba557155ee2c312a858b7b393dfb0dab7e87b0875a148d9d88666ee01e4fc62884a4b7bd690b86721b5d428bb5c112cc189725e259f5c7755aacc21f19e3c8510cc830c27ca6e725fa1116931225a28c8aa0bc04520ba2ac06388670fb5ff5a1992b277cf6e91839702a43fd4754b5d56defeff24d13c7d514a5253ac83b1a363566c3c79548fb5b6a0881b19d520ad2fbff7e76cfb6ed69e9ffd5af50b11b67a824a54ff44482140813ef9f302510083d971030f69bb57373d4ca6f310e3868f72a64af94e6b41fe5f1713324775adf6f4577e0f33a5fd8a1377db6298c4e022996d0506e1af7cdafa77e362ef92a7374c77190e42e557f6bd715a51ee493d1e1942f7f749bc989f664981689115aedae48c1d73d05ec9cb0d08072fdde8df281f72f4c48f517dcd27fb3eded21dafc90217624f103bb4c7499b9397c36cde7c46094beb8484c9f6551667f496be452e2d4a913ce3c57be1526dcb54305291021e1319236c3bb687958ff3fe9e07bec9218a5ea05cf2c268ea9745c071cab87fe9f376fff5193bed1d9eee4ef44459e121f5a422bc03cfc2e40aec2feac62a6600cd615b924334a103bacd279e2f46f3c8ba045b9bfb908b491c5a86eb018070d8bd26c496941ba6344b0fc05e3580830ae482ab21f8b22b805fb67047cd08b4ffac7655b73117771cdc679236b0d07ac416164489ccf4b90c16a8616dfc3fe40ae498a5ae90e38a721d750ecd7c66f5a4c67643db7a9b25292518b312b9952651ae72fbb8df6ef0bec358de6b3f0292b5ec66a7e5b4c13b86fc765567a95b2f0e4510e0a67f91ecf24ba808580328bd92231e48288928a2021f17cfd9b435e36d131ea9a4f74c5fde9214665172be0ee8f076e8c5924b692737f71ebc5bf0b5d93d6a474c73af47595db27775f9038f3de3ef3ce9396be1a60cdfd36dc03979ad989e99b3bf1837b4c0672bf4d5df243dbb903ffc201329596bbd7bbb45b35e6ee4cbc3833245593ca6fc7fa49e6c14c47c901e97f645aa7624c23be321dc726bf9ab122230432db449306921a2ef8e7aecc90be409420bd81c3676bfc08b4c9e58ce8a622c730817c10d5bd087af062b6dfedddd016646358035b96d2adb81e8576d02801e79d3dea7df284cfbf818888ded6ca90176d77225b4d3fe6ac3bbf3a000af0a4662869ebb9165883e6c79ac7963562337f06654b4c75a3de0d228760ac54a37012cc9f8cc35c84d72954e82f2c142c4acb1db02d1c3df01977be1c7d16ff2d99680b2c8127e6db05e30b8fda0459e385c55fdd0521ae830af0ed2d130e5c9b857b4c208580de181b75a8700634e226e348a225776cbe172afedd3ed4d75e7733ddf0201db26c2e71d70a94096f5927d9842a84e3916dfa26a2226bede2cdcd521ba1d0cb807d369e6ade8b566787f35b87bf85ecc51b3246f200a51c6e8b2eafc8c4cf18f57a941757edbe4dd52f72ae65b5e542f9c13138bd12cafa3c236314d1a16b3527eb1072f31b27b26aaa33033df5d6a8677c48eb51c81da184a7362373c5f343ce0ec5721b83967470463258e0ea20ced9dfc1c894d5729d6d8fc4846a71759c631d6aacdb0f052ea433664cac9f1318e196730e486a5dab5223da3063a7ed17a651e75f5b1ec1198ac4dcffb5df9dde7e5b37b048355dcb0b3851782da2c2eff1430ea2b4943f3981a9ca14abe9bf0da59e3281c38fca6a64a5acd7c4421e441bdca5884d17260784fee5dc42853b6ef5cbb7a6af6eaa57f72c97973fe615c4d16be93e992823092943cc442857f211e85badeea637a7d92077bc9d67f512c9ad2d6b1bbf3b8c93d7a591fe8ef69dca1ab6ebe9bda1d036a5e5b56c32a3d891e2ff272bb1cc19fb28d863baa87ea3188cbd070c04375c7c161b49a8643b0c445707c4e6be98529fa44dc903d055e981f99a326a1b500413d4075aa37dd3c4450605b524d144618415473ff3ef82ea86bc6287d51b3b6b5edb12afb3416dd113fda0024c3731196beaa2c093dccc69b244999027c972ec5e61d2d5bbdd164eddddc449ce76842341cd6ed4a3723656607fafcab09bdcdfc1b4a1bc5337f1d1de499eec23d8e8e4d5f92ce91c01ac48ac0689e9df94b9178abf06be33284857f19396f2492e7fc6098b3259bdc0ff203af559c5b6b1432d3910f08380ca2c1882b205e2006eef61cc5752e96d89ae4c576627191dd2c02f49a4d0c17bfbf394c1bf2b86cdb676294b89adfd0e4ee330bbeb060f46ec1e26fa1efb1f26c8c304066820117dbe7436327358385e542067233051d626d13f0775098ff790ade7274933e6e1b72b033d4ce8eb384757036cd507f8557a5f90859af97c9c64115050232ed4451793603571293266802118ef7218279a1f9e718df6bbd13af3228d24fa0dff967400c838a1fd2923e2c5b34d711ff0d3a16da1ffc9168b577b776eaa37a7ee87f5eeb3dd96dbc588856b3bff84980cf59855b3bcccc569c5ff59c57d759a363bd3a9eb6d7a9811b8af3c850018967978e3d34eea277da32fe5ae857eafce7e5f854507f3ff3320536d2b32513642ecbf76b505c2bb2de0b4cfe223276bae33eac4ef3a268039b4adf5085b7756aca7d9eff4d0f15996ed28c6530e8dabc2dc990a8445bf8820a14687e110ab5b7f24d69bfad1d66e3a8554073787a8340f4ccd566181b4ca2ff11ecd1b5f98b7e4ace63ed6cefd1a47cee37e3619584f62bbb50d2886e6efc6848811753a1cb0ab030ddbcaba45f862c42b4581f86f2f56b90669c35aac9e19e71376c83fddf47519113f059aa49e9d39849163411ce510e77fece6e57d387852214dea90aabc7f65fe819fc8620e39f9fd11f0f46ca3b91a1cf494c00de8ac5369495e5db82985ac81f4324d7b5f806ee38ed001e9300e7262d4a1749ae6dcb62f5cfe281c0077cd479d369488a4a09ae48525b22a832e1294a54f2535080b98e3e1b18323c52ed06c49365be78a048f3478d81cc634f3d61f954e5e0ebbabc56e07f6eeb1e858afb3dca23b4d75054e72d09916b9179c170ee7bd10bb6d4c4bb619f1c1992f51c3798c9c1ee83b3b0b48ac5a8c08cff7e7d6032f1eba730a3a4402e474722e6f3c689136171b344517135a110e7f81a6b50943a396b99e6cfd223d80d84d06d594f9c884dfae785e2d2d08f7c27a627d5f1aee9f5eb176b9cabb1df69097ad25b645ab8d7d08473e48dd11a5b1b2d459437ff11b8ef7dd6b44cf01dde4aa1aa66d265cd0849a3a77e416bf230894602f4af325463ce4b4fdd94e5cc47b72333972aee3de0cb8a97be5e74adaaf2da3285f030f2ec4b5ca3a468e700dfff97937fca90cd85e10eebb94e217b54fc85f3b84c75668a04dba1a6d8b9a7bf2ce25aba80614c75a8fd7098ec11aa963bbff906b1f1ea3abf3d9f7bf8f16c51f9638eaf51fa16e1e93fcfd2469f4f24a9f17e80c5b985e63dac66ad3c9ec937be75a2476335593a09752baa3d801ffe339398da1044fba679c2b1ee25c13981c605110e2fd36ebd8f282b714fee74592003e1d57190c0a8e9fb1343275c66bc7a7a6273666b365e914599fa3e4205c8f64e6e55614401254be47d76e8738fd4f9f5d3ec1619dd24eabde370fe1d9fbfb7e9b3aafe756e4682b620474080ec8424f3d81be3fd76a5cd4d5a38062b9fe31637d6e710d91ca5a8cd0922a1e428308e321f0a520005589a27d63db025edf71bfa92ea5ef6a82ec94f8b9e0a0380c44764909bd7f68fbab7be2ee85fdd6da345a6f01bc4dce4d2877fa00fb6c489591821d44ae9c96f3d0b468406a5d17095c638898590681daab9461e1ce18bc901efbdb2bb31d672f87aa360eda1ded126343807a7831a9285d6b9f5adff0c95042e24457b6df6a4a82d9e4751cf9c35c1723efe85b23edf106618ea872a05148563eaddb062fc942d47bd2834f8064582a2cebd26e0b8f26a6c5f29e48e04b9ce2d4e4d8088b1666b592835800cfd213864e3ae1432df9548d01b3982caa09202ef11ccf4a357538d591c349bd81dff7bfab6c700708f9a8b5bc9064703c85bf67eeb2706218cba8c45699ab53be7c271147158427c2311262125f8107967ad21f654ed26c1ecddbba785c6aa810aa8aa0c07f8f8786f542c07d101513dbe9b353e756b8acf07ca69e94f2567a347ccc95568924f0b0f21e5efc338569a868a51dfc57e44aa5ad47a22385473b815e934e6049506dd51bc8f85a7f673f5213ab70864d86a2ade5af2b8414bba03182aa5a3568bd0c8f45e474d668a0c765ff063e532ee761d5212f69fb4d0b635ebc1279844658b32296d7adeee050736cad475afed6481847cd15cb2395027ce8aa213f08341bb2103b212e68782e387fb84e4d22f5cb2bb3d06667a6bd36dccb51e9c0be2eeebeec2953e3f9214f5453d371287d8f8383ad6ae889c91e46c16966f69930dbcd02547e788b6db16c6a3d0c63ccae01da6f00d15398ea5c6da80c25bf8ffd96b670a3630ef5502986226dd08cb55b3a4ba3e23ed5ea1822d699246754a937ab8bd77b102826b9bcfee99d371947696f1d420fec78a5ede2d06e0fed1920aefae0565e8f45c3e1c3353f3710304eb69347f728561864f35407ca5461e3b5c9ef107effb11bd1c832e5c353d9d2d6b3e699f83c1b30ad61b773e11cb64c90193d01a481a78db0a5cfafe7445ec3f67ebab71fe033838c9f997a81c62e7238688dc0b18cbe30df045db28d28da5698c4a72aadf65ca029419ffd0c78a48fd3cdc19916e4a2629df3830126a4e7423c6ae8737dd18b10d5006820875c5fcfb06df94290d264d1c76c660a60289f4c0a8bf40fa7d1d3398b7fb0351f37334668a633805df86e3cc457ab79da0349330221cb7a82f3db1c71283f018b4406f216aad8dc5443a83a6f17fbd040b976eb25214b36ba3ad8e96a915ad64a1808be8542d83f04cb06b961ff8b55062ccde70262599ed397055f402ac7a0b2377fd27f81f2c5abcadc91ada7266f2a1fb419bb8d8b8ac60ec5075b78a8c91c5acc63b04216836502f2425aedd708dff1ff280fe0bff22bb2f846c644d661ede4a269008a8d7cde40b5fe7e56480cf9f0d0c4c88d0872a66e01126bf347a821c8c3d4216b6e4b060638816113e04d570774cb1caf60a0f46de8938f450941c063b9beebc0daf9a4caceae9b699fc6278d3071f1358a4cba2b59b0f675d0c58fd71f148f79461e53c2a91c4dd9b569fa5e1d39b9236f397ee2abab15d7797b10d6410aea1da786c4879b910658eb530dc094db915565b28f64e58b0bb6afedeeefaf1298d0d316d92aa38b76bad081f2603b1037a44fb243f44f4f13376e432b484e7064c5b4913d7e6a8c095130bd6e04390e3ad3242ab75dbf54f59605d70006940aec21db8c2c1a228a631816558c8f7349423e5c0b81746030b3cb9c8c24330c752addee422bd931c71ff7453a58d509308c9f70ec61830af51fdbf023c5aa03b7ef4c0e70ef4b89f4c0d92a7777c332e966c1147f5b91ba4d70f315279d8f18e7ddeb60c45ebb389f912337e221a660c8a24191afb839986b7c840ed40ac754b03548a36ba4231cd3d41b630278f388e5376d5e90220d761010c2fb204b32a6a994579706e3853c29930d08f465e99349478515a09278ad0eab93bf365b602294cd805093fc509f009212289cbe066e8806925506cf8572a9b1f9e36b0ba33e30fb6347f12c3188fcfcadf70e54e6441634a468c180a60789bc51d35b449b596e65d54a7b4ecb4c2ac813a4a7291e9975118236c4e243470b83b7eaaf7f43963e8cef1a528b684024d99d1739ebaa5a3ad7646731b9f307331e00de1c4e8f10890552414a88e53ef0fe6535ebc74b9789b298f65aef7d7977fd3b46363645fe3a107acd2cb0ff99d03753784456cf766dba31f0e27bbd23390ec0bfb3e33ed983094de0a6a56f35e85d8fe9ab568eb353fe9c4034811c6fa6a5f41e35aacb7a04a4e20b1cb90dfd6d47635e38b3ee059aea764fbe9f4c15bc7be8dc9336e9b975eeaa8617162fed4fc110716142963ded425b2068a7f504b8830f13f5c92880c5912232f6eb3ba8d3b582118858fc61788b2b46a9c8a2b376151ad1d59edda9e4052bec51331bb50c8e8050e635c2ff94d9fe5632335d4de5f9b644594e849f3707fa2d8a565ffead4aa4aaff400800f992eb12b62a380422cd1f8f5a6cef2e52a504a556218696a5979d3d1fe27c7f6c2121f582500cb3b6d1d2ccce2242f3ca1a12b8875871eed6ebc7f6deec9eec990a5ab10608d26ef00fe0588f80d205d618ed9c3ed90794f739f778acf40516b8d49b3f6323fc08e1f8e2eb517f034dcd7eb83ba5de8e1bcbb8c37cea0157ad9dfbfa41df735699e91509cc547ac1f343a443290d024537e96c3bdd890d1576beaf0bb2c6f22277c29d541dbfb4b2bf1a16ec90b37270a51fbe32febeab5e2ae04bc14ea3fb1009cc863f4094ddd823738f83e1030c8ee70dc15186b541520ef4749fafbd891da001724877e871b103c15f2476c52d4839309866a2ad01e9dba53f9e741f39a75cecba573544d08f34fdc0536ac3143265ede61bcbc73b5d8f06afc2c0a069399c836ec472ba5c9e21da330f7ef89e7a8a4fd151530e50e37cb681e504dc4d4c06cae9814dc81232a565caa24045ed3a1736f9f7011d0d0d6c6c6af65647b1d24ecb58c9264f13cb62ba7cd78c342ab5fb7fa254195ecd170976ca4c44e52f321a63dab7a4f85e6469755c4062f94cd79eac3b12abea7adc0be77f95644eaa7bdf8411bb1ad2e83d41f65025c204f5fca6d565f05f48a5e5c36b791a5f625ed2204dc7b0e3c86a7bc481bfc5dbaff06a2a21bd1aa2642f6a556e8497f7a7a560b6e95f97302c1b1c05cbc5a182514ea4534177a39f460a1b9f2260a7013b9dd415ea651df49f99b2f38f07ee061b6afae17d46b282368079597ed2580392e8bd57c84bda8706d758c5630aaee8903dc5cc1e1337959a44c0ff0b9e4b69133059716e6f6e0310eac6c590c5436ed90a8e956ddeb8b2bd177647e2de3186a8bc5f23ae10905b5484958c097d0761c388fceefaae4f87939437fb6e1b27201160c8e7285938b066a49da03a19719648432469f91a985c9e4752ab0b83deac0dae0d27e62724208dc8995ff109af7d290844c6b8c123f22477b2daea8d9387dcd36f1bae2a4cb8b6870b090d71a6af1cc15c1620a1fec4e82ce7134d348cb5159a9915f6dbb170a37db74b6f225f07da1ad69d09182c8a14f056c61a60cde6d132b4bc3871dc46403ee1a6841ab6058d2b9bd8d5be164399c31683adb9ab689543708efe86b2d1788975eb51448be74bc2267ad4d4b4db7a7f07144bfa798bdd11ea65473bccda5f552ef5e875ec0bed9aaf9e228d4a14f7b4d3a9731399dcfcce9e7f843a7f98d28fc370108e74021c92228d9f396d1a22c014f5ba4d31197817ddc93a5dee0e4ba7d3f2b28a4a04c40caeffcb93b36ece48d4cf9accef3dd609b5fbde9bb68c5e016ee67097adb504abdc4b1b89220c1327a1daff0dbfcb1c0b578346df3c6b24f6cf6d4b37fc147e32ef0dcbbb6e9e32a4b70cf51f815866453e9fe27e2a627ac348ac323381de7bc35092a560d6f150cba0593ac5c2f4c019652a1f74a98683191c8e04c24e2a5cf0f6d2d79ec7658bb925875d7974008e8601f879922d32f6193ae53dcd3ff8cae0a496312fb78aacf0e2cf5d277179c503590032c81b21edf184a80c6abc113b1ab4a130a44d90d00ee16015758903c640b5151ac4d84dfc4749f64a27eb58d4467ce3f79f9fb35d727eef8f8348afc544ee1093c5e5290e6f0be25cb8a329ec45e6f6e089372b68836ebf2f789471a1d62105b9264d891fa9e4f199c1a2d2f349390cc616a3c7e665fd82675234270a023a57226b99fbb66c58d0d13ac06f8795d73ee6a9dcdecf7213b8e794606e7961db9fa19583fec51fab5e7109b394a9dfec9d293b14ab45df724eb36c11e5073173b5208b6f0698c6366c495c1a7052d61bab2121a0e1b31f7b542574e33356ea0339afca2590faf5257a67478752e225cea7eb24f5cf3370289812604658d3477fad1beb17b4eb457236413028a5652f0f5a8902df1bffe4f403627cb735a10025a69a7f4547591293d9ec0086c2525bcc9f7c0759fb0cb926110ae1d001ccfdf94a2101498fb4a62dcd1303d4199200b02111dd26775d35a5b3007a90cc4788be7789c97a607fdc87712c41de4552f8cd264efa8874e267ce008bb13a787b7e6fa32beccf5de23d0d02260243e128bd77195f49afb028ba82bf8a06079376576a829896b0f0d1ebe45c8dfaa29cf9b10ebf841ddf75712ed14b8cba3c0aa2fdf4b0975a5796367aad8e4e282ba385ae1b3d30ad053ae7c58aa10c73870471d75c687281ee7e601ee8ba58642b165c1dbead5e703e51ba2c0fbaff0eb9519bdfd0a9f96451d5289347ac134a4fca495d560cfd83e4fc7dc7264ef36337d90cff9ccb9fffce652f9597d19f8a49c9af2c44882c95714d762ba2a017837a42e3310854ab09874fa3605c7c69a5dfa19b562625e9433d2995f53728f411c5c574f0448541f494be8ae20e3ddb66e7e046aa82fcdb693e9bedb6f84c5433254e82872f13b465d079bb706cd61dcf558a3064aab73473488a75b8e7e830ce9b9f17a23c82295b99259fc6b0c29fa9ad8e4dcf2b81674e5eff4a77731cfb44ce8b53ebdd4fcd4bac253e184cee4796343b159b16cdf17c77299944c36346c3bcbdcc565a4c25c598eb86b849407f5e3529750f6846e8fcabd7b03c48136f747dbd3b8d53476ec603adbc2efab1746f987aa9c094d761ec0181959c5a5d5339de87a01946372bf0f0c2a3fbaa2b6eb2c1d58bafac50bbbb391f37b4c109e78abd1200f6bee57d8338883bd0d814f275b2f6ed95223495465a54ea17e44ec35ec1edc5a52151af4a59137461d04c35eff2c92d6d98405f4c8f6dffde77fceb6c68c3312163ed64546897e4be1fcba5289f78309390eddc20a48e6c1bae1d874b982257dbe9d80bdc4cc1dced82e41356ae8af457a2b3cf415b34c35b8d5ac883b1aa8deadb45d6daf88a73b53653ef0c866caa6b146cb0650980ac4eb4e1ba04186586000028d4f89d7e3d9c9f3841fe193bbdd8a2011a76d3cdaaf928636739ea40dd867c5d66fefbb8f9b61e6e69965e2f7540ff614b2c7478520f8c44334dd7cfd99b1de315403e2a8f931f02a58186dc27b78f70fb760ef248897ee50cf76fc4de50ec2da62979873723ddf305ee59ecea90f3fd1bb63efe2137fb40f01222c384b071e8f4707b667b484cdde934248fc129a637b5fd2ccb6b321b94def6b26c7e5b67da7d3dbe9a778f7c1062c47a0819247980366b90b5e6d8e83e83d79dcae41b1c7c95d8575ac9c5659a324af930e2e4c15ce19b6d2462afdd2aa0d85c04cc2b52e50deeb1e9323e10ac454f214babe20efd36c0d552e6b1017e899d6b9ab680a258bc45bf9184f259ec9fa025100c194185ce3692faa2ad8d7d7252adf0d78dadbfc8b24d541728ceb7c10f00588696a2c896bbf12f645f2ade42bbec68af2edb275773d47d560f413f6ce81cee7034ff6f48aedc1f83cbabc4c5d822fbe169e020fe9f6223adce6b328928266a67d85f39a130f352444877ff7bc23b36fa11139f722c64b7a62ca63836e603d4b9dd474ed19fd5b707d0c21878417f3b1981d701bf4790e57994034ac9d4a3151de07d2439e5286a30b3f1a1da7f4e2cbbce498d8206cdcd1d59fd1ebff22a9a7320e6f6b96864e8a6a9951b4f50c2068c5b7af3d5d5b7066e62205c6d3d35a135959361b005cc00348aefc6f20bc38535b8058f6d4408bc5a4fe4b7e930fd5bb4a07c9c77cdcfc382e57f0adde1ec0009d0befc7f442f13b8863ff0ea125983ff72655c4afce42ff4bddd506e539d95faa46b5c5a07033044d874fffc7456dfce0a5471b64775890c2a7909c2990c4007033eba4428e0d1be31dab13203d328cb5effb0b9bda59125490f5c1dc368c94c7e82c61abaf9f4a7fc4bb7b1519a34db95c46a2bacd8ee78d46499a40dfd5b696ecb0d81d13f1a2c3257290f36baa6a28d275402678851f3293103610c1f89a15115a3e689e08be3a253458b9ea5dc50fc3bfeda8fe13a53c4f1560f359c76b356980189200737dda327d2eeef7be714d3aa689a1e8ed53794006a51af6d029ae04181704f2b2496c3f6004c16f0ac87cad1a32723684cdc53e84465886793e7dd2294f6ee5015e9eaed92f136cac367b9186445b59959abd440820b6942f23416653afd30a89000bed48e4f207f022a0e9a4cdce8527b11e76f57c60b1b7956c58837a4a8127ff24cbc821ec1ce3bad5090483d2e2f843353efc43fa0e1f574b7566a149ecb0f000be322b093320b04be36b89754b92bd182cea2a960a9e404398e4c2dd9064e8fafb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<link href="/zhihaojiang.github.io/css/hbe.style.css" rel="stylesheet" type="text/css"><script data-swup-reload-script type="module" src="/zhihaojiang.github.io/js/plugins/hbe.js"></script>
<script data-swup-reload-script type="module">
import {initHBE} from "/zhihaojiang.github.io/js/plugins/hbe.js";
  console.log("hexo-blog-encrypt: loaded.");
    initHBE();
</script>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>data_analysis_tools介绍</title>
    <url>/zhihaojiang.github.io/2025/05/21/20250521data_analysis_tools%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>GitHub地址：<a class="link"   href="https://github.com/super-213/dataanalysistools" >https://github.com/super-213/dataanalysistools<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="information"><a href="#information" class="headerlink" title="information"></a>information</h1><h2 id="summarize-df"><a href="#summarize-df" class="headerlink" title="summarize_df()"></a>summarize_df()</h2><p>汇总 DataFrame 的基本信息，包括 head, describe, info 等内容。</p>
<p><strong>参数:</strong><br>        df (pd.DataFrame): 需要汇总的 DataFrame<br>        head_rows (int): 显示前几行数据,默认5行</p>
<p><strong>返回:</strong><br>        dict: 包含 head, tail, describe, info, dtypes, missing 的字典结果</p>
<h1 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h1><h2 id="drop-columns"><a href="#drop-columns" class="headerlink" title="drop_columns()"></a>drop_columns()</h2><p>删除 DataFrame 中的指定列或指定类型的列。</p>
<p><strong>参数</strong><br>    df : pd.DataFrame<br>        要处理的数据框<br>    cols_to_drop : 可迭代[str], optional<br>        要删除的列名列表（如 [‘id’, ‘name’]）<br>    dtypes_to_drop : 可迭代[str], optional<br>        要删除的数据类型（如 [‘object’, ‘datetime64[ns]’]）<br>    verbose : bool, default False<br>        是否打印删除的列名</p>
<p><strong>返回</strong><br>    pd.DataFrame<br>        删除列后的副本</p>
<h2 id="impute"><a href="#impute" class="headerlink" title="impute()"></a>impute()</h2><p>通用缺失值填补函数。</p>
<p><strong>参数</strong><br>    df : DataFrame<br>        原始数据<br>    strategy : {“mean”, “median”, “mode”, “constant”}<br>        填补策略<br>    constant_value : 任意<br>        strategy&#x3D;”constant” 时使用</p>
<p><strong>返回:</strong><br>    DataFrame<br>        填补后的副本</p>
<h2 id="detect-outliers-zscore"><a href="#detect-outliers-zscore" class="headerlink" title="detect_outliers_zscore()"></a>detect_outliers_zscore()</h2><p>使用 Z-Score 方法检测并可剔除异常值。</p>
<p><strong>参数</strong><br>    df : pd.DataFrame<br>        原始数据<br>    cols : list[str], optional<br>        要检测的列（默认全部数值列）<br>    threshold : float<br>        Z 分数阈值，超过即视为异常<br>    method : {‘both’, ‘high’, ‘low’}<br>        检测异常值方向：<br>            - ‘both’: 正负两侧都检测（默认）<br>            - ‘high’: 仅检测高值异常（z &gt; threshold）<br>            - ‘low’:  仅检测低值异常（z &lt; -threshold）<br>    return_zscore : bool<br>        是否返回异常值的 Z 分数（附加在结果中）<br>    drop : bool<br>        是否直接剔除异常值行（返回清洗后的 DataFrame）<br>    verbose : bool<br>        是否输出每列异常值数量<br><strong>返回</strong><br>    如果 drop&#x3D;False 且 return_zscore&#x3D;False:<br>        返回异常值的行（pd.DataFrame）<br>    如果 drop&#x3D;False 且 return_zscore&#x3D;True:<br>        返回包含 Z 分数的异常值 DataFrame<br>    如果 drop&#x3D;True:<br>        返回剔除后的 DataFrame（无异常值）</p>
<h2 id="detect-outliers-iqr"><a href="#detect-outliers-iqr" class="headerlink" title="detect_outliers_iqr()"></a>detect_outliers_iqr()</h2><p>使用 IQR（四分位数）方法检测异常值，并可选择剔除。</p>
<p><strong>参数</strong><br>    df : pd.DataFrame<br>        原始数据<br>    cols : list[str], optional<br>        要检测的列（默认全部数值列）<br>    multiplier : float<br>        IQR 倍数阈值（默认 1.5）<br>    method : {“both”, “high”, “low”}<br>        异常方向控制：<br>            - “both”: 上下两端都检测<br>            - “high”: 仅检测上异常（值 &gt; Q3 + 1.5×IQR）<br>            - “low” : 仅检测下异常（值 &lt; Q1 - 1.5×IQR）<br>    return_bounds : bool<br>        是否返回每列的上下界（Q1 和 Q3 基础上的判断线）<br>    drop : bool<br>        是否直接剔除异常值行（返回清洗后的 df）<br>    verbose : bool<br>        是否打印每列异常数量<br><strong>返回</strong><br>    如果 drop&#x3D;False:<br>        返回异常值 DataFrame<br>    如果 drop&#x3D;True:<br>        返回剔除异常值后的 DataFrame<br>    如果 return_bounds&#x3D;True:<br>        返回 (异常值DataFrame或清洗后df, bounds字典)</p>
<h2 id="detect-outliers-boxplot"><a href="#detect-outliers-boxplot" class="headerlink" title="detect_outliers_boxplot()"></a>detect_outliers_boxplot()</h2><p>用箱线图批量可视化异常值<br>    df: pandas DataFrame<br>    features: 要检查的特征列表（数值型）<br>    max_per_page: 每页最多显示的子图数<br>    figsize: 每页图像尺寸<br>    dpi: 图像清晰度</p>
<h2 id="handle-outliers"><a href="#handle-outliers" class="headerlink" title="handle_outliers()"></a>handle_outliers()</h2><p>处理异常值：删除、替换或裁剪。<br><strong>参数：</strong><br>    - df : 原始 DataFrame<br>    - cols : 指定处理列（默认数值列）<br>    - method : 异常检测方法（zscore 或 iqr）<br>    - strategy : 处理策略（删除、替换、裁剪）<br>    - z_thresh : Z-Score 阈值<br>    - iqr_mult : IQR 倍数<br>    - direction : 异常检测方向（上下）<br>    - verbose : 是否打印信息</p>
<h1 id="EAD"><a href="#EAD" class="headerlink" title="EAD"></a>EAD</h1><h2 id="pairwise-plot"><a href="#pairwise-plot" class="headerlink" title="pairwise_plot()"></a>pairwise_plot()</h2><p>批量绘制特征两两组合的图表，每张大图包含最多9张子图。</p>
<p><strong>参数:</strong><br>    - df: DataFrame 数据<br>    - features: 要组合的特征列名列表<br>    - plot_type: 图表类型：’scatter’, ‘box’, ‘violin’, ‘hist’<br>    - hue: 分类变量（可选）<br>    - max_per_figure: 每页最多显示几个子图<br>    - figsize: 每张图的整体大小<br>    - save: 是否保存图像<br>    - save_prefix: 图像保存的前缀</p>
<h2 id="plot-all-barplots"><a href="#plot-all-barplots" class="headerlink" title="plot_all_barplots()"></a>plot_all_barplots()</h2><p> 将 DataFrame 中所有列（除 except）按类别分组绘制为子图中的柱状图</p>
<p><strong>参数:</strong><br>    - df: pandas DataFrame，包含数据和类别列<br>    - hue: str，表示分类的列名<br>    - n_cols: int，每行显示多少个图</p>
<p><strong>返回:</strong><br>    - 无（直接显示整张图）</p>
<h2 id="plot-feature-distributions"><a href="#plot-feature-distributions" class="headerlink" title="plot_feature_distributions()"></a>plot_feature_distributions()</h2><p>批量绘制特征分布图（直方图 + KDE）。</p>
<p><strong>参数：</strong><br>    - df: pandas DataFrame<br>    - features: 要查看分布的列（默认选择数值型列）<br>    - hue: 分组变量（分类列名）<br>    - bins: 直方图的 bin 数量<br>    - kde: 是否绘制 KDE 曲线<br>    - max_per_figure: 每页显示的图表数<br>    - figsize: 每页图像大小<br>    - save: 是否保存图像<br>    - save_prefix: 保存图像的文件名前缀</p>
<h2 id="plot-all-boxplots"><a href="#plot-all-boxplots" class="headerlink" title="plot_all_boxplots()"></a>plot_all_boxplots()</h2><p>将 DataFrame 中所有数值列绘制为子图中的箱线图</p>
<p><strong>参数:</strong><br>    - df: pandas DataFrame<br>    - n_cols: 每行显示的图数量<br>    - exclude_columns: 要排除的列名列表，例如类别列</p>
<p><strong>返回:</strong><br>    - 无（直接显示整张图）</p>
<h1 id="features"><a href="#features" class="headerlink" title="features"></a>features</h1><h2 id="bin-continuous-variable"><a href="#bin-continuous-variable" class="headerlink" title="bin_continuous_variable()"></a>bin_continuous_variable()</h2><p>对连续变量进行分箱处理。</p>
<p><strong>参数:</strong><br>        df (pd.DataFrame): 输入 DataFrame。<br>        column (str): 要分箱的列名。<br>        method (str): 分箱方法，’equal_width’（等宽）、’equal_freq’（等频）、’custom’（自定义）。<br>        bins (int or List[float]): 分箱数量或自定义边界。<br>        labels (List[str], optional): 分箱标签。如果不传将使用默认区间或数字编号。<br>        return_interval (bool): 是否显示区间（仅对默认 label 生效）。<br>        new_col_name (str): 分箱后新列的名称，默认为原列名+”_binned”。<br>        drop_original (bool): 是否删除原始列。<br>        inplace (bool): 是否在原df上修改。</p>
<p><strong>返回:</strong><br>        pd.DataFrame: 处理后的 DataFrame。</p>
<h1 id="使用案例："><a href="#使用案例：" class="headerlink" title="使用案例："></a>使用案例：</h1><p><a href="https://super-213.github.io/zhihaojiang.github.io/2025/05/18/20250518%E7%B3%96%E5%B0%BF%E7%97%85%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/">https://super-213.github.io/zhihaojiang.github.io/2025/05/18/20250518%E7%B3%96%E5%B0%BF%E7%97%85%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</a></p>
<p><strong>具体详见GitHub</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>survey lung cancer</title>
    <url>/zhihaojiang.github.io/2025/05/26/20250526survey%20lung%20cancer/</url>
    <content><![CDATA[<h1 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h1><p><a class="link"   href="https://www.kaggle.com/datasets/aagambshah/lung-cancer-dataset" >https://www.kaggle.com/datasets/aagambshah/lung-cancer-dataset<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>This dataset contains responses from individuals who participated in a survey to identify behavioral and demographic factors associated with lung cancer. The dataset can be used for exploratory data analysis, statistical modeling, and machine learning classification tasks to predict lung cancer risk.</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.metrics import classification_report, confusion_matrix</span><br><span class="line"></span><br><span class="line">from sklearn.metrics import accuracy_score, roc_auc_score</span><br><span class="line"></span><br><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.optim as optim</span><br><span class="line"></span><br><span class="line">import data_analysis_tools as dat</span><br></pre></td></tr></table></figure></div>

<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;survey lung cancer.csv&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p>我们查看数据特征的意思是什么:</p>
<ul>
<li>GENDER	受访者性别（男&#x2F;女）</li>
<li>AGE	受访者年龄</li>
<li>SMOKING	吸烟习惯（是&#x2F;否）</li>
<li>YELLOW_FINGERS	手指是否变黄（是&#x2F;否）</li>
<li>ANXIETY	存在焦虑（是&#x2F;否）</li>
<li>PEER_PRESSURE	经历过同伴压力（是&#x2F;否）</li>
<li>CHRONIC DISEASE	现有慢性疾病（是&#x2F;否）</li>
<li>FATIGUE	是否疲劳（是&#x2F;否）</li>
<li>ALLERGY	过敏情况（是&#x2F;否）</li>
<li>WHEEZING	喘息症状（是&#x2F;否）</li>
<li>ALCOHOL CONSUMING	饮酒习惯（是&#x2F;否）</li>
<li>COUGHING	经常咳嗽（是&#x2F;否）</li>
<li>SHORTNESS OF BREATH	呼吸困难症状（是&#x2F;否）</li>
<li>SWALLOWING DIFFICULTY	吞咽困难（是&#x2F;否）</li>
<li>CHEST PAIN	有无胸痛（是&#x2F;否）</li>
<li>LUNG_CANCER	肺癌诊断（是&#x2F;否）</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure></div>


<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>GENDER                   0<br>AGE                      0<br>SMOKING                  0<br>YELLOW_FINGERS           0<br>ANXIETY                  0<br>PEER_PRESSURE            0<br>CHRONIC DISEASE          0<br>FATIGUE                  0<br>ALLERGY                  0<br>WHEEZING                 0<br>ALCOHOL CONSUMING        0<br>COUGHING                 0<br>SHORTNESS OF BREATH      0<br>SWALLOWING DIFFICULTY    0<br>CHEST PAIN               0<br>LUNG_CANCER              0<br>dtype: int64</p>
</blockquote>
<p>由以上信息可知 该数据集的特征值有15个，target有1个，该数据集是一个二分类问题。<br>该数据集合没有缺失值 数据集用1、2表示是和否</p>
<h2 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h2><p>我们将数据的二分类使用0，1表示</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.columns.to_list()</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>[‘GENDER’,<br> ‘AGE’,<br> ‘SMOKING’,<br> ‘YELLOW_FINGERS’,<br> ‘ANXIETY’,<br> ‘PEER_PRESSURE’,<br> ‘CHRONIC DISEASE’,<br> ‘FATIGUE ‘,<br> ‘ALLERGY ‘,<br> ‘WHEEZING’,<br> ‘ALCOHOL CONSUMING’,<br> ‘COUGHING’,<br> ‘SHORTNESS OF BREATH’,<br> ‘SWALLOWING DIFFICULTY’,<br> ‘CHEST PAIN’,<br> ‘LUNG_CANCER’]</p>
</blockquote>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">df</span>[<span class="string">&#x27;GENDER&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;GENDER&#x27;</span>].map(&#123;<span class="string">&#x27;M&#x27;</span>: 1, <span class="string">&#x27;F&#x27;</span>: 0&#125;)</span><br><span class="line"> </span><br><span class="line"> columns = [</span><br><span class="line"> <span class="string">&#x27;SMOKING&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;YELLOW_FINGERS&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ANXIETY&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;PEER_PRESSURE&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;CHRONIC DISEASE&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;FATIGUE &#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ALLERGY &#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;WHEEZING&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ALCOHOL CONSUMING&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;COUGHING&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SHORTNESS OF BREATH&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SWALLOWING DIFFICULTY&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;CHEST PAIN&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> columns:</span><br><span class="line">    <span class="built_in">df</span>[column] = <span class="built_in">df</span>[column].map(&#123;1: 0, 2: 1&#125;)</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;LUNG_CANCER&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;LUNG_CANCER&#x27;</span>].map(&#123;<span class="string">&#x27;YES&#x27;</span>: 1, <span class="string">&#x27;NO&#x27;</span>: 0&#125;)</span><br></pre></td></tr></table></figure></div>
<h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2> <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">dat.plot_all_barplots(<span class="built_in">df</span>, hue=<span class="string">&#x27;LUNG_CANCER&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p> 可以看到 患有肺癌的人各项水平均比不患有肺癌的人要高</p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.corr()</span><br></pre></td></tr></table></figure></div>
<p> 从上述相关性矩阵中我们发现GENDER和ALCOHOL CONSUMING的相关性系数比较高 我们查看他们的关系</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.barplot(<span class="built_in">df</span>, x = <span class="string">&#x27;GENDER&#x27;</span>,y = <span class="string">&#x27;ALCOHOL CONSUMING&#x27;</span>, hue = <span class="string">&#x27;LUNG_CANCER&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p>可以看到 在男性中 不饮酒的男性患肺癌的概率比饮酒的男性要低<br>在女性中 </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">feature_importance = df.corr()[<span class="string">&#x27;LUNG_CANCER&#x27;</span>].sort_values(ascending=False)</span><br><span class="line">feature_importance = feature_importance[1:]</span><br><span class="line">plt.figure(figsize=(10, 6))</span><br><span class="line">sns.barplot(x=feature_importance.values, y=feature_importance.index)</span><br><span class="line">plt.title(<span class="string">&#x27;Feature Importance&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Correlation with Lung Cancer&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Features&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X = df.drop([<span class="string">&#x27;LUNG_CANCER&#x27;</span>], axis=1)</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;LUNG_CANCER&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br></pre></td></tr></table></figure></div>

<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train = scaler.fit_transform(X_train)</span><br><span class="line">X_test = scaler.transform(X_test)</span><br></pre></td></tr></table></figure></div>

<h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rf = RandomForestClassifier(n_estimators=100, random_state=42)</span><br><span class="line"></span><br><span class="line">rf.fit(X_train, y_train)</span><br><span class="line">y_pred = rf.predict(X_test)</span><br><span class="line"></span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br></pre></td></tr></table></figure></div>
<pre><code>            precision    recall  f1-score   support

       0       0.50      0.50      0.50         2
       1       0.98      0.98      0.98        60

accuracy                           0.97        62
macro avg       0.74      0.74      0.74        62
weighted avg       0.97      0.97      0.97        62
</code></pre>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换为 NumPy 数组</span></span><br><span class="line">X = df.drop(columns=[<span class="string">&#x27;LUNG_CANCER&#x27;</span>]).values.astype(np.float32)</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;LUNG_CANCER&#x27;</span>].values.astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征缩放</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train = scaler.fit_transform(X_train).astype(np.float32)</span><br><span class="line">X_test = scaler.transform(X_test).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为 PyTorch 张量</span></span><br><span class="line">X_train_tensor = torch.tensor(X_train, dtype=torch.float32)</span><br><span class="line">y_train_tensor = torch.tensor(y_train, dtype=torch.float32).unsqueeze(1)  <span class="comment"># 增加一维</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正部分：确保 y_test 是 NumPy 数组</span></span><br><span class="line">X_test_tensor = torch.tensor(X_test, dtype=torch.float32)</span><br><span class="line">y_test_tensor = torch.tensor(y_test, dtype=torch.float32).unsqueeze(1)  <span class="comment"># 增加一维</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BinaryClassifier(nn.Module):</span><br><span class="line">    def __init__(self, input_dim):</span><br><span class="line">        super(BinaryClassifier, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(input_dim, 16)  <span class="comment"># 第一个隐藏层</span></span><br><span class="line">        self.fc2 = nn.Linear(16, 8)         <span class="comment"># 第二个隐藏层</span></span><br><span class="line">        self.fc3 = nn.Linear(8, 1)          <span class="comment"># 输出层</span></span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = torch.relu(self.fc1(x))  <span class="comment"># ReLU 激活函数</span></span><br><span class="line">        x = torch.relu(self.fc2(x))</span><br><span class="line">        x = torch.sigmoid(self.fc3(x))  <span class="comment"># Sigmoid 激活函数</span></span><br><span class="line">        <span class="built_in">return</span> x</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 初始化模型</span></span><br><span class="line">input_dim = X_train.shape[1]</span><br><span class="line">model = BinaryClassifier(input_dim)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数和优化器</span></span><br><span class="line">criterion = nn.BCELoss()  <span class="comment"># 二分类交叉熵损失</span></span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=0.001)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练参数</span></span><br><span class="line">epochs = 50</span><br><span class="line">batch_size = 32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练循环</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    model.train()  <span class="comment"># 设置为训练模式</span></span><br><span class="line">    running_loss = 0.0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 小批量训练</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(0, len(X_train_tensor), batch_size):</span><br><span class="line">        inputs = X_train_tensor[i:i+batch_size]</span><br><span class="line">        labels = y_train_tensor[i:i+batch_size]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播和优化</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;Epoch [&#123;epoch+1&#125;/&#123;epochs&#125;], Loss: &#123;running_loss:.4f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Epoch [1&#x2F;50], Loss: 5.3979<br>Epoch [2&#x2F;50], Loss: 5.2241<br>Epoch [3&#x2F;50], Loss: 5.0661<br>Epoch [4&#x2F;50], Loss: 4.9229<br>Epoch [5&#x2F;50], Loss: 4.7911<br>Epoch [6&#x2F;50], Loss: 4.6619<br>Epoch [7&#x2F;50], Loss: 4.5310<br>Epoch [8&#x2F;50], Loss: 4.3962<br>Epoch [9&#x2F;50], Loss: 4.2550<br>Epoch [10&#x2F;50], Loss: 4.1069<br>Epoch [11&#x2F;50], Loss: 3.9532<br>Epoch [12&#x2F;50], Loss: 3.7950<br>Epoch [13&#x2F;50], Loss: 3.6341<br>Epoch [14&#x2F;50], Loss: 3.4730<br>Epoch [15&#x2F;50], Loss: 3.3150<br>Epoch [16&#x2F;50], Loss: 3.1634<br>Epoch [17&#x2F;50], Loss: 3.0199<br>Epoch [18&#x2F;50], Loss: 2.8862<br>Epoch [19&#x2F;50], Loss: 2.7630<br>Epoch [20&#x2F;50], Loss: 2.6512<br>Epoch [21&#x2F;50], Loss: 2.5504<br>Epoch [22&#x2F;50], Loss: 2.4604<br>Epoch [23&#x2F;50], Loss: 2.3804<br>Epoch [24&#x2F;50], Loss: 2.3079<br>Epoch [25&#x2F;50], Loss: 2.2413<br>…<br>Epoch [47&#x2F;50], Loss: 1.3242<br>Epoch [48&#x2F;50], Loss: 1.3006<br>Epoch [49&#x2F;50], Loss: 1.2785<br>Epoch [50&#x2F;50], Loss: 1.2578</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在测试集上评估模型</span></span><br><span class="line">model.eval()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">with torch.no_grad():</span><br><span class="line">    y_pred_prob = model(X_test_tensor).numpy().flatten()  <span class="comment"># 预测概率</span></span><br><span class="line">    y_pred = (y_pred_prob &gt; 0.5).astype(int)              <span class="comment"># 转换为类别标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率和 AUC-ROC</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">auc = roc_auc_score(y_test, y_pred_prob)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分类报告:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;测试集准确率: &#123;accuracy:.4f&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;测试集 AUC-ROC: &#123;auc:.4f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>分类报告:</p>
<pre><code> precision    recall  f1-score   support

     0.0       0.50      0.50      0.50         2
     1.0       0.98      0.98      0.98        60

accuracy                           0.97        62
macro avg       0.74      0.74      0.74        62
weighted avg       0.97      0.97      0.97        62
</code></pre>
<p>测试集准确率: 0.9677<br>测试集 AUC-ROC: 0.9500</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习--长尾分布</title>
    <url>/zhihaojiang.github.io/2025/05/26/20250526%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E9%95%BF%E5%B0%BE%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p><strong>长尾分布（Long-Tail Distribution）</strong> 是指数据集中少数类别（头部）占据大量样本，而多数类别（尾部）只有极少样本的现象。这种分布广泛存在于现实场景（如推荐系统、图像分类、自然语言处理等），对模型训练和评估带来显著挑战。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ol>
<li><p><strong>头部类别（Head Classes）</strong>  </p>
<ul>
<li>数量少但样本占比极高（如20%的类别覆盖80%的数据）。</li>
<li>模型容易过拟合这些类别，导致对尾部类别表现差。</li>
</ul>
</li>
<li><p><strong>尾部类别（Tail Classes）</strong>  </p>
<ul>
<li>数量多但样本极少（如每个类别仅几个样本）。</li>
<li>因数据不足，模型难以学习有效特征，导致欠拟合。</li>
</ul>
</li>
</ol>
<h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h1><ul>
<li><strong>图像分类</strong>：大规模数据集（如ImageNet）中稀有物体类别。</li>
<li><strong>推荐系统</strong>：热门商品点击量巨大，冷门商品极少被交互。</li>
<li><strong>自然语言处理</strong>：高频词汇vs.低频长尾词汇。</li>
<li><strong>异常检测</strong>：异常样本通常远少于正常样本。</li>
</ul>
<h1 id="解决长尾分布的方法"><a href="#解决长尾分布的方法" class="headerlink" title="解决长尾分布的方法"></a><strong>解决长尾分布的方法</strong></h1><h2 id="1-数据层面"><a href="#1-数据层面" class="headerlink" title="1. 数据层面"></a>1. <strong>数据层面</strong></h2><ul>
<li><p><strong>重采样（Re-sampling）</strong>  </p>
<ul>
<li><strong>过采样（Oversampling）</strong>：对尾部类别重复样本或生成新样本（如SMOTE、GANs）。  </li>
<li><strong>欠采样（Undersampling）</strong>：减少头部类别的样本，可能丢失信息。</li>
<li><strong>混合采样</strong>：结合过采样和欠采样。</li>
</ul>
</li>
<li><p><strong>数据增强（Data Augmentation）</strong>  </p>
<ul>
<li>对尾部类别使用增强技术（如旋转、裁剪、Mixup、CutMix）生成多样化样本。</li>
</ul>
</li>
</ul>
<p>代码:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from torch.utils.data import WeightedRandomSampler, Dataset</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># `labels`是类别标签列表</span></span><br><span class="line">labels = [0, 0, 0, 1, 1, 2, 2, 2, 2, 3]  <span class="comment"># 类别0和2样本多，1和3样本少</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个类别的样本数</span></span><br><span class="line">class_counts = np.bincount(labels)</span><br><span class="line">num_samples = len(labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1：过采样（对少数类样本增加权重）</span></span><br><span class="line">class_weights = 1. / class_counts  <span class="comment"># 逆频率权重</span></span><br><span class="line">sample_weights = class_weights[labels]  <span class="comment"># 每个样本的权重</span></span><br><span class="line">sampler = WeightedRandomSampler(sample_weights, num_samples, replacement=True)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：欠采样（对多数类样本降权）</span></span><br><span class="line"><span class="comment"># 设置每个类别的采样数量为最小类别的样本数</span></span><br><span class="line">min_samples = min(class_counts)</span><br><span class="line">sample_weights = np.array([1.0 / class_counts[label] <span class="keyword">for</span> label <span class="keyword">in</span> labels])</span><br><span class="line">sampler = WeightedRandomSampler(sample_weights, min_samples * len(class_counts), replacement=False)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在DataLoader中使用sampler</span></span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=32, sampler=sampler)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from imblearn.over_sampling import SMOTE</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设特征X和标签y</span></span><br><span class="line">X = np.random.rand(100, 10)  <span class="comment"># 100个样本，10维特征</span></span><br><span class="line">y = np.array([0]*80 + [1]*15 + [2]*5)  <span class="comment"># 长尾分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SMOTE生成少数类样本</span></span><br><span class="line">smote = SMOTE(sampling_strategy=<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">X_resampled, y_resampled = smote.fit_resample(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Original counts: &#123;np.bincount(y)&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Resampled counts: &#123;np.bincount(y_resampled)&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="2-损失函数设计"><a href="#2-损失函数设计" class="headerlink" title="2. 损失函数设计"></a>2. <strong>损失函数设计</strong></h2><ul>
<li><strong>类别加权损失（Class-Weighted Loss）</strong>  <ul>
<li>为不同类别分配权重（如逆类别频率），使模型更关注尾部类别。</li>
<li>例如：<code>weight = 1 / sqrt(class_count)</code>。<br>代码：</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">  import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设类别数量为4，计算每个类别的权重（逆频率）</span></span><br><span class="line">class_counts = torch.tensor([1000, 100, 10, 1])  <span class="comment"># 长尾分布</span></span><br><span class="line">weights = 1.0 / class_counts</span><br><span class="line">weights = weights / weights.sum()  <span class="comment"># 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义加权交叉熵损失</span></span><br><span class="line">criterion = nn.CrossEntropyLoss(weight=weights)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">logits = torch.randn(4, 4)  <span class="comment"># 模型输出（batch_size=4, num_classes=4）</span></span><br><span class="line">targets = torch.tensor([0, 1, 2, 3])  <span class="comment"># 真实标签</span></span><br><span class="line">loss = criterion(logits, targets)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>焦点损失（Focal Loss）</strong>  <ul>
<li>降低易分类样本（通常是头部类别）的损失权重，聚焦难样本（尾部）。  </li>
<li>公式：<code>FL(p_t) = -α_t (1 - p_t)^γ log(p_t)</code>，其中γ调节难易样本权重。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class FocalLoss(nn.Module):</span><br><span class="line">    def __init__(self, alpha=1.0, gamma=2.0):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.alpha = alpha  <span class="comment"># 类别平衡参数</span></span><br><span class="line">        self.gamma = gamma  <span class="comment"># 难易样本调节参数</span></span><br><span class="line"></span><br><span class="line">    def forward(self, inputs, targets):</span><br><span class="line">        ce_loss = nn.functional.cross_entropy(inputs, targets, reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">        pt = torch.exp(-ce_loss)  <span class="comment"># 模型对真实类别的预测概率</span></span><br><span class="line">        loss = self.alpha * (1 - pt) ** self.gamma * ce_loss</span><br><span class="line">        <span class="built_in">return</span> loss.mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">focal_loss = FocalLoss(alpha=[1.0, 2.0, 5.0, 10.0], gamma=2)  <span class="comment"># alpha可对不同类别加权</span></span><br><span class="line">loss = focal_loss(logits, targets)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>解耦训练（Decoupling）</strong>  <ul>
<li>先学习特征表示（均匀采样），再调整分类器（重采样或重加权）。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：均匀采样学习特征</span></span><br><span class="line">uniform_sampler = WeightedRandomSampler(</span><br><span class="line">    weights=torch.ones(len(dataset)),  <span class="comment"># 均匀权重</span></span><br><span class="line">    num_samples=len(dataset),</span><br><span class="line">    replacement=True</span><br><span class="line">)</span><br><span class="line">dataloader_stage1 = DataLoader(dataset, batch_size=32, sampler=uniform_sampler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：冻结特征层，调整分类器（使用类别加权损失）</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.feature_extractor.parameters():</span><br><span class="line">    param.requires_grad = False  <span class="comment"># 冻结特征层</span></span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss(weight=class_weights)  <span class="comment"># 使用加权损失</span></span><br><span class="line">optimizer = torch.optim.Adam(model.classifier.parameters(), lr=0.001)</span><br></pre></td></tr></table></figure></div>
<h2 id="3-模型结构改进"><a href="#3-模型结构改进" class="headerlink" title="3. 模型结构改进"></a>3. <strong>模型结构改进</strong></h2><ul>
<li><strong>解耦框架（Decoupling Framework）</strong>  <ul>
<li>如<strong>Decoupling</strong>（NeurIPS 2019）分离特征学习和分类器调整。</li>
</ul>
</li>
<li><strong>两阶段训练</strong>  <ul>
<li>第一阶段：正常训练；第二阶段：冻结骨干网络，微调分类器（使用重采样或加权）。</li>
</ul>
</li>
<li><strong>专家混合（Mixture of Experts, MoE）</strong>  <ul>
<li>为不同类别分配专用子模型（专家）。</li>
</ul>
</li>
</ul>
<h2 id="4-迁移学习-自监督学习"><a href="#4-迁移学习-自监督学习" class="headerlink" title="4. 迁移学习 &amp; 自监督学习"></a>4. <strong>迁移学习 &amp; 自监督学习</strong></h2><ul>
<li><strong>预训练 + 微调</strong>：在大规模平衡数据上预训练，再在长尾数据上微调。</li>
<li><strong>自监督学习</strong>：通过对比学习（如SimCLR）学习通用特征，减少对标签的依赖。</li>
</ul>
<h2 id="5-评估指标优化"><a href="#5-评估指标优化" class="headerlink" title="5. 评估指标优化"></a>5. <strong>评估指标优化</strong></h2><ul>
<li>避免单一准确率（Accuracy），采用更全面的指标：  <ul>
<li><strong>宏平均（Macro-F1）</strong>：各类别F1的均值，平等对待所有类别。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import f1_score</span><br><span class="line"></span><br><span class="line">def macro_f1(y_true, y_pred):</span><br><span class="line">    <span class="built_in">return</span> f1_score(y_true, y_pred, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">y_true = [0, 1, 2, 0, 1, 2]</span><br><span class="line">y_pred = [0, 1, 1, 0, 0, 2]</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Macro-F1: &#123;macro_f1(y_true, y_pred)&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>平衡准确率（Balanced Accuracy）</strong>：各类别召回率的均值。  </li>
<li><strong>AUC-ROC</strong>：衡量模型在不同阈值下的整体性能。</li>
</ul>
<h1 id="经典论文与模型"><a href="#经典论文与模型" class="headerlink" title="经典论文与模型"></a><strong>经典论文与模型</strong></h1><ul>
<li><strong>Decoupling</strong>（NeurIPS 2019）：解耦表示学习和分类器调整。  </li>
<li><strong>BBN</strong>（CVPR 2020）：双分支网络平衡重采样和原始分布。  </li>
<li><strong>Logit Adjustment</strong>（ICML 2020）：通过调整logit偏移解决类别不平衡。  </li>
<li><strong>Balanced Softmax</strong>（NeurIPS 2020）：修改Softmax适应长尾分布。</li>
</ul>
<h1 id="方向"><a href="#方向" class="headerlink" title="方向"></a><strong>方向</strong></h1><ul>
<li><strong>过拟合与泛化</strong>：尾部数据不足易导致过拟合，需更好的正则化或小样本学习技术。  </li>
<li><strong>动态长尾分布</strong>：现实世界中类别分布可能随时间变化（如热门商品更替）。  </li>
<li><strong>无监督长尾学习</strong>：探索自监督或半监督方法减少对标签的依赖。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import torchvision</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">from torch.utils.data import Subset</span><br><span class="line">import torch</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 CIFAR-10 原始训练集</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor()])</span><br><span class="line">train_dataset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=True, download=True, transform=transform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每类索引</span></span><br><span class="line">class_indices = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(10)]</span><br><span class="line"><span class="keyword">for</span> idx, (_, label) <span class="keyword">in</span> enumerate(train_dataset):</span><br><span class="line">    class_indices[label].append(idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人为制造长尾分布，例如类0有5000个样本，类9只有10个样本</span></span><br><span class="line">long_tail_counts = [5000, 2000, 1000, 500, 200, 100, 50, 30, 20, 10]</span><br><span class="line">selected_indices = []</span><br><span class="line"><span class="keyword">for</span> i, count <span class="keyword">in</span> enumerate(long_tail_counts):</span><br><span class="line">    selected_indices.extend(class_indices[i][:count])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建新的训练子集</span></span><br><span class="line">long_tail_dataset = Subset(train_dataset, selected_indices)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取子集标签</span></span><br><span class="line">labels = [train_dataset[i][1] <span class="keyword">for</span> i <span class="keyword">in</span> selected_indices]</span><br><span class="line">class_counts = np.bincount(labels, minlength=10)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每类样本数量：&quot;</span>, class_counts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算类别权重（样本越少权重越大）</span></span><br><span class="line">weights = 1.0 / (class_counts + 1e-6)</span><br><span class="line">weights = weights / weights.sum() * len(class_counts)</span><br><span class="line">class_weights = torch.FloatTensor(weights)</span><br><span class="line"></span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单CNN模型</span></span><br><span class="line">class SimpleCNN(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(3, 32, 3)</span><br><span class="line">        self.conv2 = nn.Conv2d(32, 64, 3)</span><br><span class="line">        self.fc1 = nn.Linear(64 * 6 * 6, 128)</span><br><span class="line">        self.fc2 = nn.Linear(128, 10)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = F.relu(self.conv1(x))    <span class="comment"># [batch, 32, 30, 30]</span></span><br><span class="line">        x = F.max_pool2d(x, 2)       <span class="comment"># [batch, 32, 15, 15]</span></span><br><span class="line">        x = F.relu(self.conv2(x))    <span class="comment"># [batch, 64, 13, 13]</span></span><br><span class="line">        x = F.max_pool2d(x, 2)       <span class="comment"># [batch, 64, 6, 6]</span></span><br><span class="line">        x = x.view(-1, 64 * 6 * 6)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="built_in">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用权重定义加权损失函数</span></span><br><span class="line">criterion = nn.CrossEntropyLoss(weight=class_weights)</span><br><span class="line"></span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">from torch import optim</span><br><span class="line"></span><br><span class="line">model = SimpleCNN()</span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=0.001)</span><br><span class="line">loader = DataLoader(long_tail_dataset, batch_size=64, shuffle=True)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(10):</span><br><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> loader:</span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;Epoch &#123;epoch&#125;: loss = &#123;loss.item():.4f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Epoch 0: loss &#x3D; 1.9016<br>Epoch 1: loss &#x3D; 1.7739<br>Epoch 2: loss &#x3D; 1.4057<br>Epoch 3: loss &#x3D; 1.8090<br>Epoch 4: loss &#x3D; 1.6333<br>Epoch 5: loss &#x3D; 1.5193<br>Epoch 6: loss &#x3D; 0.8202<br>Epoch 7: loss &#x3D; 0.5897<br>Epoch 8: loss &#x3D; 0.7408<br>Epoch 9: loss &#x3D; 1.2246</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂互补松弛性--从册那到不册那</title>
    <url>/zhihaojiang.github.io/2025/06/02/202505026%E5%88%86%E9%92%9F%E6%90%9E%E6%87%82%E4%BA%92%E8%A1%A5%E6%9D%BE%E5%BC%9B%E6%80%A7--%E4%BB%8E%E5%86%8C%E9%82%A3%E5%88%B0%E4%B8%8D%E5%86%8C%E9%82%A3/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YA7kzAEgQ?vd_source=bc448494c13de3dddfcff371ac637813"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/02/001.png"
                      alt="点击观看视频"
                ></a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>Extrovert vs. Introvert Behavior Data</title>
    <url>/zhihaojiang.github.io/2025/06/04/20250604Extrovert%20vs.%20Introvert%20Behavior%20Data/</url>
    <content><![CDATA[<h1 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h1><p><a class="link"   href="https://www.kaggle.com/datasets/rakeshkapilavai/extrovert-vs-introvert-behavior-data/data" >https://www.kaggle.com/datasets/rakeshkapilavai/extrovert-vs-introvert-behavior-data/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>关于数据集<br>概述</p>
<p>深入研究“外向与内向性格特征数据集”，这是一个丰富的行为和社交数据集合，旨在探索人类性格谱系。该数据集涵盖了外向和内向的关键指标，是心理学家、数据科学家以及研究社会行为、性格预测或数据预处理技术的研究人员的宝贵资源。</p>
<p>语境</p>
<p>外向和内向等性格特征塑造了个体与社交环境的互动方式。该数据集提供了对个人行为的洞察，例如独处时间、社交活动参与度以及社交媒体参与度，从而为心理学、社会学、市场营销和机器学习等领域的应用提供支持。无论您是预测性格类型还是分析社交模式，该数据集都能助您发现引人入胜的洞见。</p>
<p>数据集详细信息</p>
<p>大小：数据集包含 2,900 行和 8 列。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br></pre></td></tr></table></figure></div>

<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;personality_dataset.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Index([‘Time_spent_Alone’, ‘Stage_fear’, ‘Social_event_attendance’,<br>       ‘Going_outside’, ‘Drained_after_socializing’, ‘Friends_circle_size’,<br>       ‘Post_frequency’, ‘Personality’],<br>      dtype&#x3D;’object’)</p>
</blockquote>
<ul>
<li>Time_spent_Alone: 独处时间 – 一个人每天通常独自度过的小时数</li>
<li>Stage_fear: 舞台恐惧 – 是否经历过舞台恐惧症</li>
<li>Social_event_attendance: 社交活动出席率 – 参加社交活动的频率（0-10 级）</li>
<li>Going_outside: 外出 – 个人外出的频率（0-10 级）</li>
<li>Drained_after_socializing:社交后精疲力竭 – 社交后是否感觉精疲力尽</li>
<li>Friends_circle_size:好友圈大小 – 亲密朋友数量</li>
<li>Post_frequency:帖子频率 – 在社交媒体上发帖的频率</li>
<li>Personality: 性格 – 目标变量：内向或外向</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>&lt;class ‘pandas.core.frame.DataFrame’&gt;<br>RangeIndex: 2900 entries, 0 to 2899<br>Data columns (total 8 columns):</p>
<h1 id="Column-Non-Null-Count-Dtype"><a href="#Column-Non-Null-Count-Dtype" class="headerlink" title="Column                     Non-Null Count  Dtype"></a>Column                     Non-Null Count  Dtype</h1><hr>
<p> 0   Time_spent_Alone           2837 non-null   float64<br> 1   Stage_fear                 2827 non-null   object<br> 2   Social_event_attendance    2838 non-null   float64<br> 3   Going_outside              2834 non-null   float64<br> 4   Drained_after_socializing  2848 non-null   object<br> 5   Friends_circle_size        2823 non-null   float64<br> 6   Post_frequency             2835 non-null   float64<br> 7   Personality                2900 non-null   object<br>dtypes: float64(5), object(3)<br>memory usage: 181.4+ KB</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/002.png"
                      alt="photo"
                ></p>
<h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Time_spent_Alone             63<br>Stage_fear                   73<br>Social_event_attendance      62<br>Going_outside                66<br>Drained_after_socializing    52<br>Friends_circle_size          77<br>Post_frequency               65<br>Personality                   0<br>dtype: int64</p>
</blockquote>
<p>数值型用均值填充<br>类别型用众数填充</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">df</span>[col].dtype == <span class="string">&#x27;object&#x27;</span>:</span><br><span class="line">        <span class="built_in">df</span>[col] = <span class="built_in">df</span>[col].fillna(<span class="built_in">df</span>[col].mode()[0])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">df</span>[col] = <span class="built_in">df</span>[col].fillna(<span class="built_in">df</span>[col].mean())</span><br></pre></td></tr></table></figure></div>

<h2 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Stage_fear&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;Stage_fear&#x27;</span>].map(&#123;<span class="string">&#x27;Yes&#x27;</span>: 1, <span class="string">&#x27;No&#x27;</span>: 0&#125;)</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Drained_after_socializing&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;Drained_after_socializing&#x27;</span>].map(&#123;<span class="string">&#x27;Yes&#x27;</span>: 1, <span class="string">&#x27;No&#x27;</span>: 0&#125;)</span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Personality&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;Personality&#x27;</span>].map(&#123;<span class="string">&#x27;Introvert&#x27;</span>: 0, <span class="string">&#x27;Extrovert&#x27;</span>: 1&#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="异常值检测"><a href="#异常值检测" class="headerlink" title="异常值检测"></a>异常值检测</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    Q1 = <span class="built_in">df</span>[col].quantile(0.25)</span><br><span class="line">    Q3 = <span class="built_in">df</span>[col].quantile(0.75)</span><br><span class="line">    IQR = Q3 - Q1</span><br><span class="line">    lower_bound = Q1 - 1.5 * IQR</span><br><span class="line">    upper_bound = Q3 + 1.5 * IQR</span><br><span class="line">    outliers = <span class="built_in">df</span>[(<span class="built_in">df</span>[col] &gt;= lower_bound) &amp; (<span class="built_in">df</span>[col] &lt;= upper_bound)]</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;列&#123;col&#125;的异常值:&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>列Time_spent_Alone的异常值:<br>列Stage_fear的异常值:<br>列Social_event_attendance的异常值:<br>列Going_outside的异常值:<br>列Drained_after_socializing的异常值:<br>列Friends_circle_size的异常值:<br>列Post_frequency的异常值:<br>列Personality的异常值:</p>
</blockquote>
<p>说明没有异常值 我们通过箱线图也没发现异常值</p>
<h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><h3 id="工具代码"><a href="#工具代码" class="headerlink" title="工具代码"></a>工具代码</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def pairwise_plot(</span><br><span class="line">    <span class="built_in">df</span>: pd.DataFrame,</span><br><span class="line">    features: list,</span><br><span class="line">    plot_type: str = <span class="string">&#x27;scatter&#x27;</span>,  <span class="comment"># 可选: &#x27;scatter&#x27;, &#x27;box&#x27;, &#x27;bar&#x27;, &#x27;violin&#x27;, &#x27;hist&#x27;</span></span><br><span class="line">    hue: str = None,</span><br><span class="line">    max_per_figure: int = 9,</span><br><span class="line">    figsize: tuple = (15, 12),</span><br><span class="line">    fill: bool = None,</span><br><span class="line">    save: bool = False,</span><br><span class="line">    save_prefix: str = <span class="string">&quot;pairplot&quot;</span></span><br><span class="line">):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    批量绘制特征两两组合的图表，每张大图包含最多9张子图。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    - df: DataFrame 数据</span></span><br><span class="line"><span class="string">    - features: 要组合的特征列名列表</span></span><br><span class="line"><span class="string">    - plot_type: 图表类型：&#x27;scatter&#x27;, &#x27;box&#x27;, &#x27;violin&#x27;, &#x27;hist&#x27;, &#x27;kde&#x27;, &#x27;bar&#x27;</span></span><br><span class="line"><span class="string">    - fill: 是否填充 KDE 图（仅适用于 &#x27;kde&#x27; 类型）</span></span><br><span class="line"><span class="string">    - hue: 分类变量（可选）</span></span><br><span class="line"><span class="string">    - max_per_figure: 每页最多显示几个子图</span></span><br><span class="line"><span class="string">    - figsize: 每张图的整体大小</span></span><br><span class="line"><span class="string">    - save: 是否保存图像</span></span><br><span class="line"><span class="string">    - save_prefix: 图像保存的前缀</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    import itertools</span><br><span class="line">    import math</span><br><span class="line">    import matplotlib.pyplot as plt</span><br><span class="line">    import seaborn as sns</span><br><span class="line">    combs = list(itertools.combinations(features, 2))</span><br><span class="line">    total_figures = math.ceil(len(combs) / max_per_figure)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fig_idx <span class="keyword">in</span> range(total_figures):</span><br><span class="line">        fig, axs = plt.subplots(3, 3, figsize=figsize)</span><br><span class="line">        axs = axs.flatten()</span><br><span class="line">        start = fig_idx * max_per_figure</span><br><span class="line">        end = start + max_per_figure</span><br><span class="line">        current_combs = combs[start:end]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ax_idx, (x, y) <span class="keyword">in</span> enumerate(current_combs):</span><br><span class="line">            ax = axs[ax_idx]</span><br><span class="line">            <span class="keyword">if</span> plot_type == <span class="string">&#x27;scatter&#x27;</span>:</span><br><span class="line">                sns.scatterplot(data=<span class="built_in">df</span>, x=x, y=y, hue=hue, ax=ax)</span><br><span class="line">            <span class="keyword">elif</span> plot_type == <span class="string">&#x27;box&#x27;</span>:</span><br><span class="line">                sns.boxplot(data=<span class="built_in">df</span>, x=x, y=y, hue=hue, ax=ax)</span><br><span class="line">            <span class="keyword">elif</span> plot_type == <span class="string">&#x27;violin&#x27;</span>:</span><br><span class="line">                sns.violinplot(data=<span class="built_in">df</span>, x=x, y=y, hue=hue, ax=ax)</span><br><span class="line">            <span class="keyword">elif</span> plot_type == <span class="string">&#x27;bar&#x27;</span>:</span><br><span class="line">                sns.barplot(data=<span class="built_in">df</span>, x=x, y=y, hue=hue, ax=ax)</span><br><span class="line">            <span class="keyword">elif</span> plot_type == <span class="string">&#x27;hist&#x27;</span>:</span><br><span class="line">                sns.histplot(data=<span class="built_in">df</span>, x=x, hue=hue, ax=ax, kde=True)</span><br><span class="line">            <span class="keyword">elif</span> plot_type == <span class="string">&#x27;kde&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> hue :</span><br><span class="line">                    <span class="keyword">for</span> label <span class="keyword">in</span> <span class="built_in">df</span>[hue].dropna().unique():</span><br><span class="line">                            subset = <span class="built_in">df</span>[<span class="built_in">df</span>[hue] == label]</span><br><span class="line">                            sns.kdeplot(data=subset, x=x, y=y, ax=ax, fill=fill, label=str(label), alpha=0.5)</span><br><span class="line">                            ax.legend()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sns.kdeplot(data=<span class="built_in">df</span>, x=x, y=y, ax=ax, fill=fill)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ax.set_title(f<span class="string">&quot;Unsupported plot type: &#123;plot_type&#125;&quot;</span>)</span><br><span class="line">            ax.set_title(f<span class="string">&quot;&#123;y&#125; vs &#123;x&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 隐藏多余的子图</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(current_combs), max_per_figure):</span><br><span class="line">            fig.delaxes(axs[j])</span><br><span class="line"></span><br><span class="line">        plt.tight_layout()</span><br><span class="line">        <span class="keyword">if</span> save:</span><br><span class="line">            plt.savefig(f<span class="string">&quot;&#123;save_prefix&#125;_&#123;fig_idx+1&#125;.png&quot;</span>, dpi=300)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure></div>

<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.pairplot(<span class="built_in">df</span>, diag_kind=<span class="string">&#x27;hist&#x27;</span>, hue=<span class="string">&#x27;Personality&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">&#x27;Pair Plot of Numeric Features by Personality&#x27;</span>, y=1.02)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/003.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pairwise_plot(<span class="built_in">df</span>, df.columns, plot_type=<span class="string">&#x27;hist&#x27;</span>, hue=<span class="string">&#x27;Personality&#x27;</span>, max_per_figure=9)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/004.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/005.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/006.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/007.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pairwise_plot(<span class="built_in">df</span>, df.columns, plot_type=<span class="string">&#x27;scatter&#x27;</span>, hue=<span class="string">&#x27;Personality&#x27;</span>, max_per_figure=9)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/008.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/009.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/010.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/011.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pairwise_plot(<span class="built_in">df</span>, df.columns, plot_type=<span class="string">&#x27;kde&#x27;</span>, max_per_figure=9)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/012.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/013.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/014.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/015.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.corr()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/04/016.png"
                      alt="photo"
                ></p>
<p>我们发现这些变量与目标变量的相关性的绝对值均大于0.6 说明这些特征都很重要 从上面的可视化结果来看也是如此</p>
<h2 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X = df.drop(<span class="string">&#x27;Personality&#x27;</span>, axis=1)</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;Personality&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br></pre></td></tr></table></figure></div>

<h2 id="标准化-模型训练"><a href="#标准化-模型训练" class="headerlink" title="标准化+模型训练"></a>标准化+模型训练</h2><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.svm import SVC</span><br><span class="line">from sklearn.metrics import accuracy_score, classification_report, confusion_matrix</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;scaler&#x27;</span>, StandardScaler()),</span><br><span class="line">    (<span class="string">&#x27;svm&#x27;</span>, SVC(kernel=<span class="string">&#x27;linear&#x27;</span>))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">pipeline.fit(X_train, y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y_pred = pipeline.predict(X_test)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>0.9293103448275862<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.92      0.94      0.93       278
       1       0.94      0.92      0.93       302

accuracy                           0.93       580
</code></pre>
<p>   macro avg       0.93      0.93      0.93       580<br>weighted avg       0.93      0.93      0.93       580<br>[[261  17]<br> [ 24 278]]</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.svm import SVC</span><br><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建Pipeline</span></span><br><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;scaler&#x27;</span>, StandardScaler()),</span><br><span class="line">    (<span class="string">&#x27;svm&#x27;</span>, SVC())</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;svm__C&#x27;</span>: [0.1, 1, 10],</span><br><span class="line">    <span class="string">&#x27;svm__kernel&#x27;</span>: [<span class="string">&#x27;linear&#x27;</span>, <span class="string">&#x27;rbf&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;svm__gamma&#x27;</span>: [<span class="string">&#x27;scale&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grid_search = GridSearchCV(pipeline, param_grid, cv=5)</span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(grid_search.best_params_)</span><br><span class="line"><span class="built_in">print</span>(grid_search.best_score_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_pred = grid_search.predict(X_test)</span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>{‘svm__C’: 0.1, ‘svm__gamma’: ‘scale’, ‘svm__kernel’: ‘rbf’}<br>0.9357758620689655<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.92      0.94      0.93       278
       1       0.94      0.92      0.93       302

accuracy                           0.93       580
</code></pre>
<p>   macro avg       0.93      0.93      0.93       580<br>weighted avg       0.93      0.93      0.93       580<br>[[261  17]<br> [ 24 278]]</p>
</blockquote>
<h3 id="XGboost"><a href="#XGboost" class="headerlink" title="XGboost"></a>XGboost</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from xgboost import XGBClassifier</span><br><span class="line">XGB = XGBClassifier()</span><br><span class="line">XGB.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = XGB.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;XGBoost Accuracy:&quot;</span>, accuracy_score(y_test, y_pred))</span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>XGBoost Accuracy: 0.9172413793103448<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.90      0.93      0.91       278
       1       0.93      0.91      0.92       302

accuracy                           0.92       580
</code></pre>
<p>   macro avg       0.92      0.92      0.92       580<br>weighted avg       0.92      0.92      0.92       580</p>
<p>[[258  20]<br> [ 28 274]]</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;XGB&#x27;</span>, XGBClassifier(use_label_encoder=False, eval_metric=<span class="string">&#x27;logloss&#x27;</span>)),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;XGB__max_depth&#x27;</span>: [3, 5, 7],</span><br><span class="line">    <span class="string">&#x27;XGB__learning_rate&#x27;</span>: [0.01, 0.1, 0.2],</span><br><span class="line">    <span class="string">&#x27;XGB__n_estimators&#x27;</span>: [50, 100, 200],</span><br><span class="line">    <span class="string">&#x27;XGB__subsample&#x27;</span>: [0.8, 1.0],</span><br><span class="line">    <span class="string">&#x27;XGB__colsample_bytree&#x27;</span>: [0.8, 1.0],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring=<span class="string">&#x27;recall&#x27;</span>)</span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(grid_search.best_params_)</span><br><span class="line"><span class="built_in">print</span>(grid_search.best_score_)</span><br><span class="line"></span><br><span class="line">y_pred = grid_search.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Accuracy: &#123;accuracy&#125;&quot;</span>)</span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Accuracy: 0.9293103448275862<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.92      0.94      0.93       278
       1       0.94      0.92      0.93       302

accuracy                           0.93       580
</code></pre>
<p>   macro avg       0.93      0.93      0.93       580<br>weighted avg       0.93      0.93      0.93       580</p>
<p>[[261  17]<br> [ 24 278]]</p>
</blockquote>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line"></span><br><span class="line">rf = RandomForestClassifier(n_estimators=100, random_state=42)</span><br><span class="line">rf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = rf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random Forest Accuracy:&quot;</span>, accuracy_score(y_test, y_pred))</span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>Random Forest Accuracy: 0.9224137931034483<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.91      0.93      0.92       278
       1       0.94      0.91      0.92       302

accuracy                           0.92       580
</code></pre>
<p>   macro avg       0.92      0.92      0.92       580<br>weighted avg       0.92      0.92      0.92       580</p>
<p>[[259  19]<br> [ 26 276]]</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;rf&#x27;</span>, RandomForestClassifier(random_state=42)),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;rf__n_estimators&#x27;</span>: [50, 100, 200],</span><br><span class="line">    <span class="string">&#x27;rf__max_depth&#x27;</span>: [None, 10, 20, 30],</span><br><span class="line">    <span class="string">&#x27;rf__min_samples_split&#x27;</span>: [2, 5, 10],</span><br><span class="line">    <span class="string">&#x27;rf__min_samples_leaf&#x27;</span>: [1, 2, 4],</span><br><span class="line">&#125;</span><br><span class="line">grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring=<span class="string">&#x27;accuracy&#x27;</span>, n_jobs=-1)</span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line">best_model = grid_search.best_estimator_</span><br><span class="line"></span><br><span class="line">y_pred = best_model.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;Best Random Forest Accuracy: &#123;accuracy&#125;&quot;</span>)</span><br><span class="line">report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(report)</span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Best Random Forest Accuracy: 0.9293103448275862<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.92      0.94      0.93       278
       1       0.94      0.92      0.93       302

accuracy                           0.93       580
</code></pre>
<p>   macro avg       0.93      0.93      0.93       580<br>weighted avg       0.93      0.93      0.93       580</p>
<p>[[261  17]<br> [ 24 278]]</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们通过可视化图表可以看到 数据的分布呈现集中分布 说明特征与特征之间的关系较为紧密 说明内向与外向的人他们具有明显的区分度</p>
<p>SVM的准确率为：0.9357758620689655<br>预测的召回率为：0.93</p>
<p>其中预测内向的召回率为：0.94<br>其中预测外向的召回率为：0.92<br>说明其对内向的确诊率较高</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Global Internet Adoption &amp; Digital Growth Analysis</title>
    <url>/zhihaojiang.github.io/2025/06/05/20250605Global%20Internet%20Adoption%20&amp;%20Digital%20Growth%20Analysis/</url>
    <content><![CDATA[<h1 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h1><p><a class="link"   href="https://www.kaggle.com/datasets/sudipde25/global-internet-adoption-trends/data" >https://www.kaggle.com/datasets/sudipde25/global-internet-adoption-trends/data<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>此数据集主要为探索 以可视化为主</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"><span class="comment"># 设置字体路径</span></span><br><span class="line">font_path = <span class="string">&#x27;/System/Library/Fonts/STHeiti Medium.ttc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载字体</span></span><br><span class="line">my_font = font_manager.FontProperties(fname=font_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = my_font.get_name()</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = False  <span class="comment"># 正确显示负号</span></span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;#d7fbe8&#x27;</span>,<span class="string">&#x27;#9df3c4&#x27;</span>,<span class="string">&#x27;#62d2a2&#x27;</span>,<span class="string">&#x27;#1fab89&#x27;</span>,<span class="string">&#x27;#a6d0e4&#x27;</span>, <span class="string">&#x27;#f9ffea&#x27;</span>, <span class="string">&#x27;#ffecda&#x27;</span>, <span class="string">&#x27;#d4a5a5&#x27;</span>, <span class="string">&#x27;#fbafaf&#x27;</span>, <span class="string">&#x27;#f2c6b4&#x27;</span>, <span class="string">&#x27;#f3e8cb&#x27;</span>, <span class="string">&#x27;#99e1e5&#x27;</span>]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Country 国家</li>
<li>Date 日期</li>
<li>Internet_Penetration (%) 互联网普及率（%）</li>
<li>Broadband_Speed (Mbps) 宽带速度（Mbps）</li>
<li>GDP_Per_Capita (USD) 人均GDP（美元）</li>
<li>Education_Level (%) 教育水平（%）</li>
<li>Mobile_Data_Usage (GB) 移动数据使用量（GB）</li>
<li>Digital_Investment (M USD) 数字投资（百万美元）</li>
<li>Digital_Literacy (%) 数字素养（%）</li>
<li>X_Sentiment_Score X情绪评分</li>
<li>5G_Rollout 5G部署</li>
<li>Urban_Rural 城乡（城市&#x2F;农村）</li>
<li>Latitude 纬度</li>
<li>Longitude 经度</li>
<li>Anomaly 异常</li>
</ul>
<h1 id="分析每月数据"><a href="#分析每月数据" class="headerlink" title="分析每月数据"></a>分析每月数据</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_csv(<span class="string">&#x27;global_internet_adoption_monthly_2010_2025_with_clusters.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">df</span>[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(<span class="built_in">df</span>[<span class="string">&#x27;Date&#x27;</span>])</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.pairplot(<span class="built_in">df</span>, diag_kind=<span class="string">&#x27;hist&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">&#x27;EDA&#x27;</span>, y=1.02)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/001.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选出所有数值型列（排除 &#x27;Country&#x27;）</span></span><br><span class="line">num_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> df.columns <span class="keyword">if</span> <span class="built_in">df</span>[col].dtype <span class="keyword">in</span> [<span class="string">&#x27;float64&#x27;</span>, <span class="string">&#x27;int64&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置子图布局（比如每行显示2个图）</span></span><br><span class="line">n_cols = 3</span><br><span class="line">n_rows = math.ceil(len(num_cols) / n_cols)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图尺寸</span></span><br><span class="line">fig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 5 * n_rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若 axes 是 1D，需要变成 2D 统一处理</span></span><br><span class="line">axes = axes.flatten()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> enumerate(num_cols):</span><br><span class="line">    sns.boxplot(data=<span class="built_in">df</span>, x=<span class="string">&#x27;Country&#x27;</span>, y=col, ax=axes[i], palette=colors)</span><br><span class="line">    axes[i].set_title(col)</span><br><span class="line">    axes[i].tick_params(axis=<span class="string">&#x27;x&#x27;</span>, rotation=45)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多余的子图隐藏</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+1, len(axes)):</span><br><span class="line">    fig.delaxes(axes[j])</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/002.png"
                      alt="photo"
                ></p>
<p>上述是不同国家的互联网相关的各项数据的箱线图</p>
<ul>
<li>从互联网普及率来看 中国 美国和德国的互联网普及率在一个水平 其他国家的在另一个水平 说明中国 美国和德国的互联网普及率较其他国家领先</li>
<li>从宽带速度来看 各国的宽带速度有差别 但差别不算太大</li>
<li>从国家GDP来看 各国的GDP的差别较大</li>
<li>从教育水平来看 各国的教育水平有差别 与互联网普及率的关系不大</li>
<li>从移动数据使用量来看 各国的移动数据使用量基本一致</li>
<li>从数字投资来看 各国的数字投资有差别 其中美国的数字投资最高 个人认为由于美国的互联网发展最早 了解其中的的投资回报率 并且可以投资的资金十分丰厚 所以其数字投资最高 第二高的是中国 由于中国作为世界第二大经济体 也了解其中的投资回报率 第三高的是南非 作为一个非洲国家 其互联网发展较晚 但是却有如此的投资 应该是因为作为一个发展中国家 要想在国际市场上获得成功 其要抓住机会 因此政府大力投资</li>
<li>从数字素养来看 各国的数字素养有差别 数字素养的高低反应了国家互联网发展水平与先后关系</li>
<li>从X情绪评分来看 各国的X情绪评分几乎一致</li>
<li>从5G部署来看 各国的5G部署有差别 只有中国、美国和德国全面部署了5G 由于5G的部署需要大量的投资 因此只有少数国家负担得起 其他国家那些有5G的应该是私人部署</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import plotly.express as px</span><br><span class="line"></span><br><span class="line">fig = px.line(<span class="built_in">df</span>, x=<span class="string">&#x27;Date&#x27;</span>, y=<span class="string">&#x27;Internet_Penetration (%)&#x27;</span>, color=<span class="string">&#x27;Country&#x27;</span>,</span><br><span class="line">              title=<span class="string">&#x27;Internet Penetration Over Time&#x27;</span>,</span><br><span class="line">              labels=&#123;<span class="string">&#x27;Internet_Penetration (%)&#x27;</span>: <span class="string">&#x27;Internet Penetration (%)&#x27;</span>, <span class="string">&#x27;Date&#x27;</span>: <span class="string">&#x27;Date&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图例放到图外右侧</span></span><br><span class="line">fig.update_layout(</span><br><span class="line">    legend_title_text=<span class="string">&#x27;Country&#x27;</span>,</span><br><span class="line">    legend=dict(</span><br><span class="line">        x=1.05,</span><br><span class="line">        y=1,</span><br><span class="line">        xanchor=<span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">        yanchor=<span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">        bgcolor=<span class="string">&#x27;rgba(0,0,0,0)&#x27;</span>,  <span class="comment"># 图例背景透明</span></span><br><span class="line">    ),</span><br><span class="line">    margin=dict(r=150)  <span class="comment"># 右边距留够空间放图例</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/003.png"
                      alt="photo"
                ></p>
<p>可以看到 随着时间的推移 互联网的普及率呈现阶梯式上升的趋势</p>
<p>不同国家的互联网普及率也有一定的差异 这是由于国家的发展导致的 有些国家发展得早 互联网普及率就高一些 有些国家发展得晚 互联网普及率就低一些</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(2, 2, figsize=(14, 10))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 城乡互联网渗透率</span></span><br><span class="line">ax1 = axes[0, 0]</span><br><span class="line">sns.lineplot(data=<span class="built_in">df</span>, x=<span class="string">&#x27;Date&#x27;</span>, y=<span class="string">&#x27;Internet_Penetration (%)&#x27;</span>,</span><br><span class="line">             hue=<span class="string">&#x27;Urban_Rural&#x27;</span>, ci=None, ax=ax1)</span><br><span class="line">ax1.set_title(<span class="string">&quot;城乡互联网渗透率&quot;</span>)</span><br><span class="line">ax1.legend(title=<span class="string">&#x27;Urban/Rural&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字投资 vs GDP</span></span><br><span class="line">ax2 = axes[0, 1]</span><br><span class="line">sns.scatterplot(data=<span class="built_in">df</span>, x=<span class="string">&#x27;GDP_Per_Capita (USD)&#x27;</span>, y=<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>,</span><br><span class="line">                hue=<span class="string">&#x27;Country&#x27;</span>, ax=ax2, legend=False)</span><br><span class="line">ax2.set_title(<span class="string">&quot;数字投资与人均GDP的关系&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各国互联网渗透率分布</span></span><br><span class="line">ax3 = axes[1, 0]</span><br><span class="line">sns.violinplot(data=<span class="built_in">df</span>, x=<span class="string">&#x27;Country&#x27;</span>, y=<span class="string">&#x27;Internet_Penetration (%)&#x27;</span>,</span><br><span class="line">               palette=colors, ax=ax3)</span><br><span class="line">ax3.set_title(<span class="string">&quot;各国互联网渗透率分布&quot;</span>)</span><br><span class="line">ax3.tick_params(axis=<span class="string">&#x27;x&#x27;</span>, rotation=45)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼图</span></span><br><span class="line">ax4 = axes[1, 1]</span><br><span class="line">investment_by_country = df.groupby(<span class="string">&#x27;Country&#x27;</span>)[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">top10 = investment_by_country.sort_values(ascending=False).<span class="built_in">head</span>(10)</span><br><span class="line"></span><br><span class="line">ax4.pie(top10,</span><br><span class="line">        labels=top10.index,</span><br><span class="line">        autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>,</span><br><span class="line">        startangle=140,</span><br><span class="line">        colors=colors[:10],</span><br><span class="line">        wedgeprops=&#123;<span class="string">&#x27;edgecolor&#x27;</span>: <span class="string">&#x27;white&#x27;</span>&#125;)</span><br><span class="line">ax4.set_title(<span class="string">&quot;国家数字投资占比&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/004.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import plotly.express as px</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df_map = df.groupby(<span class="string">&#x27;Country&#x27;</span>, as_index=False)[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">df_map[<span class="string">&#x27;Investment (%)&#x27;</span>] = df_map[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>] / df_map[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>].<span class="built_in">sum</span>() * 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Plotly 画 Choropleth 地图</span></span><br><span class="line">fig = px.choropleth(df_map,</span><br><span class="line">                    locations=<span class="string">&#x27;Country&#x27;</span>,</span><br><span class="line">                    locationmode=<span class="string">&#x27;country names&#x27;</span>,</span><br><span class="line">                    color=<span class="string">&#x27;Investment (%)&#x27;</span>,</span><br><span class="line">                    hover_name=<span class="string">&#x27;Country&#x27;</span>,</span><br><span class="line">                    color_continuous_scale=<span class="string">&#x27;Blues&#x27;</span>,</span><br><span class="line">                    title=<span class="string">&#x27;各国数字投资占比（%）&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.update_geos(showframe=False, showcoastlines=False)</span><br><span class="line">fig.update_layout(margin=&#123;<span class="string">&quot;r&quot;</span>:0,<span class="string">&quot;t&quot;</span>:50,<span class="string">&quot;l&quot;</span>:0,<span class="string">&quot;b&quot;</span>:0&#125;)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/005.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import plotly.express as px</span><br><span class="line">import plotly.graph_objects as go</span><br><span class="line">from plotly.subplots import make_subplots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">investment_by_country = df.groupby(<span class="string">&#x27;Country&#x27;</span>)[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">top10 = investment_by_country.sort_values(ascending=False).<span class="built_in">head</span>(10)</span><br><span class="line">top10_percent = top10 / top10.sum() * 100  <span class="comment"># 转为百分比</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df_map = investment_by_country.reset_index()</span><br><span class="line">df_map[<span class="string">&#x27;Percent&#x27;</span>] = df_map[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>] / df_map[<span class="string">&#x27;Digital_Investment (M USD)&#x27;</span>].<span class="built_in">sum</span>() * 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 subplot: 1行2列，第1列地图，第2列饼图</span></span><br><span class="line">fig = make_subplots(rows=1, cols=2, </span><br><span class="line">                    column_widths=[0.6, 0.4],</span><br><span class="line">                    specs=[[&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;choropleth&quot;</span>&#125;, &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;domain&quot;</span>&#125;]],</span><br><span class="line">                    subplot_titles=(<span class="string">&quot;各国数字投资地图&quot;</span>, <span class="string">&quot;前10国家投资占比饼图&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map_fig = px.choropleth(df_map,</span><br><span class="line">                        locations=<span class="string">&#x27;Country&#x27;</span>,</span><br><span class="line">                        locationmode=<span class="string">&#x27;country names&#x27;</span>,</span><br><span class="line">                        color=<span class="string">&#x27;Percent&#x27;</span>,</span><br><span class="line">                        color_continuous_scale=<span class="string">&#x27;Blues&#x27;</span>,</span><br><span class="line">                        hover_name=<span class="string">&#x27;Country&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> trace <span class="keyword">in</span> map_fig.data:</span><br><span class="line">    fig.add_trace(trace, row=1, col=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig.add_trace(go.Pie(</span><br><span class="line">    labels=top10.index,</span><br><span class="line">    values=top10.values,</span><br><span class="line">    hole=0,  </span><br><span class="line">    textinfo=<span class="string">&#x27;percent+label&#x27;</span>,</span><br><span class="line">    marker=dict(colors=colors),</span><br><span class="line">), row=1, col=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig.update_layout(</span><br><span class="line">    title_text=<span class="string">&quot;数字投资地图 + Top10 国家饼图&quot;</span>,</span><br><span class="line">    showlegend=False,</span><br><span class="line">    margin=dict(t=60, l=30, r=30)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/006.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(6, 5))</span><br><span class="line">sns.heatmap(df.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).corr(), annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>, square=True)</span><br><span class="line">plt.title(<span class="string">&quot;变量相关性热力图&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/05/007.png"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模论文</title>
    <url>/zhihaojiang.github.io/2025/06/06/20250606%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>学院</th>
<th>班级</th>
<th>姓名</th>
</tr>
</thead>
<tbody><tr>
<td>数据科学学院</td>
<td>大数据231</td>
<td>陈佳妮</td>
</tr>
<tr>
<td>数据科学学院</td>
<td>大数据231</td>
<td>许薇</td>
</tr>
<tr>
<td>数据科学学院</td>
<td>大数据232</td>
<td>姜智浩</td>
</tr>
<tr>
<td>数据科学学院</td>
<td>大数据232</td>
<td>马子楦</td>
</tr>
<tr>
<td>数据科学学院</td>
<td>大数据232</td>
<td>王靖侃</td>
</tr>
</tbody></table>
<h1 id="一、问题重述"><a href="#一、问题重述" class="headerlink" title="一、问题重述"></a>一、问题重述</h1><p>青少年时期是人生发展的重要阶段，良好的饮食习惯对学生的知识学习和身体发育具有深远影响。然而当前学生群体普遍存在饮食结构不合理的问题，主要表现为早餐质量不佳、过度依赖外卖快餐以及不科学的节食行为等。这些不良饮食习惯可能导致营养摄入不均衡，进而影响学生的健康状态和学习效率。针对这一现状，本研究基于科学营养学原理，旨在通过系统性的饮食评估和优化设计，帮助学生建立更加合理的膳食结构。<br>根据题目和所提供附件，建立合理的数学模型解决以下问题<br><strong>问题1. 饮食营养分析与调整</strong><br>对两份提供的日常饮食记录进行全面营养评价。通过参照健康饮食的基本标准和营养素参考摄入量，系统评估其饮食结构的合理性。在完成评价后，将根据评价结果给出针对性的调整建议。<br><strong>问题2. 日常健康饮食的优化设计</strong><br>在完成基础评价后，本研究将重点探讨三种不同优化目标的饮食方案设计。第一种方案以蛋白质氨基酸评分最大化为核心目标，着重提升饮食的营养质量，确保优质蛋白质的摄入。第二种方案以经济性为导向，在保证基本营养需求的前提下实现成本最小化。第三种方案设计一个综合优化模型，同时考虑蛋白质氨基酸评分和成本效益。最后，通过对这三种优化模型的比较分析，从营养达标率、经济成本、可行性等多个维度进行综合评估，为不同需求的学生提供个性化的膳食建议。</p>
<h1 id="二、基本假设"><a href="#二、基本假设" class="headerlink" title="二、基本假设"></a>二、基本假设</h1><p>为了方便模型的建立与模型的可行性，这里首先对模型提出一些假设，使得模型更加完备，预测的结果更加合理。</p>
<ol>
<li>假设附件1-4提供的数据（如食物成分、价格、营养素推荐量）准确可靠，可直接用于建模。</li>
<li>在食谱设计时，忽略食物在存储和烹饪过程中可能发生的营养成分损失，假设食物的营养成分与原材料表中的数据一致。</li>
<li>假设每日的餐次固定，例如早餐、午餐、晚餐，每餐的能量分配比例固定，便于食谱的规范化设计.</li>
<li>所有食谱设计都必须满足大学生的基本营养需求，包括蛋白质、脂肪、碳水化合物、维生素和矿物质的日推荐摄入量。</li>
<li>食谱的总成本应适合学生的经济能力，确保食谱的经济可行性。</li>
<li>在模型设计时，假设所有大学生的营养需求和偏好是均一的，不考虑个体之间的生理差异和个人偏好。</li>
<li>假设食堂提供的所有食物（附件3）均可无限量供应，且价格稳定。</li>
<li>假设食物成本仅考虑食材价格，忽略加工、人力等附加成本。</li>
<li>假设每日饮食方案独立设计，不考虑长期营养累积效应</li>
<li>假设模型的计算和响应时间在可接受范围内，适合实际应用中的快速决策需求。</li>
</ol>
<h1 id="三、问题分析"><a href="#三、问题分析" class="headerlink" title="三、问题分析"></a>三、问题分析</h1><p>膳食食谱的营养分析与优化是一个典型的营养学与数据科学交叉问题，其核心在于通过定量分析食谱的营养成分，评估其是否符合健康膳食标准，并基于数学模型进行优化调整。题目提供了61种常见食物的详细营养成分数据，包括蛋白质、脂肪、碳水化合物、维生素及矿物质含量，以及8种必需氨基酸的组成信息。这些数据构成了问题分析的基础，而评价与调整的关键在于如何将这些数据转化为可计算的营养指标，并建立合理的优化模型。<br>该问题可抽象为一个多目标优化问题，主要涉及食谱中各类食物的摄入量作为决策变量，目标函数包括营养均衡性、氨基酸评分和经济性，约束条件则涵盖能量需求、营养素下限、餐次比和食物多样性等。由于氨基酸评分涉及最小值函数，导致目标函数呈现非线性特征，同时食物选择存在离散与连续变量混合的情况，这增加了问题的复杂性。针对这些特点，本文采用差分进化算法进行优化，该算法能够有效处理非线性问题，具有全局搜索能力，并能灵活应对混合变量类型。<br>通过模型求解，可以得到调整后的优化食谱方案。具体优化策略包括增加优质蛋白来源以提升氨基酸评分，减少高脂肪食物来改善宏量营养素比例，补充微量营养素以满足最低摄入要求，以及优化餐次分配确保能量供给合理。最终通过营养计算和可视化手段验证优化效果，确保调整后的食谱既科学合理又具有实际可操作性。这一方法不仅解决了当前食谱的营养均衡问题，也为后续个性化膳食推荐提供了可扩展的模型框架。</p>
<h1 id="四、符号说明"><a href="#四、符号说明" class="headerlink" title="四、符号说明"></a>四、符号说明</h1><h1 id="五、模型的建立与求解"><a href="#五、模型的建立与求解" class="headerlink" title="五、模型的建立与求解"></a>五、模型的建立与求解</h1><h2 id="5-1男女生一天饮食评价"><a href="#5-1男女生一天饮食评价" class="headerlink" title="5.1男女生一天饮食评价"></a>5.1男女生一天饮食评价</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><strong>评价模型</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/016.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/017.png"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/018.png"
                      alt="photo"
                ></p>
<p><strong>优化模型</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/019.png"
                      alt="photo"
                ></p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>本研究基于《中国食物成分表》的61种食材数据，对某校学生食堂提供的男女膳食方案进行了系统性评估。如图1（某校学生食堂食物类别分布）所示，男生食谱中谷薯类占比达35.7%，显著高于女生的28.6%（χ²&#x3D;4.32，p&lt;0.05），而女生食谱中蔬菜菌藻水果类占比41.2%则明显优于男生的33.3%。这种结构性差异直接影响了后续的营养素摄入分布。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/001.png"
                      alt="photo"
                ><br><em>图1 某校学生食堂食物类别分布</em></p>
<p>通过图2（男生食物类别统计）和图3（女生食物类别统计）的对比分析发现，男生每日摄入的畜禽鱼蛋类食物达到4种，比女生多出1种，但奶豆坚果类仅2种，较女生少1种。这种不均衡分布导致了两者在微量元素摄入上的显著差异。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/002.png"
                      alt="photo"
                ><br><em>图2 男生食物类别统计</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/003.png"
                      alt="photo"
                ><br><em>图3 女生食物类别统计</em></p>
<p>图4（男生膳食微量元素分布特征）显示，钙、铁、锌的摄入量分别为578.5mg、18.77mg和9.99mg，而图5（女生膳食微量元素分布特征）则显示相应数值为346.0mg、8.56mg和5.38mg，均低于男生水平（t&#x3D;3.21，p&lt;0.01）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/004.png"
                      alt="photo"
                ><br><em>图4 男生膳食微量元素分布特征</em><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/005.png"
                      alt="photo"
                ><br><em>图5 女生膳食微量元素分布特征</em></p>
<p>在宏量营养素方面，图6（男生宏量营养素能量占比）左图清晰地展示了蛋白质、脂肪和碳水化合物的供能比分别为11.58%、43.35%和45.07%，其中脂肪占比远超推荐上限。图6（女生宏量营养素能量占比）右图则显示其脂肪占比为27.6%，虽然处于合理区间，但碳水化合物占比达57.3%，反映出主食过量的倾向。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/006.png"
                      alt="photo"
                ><br><strong>图6 男生(左)、女生（右）宏量营养素能量占比</strong></p>
<p>这种差异在图7（男生实际摄入量与推荐摄入量比较）和图8（女生实际摄入量与推荐摄入量比较）中得到了进一步验证，男生总能量摄入2602.99kcal基本达标，但女生1347.98kcal的总能量仅达到推荐值的74.6%。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/007.png"
                      alt="photo"
                ><br><em>图7 男生实际摄入量与推荐摄入量比较</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/008.png"
                      alt="photo"
                ><br><em>图8 女生实际摄入量与推荐摄入量比较</em></p>
<p>氨基酸评分分析揭示了更深层次的问题。图9（男生必需氨基酸评分（AAS））显示含硫氨基酸评分仅为40.16，成为限制蛋白质质量的首要因素；图10（女生必需氨基酸评分（AAS））虽然赖氨酸评分达92.90，但含硫氨基酸68.41的评分仍低于安全阈值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/009.png"
                      alt="photo"
                ><br><em>图9 男生必需氨基酸评分（AAS）</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/010.png"
                      alt="photo"
                ><br><em>图10 女生必需氨基酸评分（AAS）</em></p>
<p>通过图11（男生、女生三餐氨基酸摄入均衡性评估）的时间维度分析发现，晚餐的氨基酸评分普遍低于其他餐次，这与图12（男生、女生每餐能量占总能量的百分比）中显示的晚餐营养密度不足直接相关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/011.png"
                      alt="photo"
                ><br><em>图11 男生（左）、女生（右）三餐氨基酸摄入均衡性评估</em><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/012.png"
                      alt="photo"
                ><br><em>图12 男生（左）、女生（右）每餐能量占总能量的百分比</em></p>
<p>微量元素摄入的均衡性评估结果同样值得关注。图13（男生微量元素摄入均衡性评估）左图表明铁和锌的摄入充足，但钙和维生素C明显不足；图13（女生微量元素摄入均衡性评估）右图则显示所有微量元素的摄入量均低于推荐值，其中钙的缺口达45.3%。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/013.png"
                      alt="photo"
                ><br><em>图13 男生（左）、女生（右）微量元素摄入均衡性评估</em></p>
<p>这种差异在图14（男生膳食氨基酸与营养成分的分布特征）和图15（女生膳食氨基酸与营养成分的分布特征）的散点图中表现得尤为明显，女生数据点的分布更加偏离理想区间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/014.png"
                      alt="photo"
                ><br><em>图14 男生膳食氨基酸与营养成分的分布特征</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/015.png"
                      alt="photo"
                ><br><em>图15 女生膳食氨基酸与营养成分的分布特征</em></p>
<p>基于上述发现，本研究提出了针对性的优化方案。首先调整食物类别占比，增加男生奶制品和女生豆制品的摄入；其次重新分配餐次能量，将男生晚餐能量占比从32%提升至35%，女生早餐占比从30%增至33%；最后优化食材组合，采用氨基酸互补原则，如将男生食谱中的豆油部分替换为芝麻油，女生增加蛋奶混合食材。通过这些调整，最终使男生的含硫氨基酸评分提升至47.94，女生的钙摄入量达到649.1mg，显著改善了整体营养质量。</p>
<h2 id="5-2男女生氨基酸优先推荐饮食"><a href="#5-2男女生氨基酸优先推荐饮食" class="headerlink" title="5.2男女生氨基酸优先推荐饮食"></a>5.2男女生氨基酸优先推荐饮食</h2><h3 id="食谱"><a href="#食谱" class="headerlink" title="食谱"></a>食谱</h3><p><strong>男生食谱</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>食物名称</th>
</tr>
</thead>
<tbody><tr>
<td>早餐</td>
<td>酸奶</td>
</tr>
<tr>
<td>早餐</td>
<td>煎鸡蛋</td>
</tr>
<tr>
<td>早餐</td>
<td>蒸地瓜</td>
</tr>
<tr>
<td>午餐</td>
<td>海带炖白菜</td>
</tr>
<tr>
<td>午餐</td>
<td>鸡肉炖土豆胡萝卜</td>
</tr>
<tr>
<td>午餐</td>
<td>白菜炖豆腐</td>
</tr>
<tr>
<td>午餐</td>
<td>干炸黄花鱼</td>
</tr>
<tr>
<td>晚餐</td>
<td>砂锅面</td>
</tr>
<tr>
<td>晚餐</td>
<td>萝卜粉丝汤</td>
</tr>
<tr>
<td>晚餐</td>
<td>炒肉扁豆</td>
</tr>
<tr>
<td>晚餐</td>
<td>茄汁沙丁鱼</td>
</tr>
</tbody></table>
<p><strong>女生食谱</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>食物名称</th>
</tr>
</thead>
<tbody><tr>
<td>早餐</td>
<td>大米粥</td>
</tr>
<tr>
<td>早餐</td>
<td>油条</td>
</tr>
<tr>
<td>早餐</td>
<td>煮鸡蛋</td>
</tr>
<tr>
<td>早餐</td>
<td>蒸地瓜</td>
</tr>
<tr>
<td>早餐</td>
<td>水煎包</td>
</tr>
<tr>
<td>午餐</td>
<td>鱼丸汤</td>
</tr>
<tr>
<td>午餐</td>
<td>红烧牛肉面</td>
</tr>
<tr>
<td>晚餐</td>
<td>红烧肉</td>
</tr>
<tr>
<td>晚餐</td>
<td>干炸黄花鱼</td>
</tr>
<tr>
<td>晚餐</td>
<td>炖海带白菜豆腐</td>
</tr>
<tr>
<td>晚餐</td>
<td>柚子</td>
</tr>
</tbody></table>
<h3 id="可视化评价"><a href="#可视化评价" class="headerlink" title="可视化评价"></a>可视化评价</h3><p><strong>男生</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/020.png"
                      alt="photo"
                ><br><em>男生三餐氨基酸摄入均衡性评估</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/021.png"
                      alt="photo"
                ><br><em>男生膳食微量元素分布特征</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/022.png"
                      alt="photo"
                ><br><em>全天氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/023.png"
                      alt="photo"
                ><br><em>三餐氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/024.png"
                      alt="photo"
                ><br><em>三餐营养供能占比</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/025.png"
                      alt="photo"
                ><br><em>三餐营养热力图</em></p>
<p><strong>女生</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/026.png"
                      alt="photo"
                ><br><em>女生三餐氨基酸摄入均衡性评估</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/027.png"
                      alt="photo"
                ><br><em>女生膳食微量元素分布特征</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/028.png"
                      alt="photo"
                ><br><em>全天氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/029.png"
                      alt="photo"
                ><br><em>三餐氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/030.png"
                      alt="photo"
                ><br><em>三餐营养供能占比</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/031.png"
                      alt="photo"
                ><br><em>三餐营养热力图</em></p>
<h2 id="5-3男女生价格优先推荐饮食"><a href="#5-3男女生价格优先推荐饮食" class="headerlink" title="5.3男女生价格优先推荐饮食"></a>5.3男女生价格优先推荐饮食</h2><h3 id="食谱-1"><a href="#食谱-1" class="headerlink" title="食谱"></a>食谱</h3><p><strong>男生食谱</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>食物名称</th>
</tr>
</thead>
<tbody><tr>
<td>早餐</td>
<td>牛奶</td>
</tr>
<tr>
<td>早餐</td>
<td>蒸地瓜</td>
</tr>
<tr>
<td>午餐</td>
<td>白菜炖豆腐</td>
</tr>
<tr>
<td>午餐</td>
<td>香蕉</td>
</tr>
<tr>
<td>午餐</td>
<td>蜜瓜</td>
</tr>
<tr>
<td>晚餐</td>
<td>炖海带白菜豆腐</td>
</tr>
<tr>
<td>晚餐</td>
<td>柚子</td>
</tr>
</tbody></table>
<p><strong>女生食谱</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>食物名称</th>
</tr>
</thead>
<tbody><tr>
<td>早餐</td>
<td>牛奶</td>
</tr>
<tr>
<td>早餐</td>
<td>蒸地瓜</td>
</tr>
<tr>
<td>早餐</td>
<td>拌土豆丝</td>
</tr>
<tr>
<td>午餐</td>
<td>菠菜汤</td>
</tr>
<tr>
<td>午餐</td>
<td>白菜炖豆腐</td>
</tr>
<tr>
<td>午餐</td>
<td>香蕉</td>
</tr>
<tr>
<td>午餐</td>
<td>蜜瓜</td>
</tr>
<tr>
<td>晚餐</td>
<td>炖海带白菜豆腐</td>
</tr>
<tr>
<td>晚餐</td>
<td>柚子</td>
</tr>
</tbody></table>
<h3 id="可视化评价-1"><a href="#可视化评价-1" class="headerlink" title="可视化评价"></a>可视化评价</h3><p><strong>男生</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/032.png"
                      alt="photo"
                ><br><em>男生三餐氨基酸摄入均衡性评估</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/033.png"
                      alt="photo"
                ><br><em>男生膳食微量元素分布特征</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/034.png"
                      alt="photo"
                ><br><em>全天氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/035.png"
                      alt="photo"
                ><br><em>三餐氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/036.png"
                      alt="photo"
                ><br><em>三餐营养供能占比</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/037.png"
                      alt="photo"
                ><br><em>三餐营养热力图</em></p>
<p><strong>女生</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/038.png"
                      alt="photo"
                ><br><em>女生三餐氨基酸摄入均衡性评估</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/039.png"
                      alt="photo"
                ><br><em>女生膳食微量元素分布特征</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/040.png"
                      alt="photo"
                ><br><em>全天氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/041.png"
                      alt="photo"
                ><br><em>三餐氨基酸摄入评分柱状图</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/042.png"
                      alt="photo"
                ><br><em>三餐营养供能占比</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/06/043.png"
                      alt="photo"
                ><em>三餐营养热力图</em></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>移动房车险购买倾向预测分析</title>
    <url>/zhihaojiang.github.io/2025/06/05/20250607%E7%A7%BB%E5%8A%A8%E6%88%BF%E8%BD%A6%E9%99%A9%E8%B4%AD%E4%B9%B0%E5%80%BE%E5%90%91%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>保险已成为“高净值人士”的青睐之选。在当前投资机会较少、股市&#x2F;楼市&#x2F;实体经济风险较高的背景下，保险业迎来蓬勃发展，大量保险公司推出人寿型、医疗型、投资理财型等产品，竞争激烈。传统的保险模型往往依赖于历史数据和经验法则，易出现险种推荐错配、过度推销等问题，引发客户信任危机和抵触情绪，损害企业品牌信誉。<br>本案例旨在通过机器学习技术分析家庭购买保险的历史数据，帮助保险公司更好地理解客户的购买行为和风险偏好。完成数据清洗、特征选择、模型构建、模型评估、模型优化和模型解释等数据分析任务，挖掘影响客户购买移动放车险的重要因素，构建移动房车险购买倾向预测模型，提升推荐准确度，从而在竞争激烈的市场中获得优势。</p>
<h1 id="基本库导入"><a href="#基本库导入" class="headerlink" title="基本库导入"></a>基本库导入</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">from matplotlib import font_manager</span><br><span class="line"><span class="comment"># 设置字体路径</span></span><br><span class="line">font_path = <span class="string">&#x27;/System/Library/Fonts/STHeiti Medium.ttc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载字体</span></span><br><span class="line">my_font = font_manager.FontProperties(fname=font_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = my_font.get_name()</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = False  <span class="comment"># 正确显示负号</span></span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;#d7fbe8&#x27;</span>,<span class="string">&#x27;#9df3c4&#x27;</span>,<span class="string">&#x27;#62d2a2&#x27;</span>,<span class="string">&#x27;#1fab89&#x27;</span>,<span class="string">&#x27;#a6d0e4&#x27;</span>, <span class="string">&#x27;#f9ffea&#x27;</span>, <span class="string">&#x27;#ffecda&#x27;</span>, <span class="string">&#x27;#d4a5a5&#x27;</span>, <span class="string">&#x27;#fbafaf&#x27;</span>, <span class="string">&#x27;#f2c6b4&#x27;</span>, <span class="string">&#x27;#f3e8cb&#x27;</span>, <span class="string">&#x27;#99e1e5&#x27;</span>]</span><br></pre></td></tr></table></figure></div>

<h1 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> = pd.read_excel(<span class="string">&#x27;train.xlsx&#x27;</span>)</span><br><span class="line">df_test = pd.read_excel(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.info()</span><br><span class="line"></span><br><span class="line">df.shape</span><br><span class="line"></span><br><span class="line">df.head()</span><br><span class="line"></span><br><span class="line">df.describe()</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>&lt;class ‘pandas.core.frame.DataFrame’&gt;<br>RangeIndex: 1756 entries, 0 to 1755<br>Data columns (total 86 columns):</p>
<h1 id="Column-Non-Null-Count-Dtype"><a href="#Column-Non-Null-Count-Dtype" class="headerlink" title="Column      Non-Null Count  Dtype"></a>Column      Non-Null Count  Dtype</h1><hr>
<p> 0   客户次类别       1756 non-null   int64<br> 1   房产数         1756 non-null   int64<br> 2   每房人数        1756 non-null   int64<br> 3   平均年龄        1756 non-null   int64<br> 4   客户主类别       1756 non-null   int64<br> 5   罗马天主教比例     1756 non-null   int64<br> 6   新教比例        1756 non-null   int64<br> 7   其它宗教比例      1756 non-null   int64<br> 8   无宗教比例       1756 non-null   int64<br> 9   已婚占比        1756 non-null   int64<br> 10  同居占比        1756 non-null   int64<br> 11  其它关系占比      1756 non-null   int64<br> 12  单身占比        1756 non-null   int64<br> 13  无子女         1756 non-null   int64<br> 14  有子女         1756 non-null   int64<br> 15  高等教育        1756 non-null   int64<br> 16  中等教育        1756 non-null   int64<br> 17  低等教育        1756 non-null   int64<br> 18  高管          1756 non-null   int64<br> 19  企业家         1756 non-null   int64<br>…<br> 84  投保社会安全险数量   1756 non-null   int64<br> 85  移动房车险数量     1756 non-null   int64<br>dtypes: int64(86)<br>memory usage: 1.2 MB</p>
<p>(1756, 86)</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/001.png"
                      alt="photo"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/002.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sns.countplot(x=<span class="string">&#x27;移动房车险数量&#x27;</span>, data=<span class="built_in">df</span>, palette=colors)</span><br><span class="line">plt.title(<span class="string">&#x27;移动房车险数量分布&#x27;</span>, fontproperties=my_font, fontsize=16)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;移动房车险数量&#x27;</span>, fontproperties=my_font, fontsize=14)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;数量&#x27;</span>, fontproperties=my_font, fontsize=14)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/003.png"
                      alt="photo"
                ></p>
<p>我们查看训练集数据的分布 发现其数量较均匀（也查看了测试集的分布 其购买保险的人数远少于未买保险的人数）</p>
<h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;存在缺失值的列：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.columns[df.isnull().any()])</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>存在缺失值的列：<br>Index([], dtype&#x3D;’object’)</p>
</blockquote>
<p>发现数据中没有缺失值</p>
<h2 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h2><h3 id="检测数据分布"><a href="#检测数据分布" class="headerlink" title="检测数据分布"></a>检测数据分布</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line">import scipy.stats as stats</span><br><span class="line"></span><br><span class="line">numeric_cols = df.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> numeric_cols:</span><br><span class="line">    plt.figure(figsize=(14, 5))</span><br><span class="line"></span><br><span class="line">    plt.subplot(1, 2, 1)</span><br><span class="line">    sns.histplot(<span class="built_in">df</span>[col], kde=True, bins=30, color=<span class="string">&#x27;skyblue&#x27;</span>)</span><br><span class="line">    plt.title(col)</span><br><span class="line">    plt.xlabel(col)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(1, 2, 2)</span><br><span class="line">    stats.probplot(<span class="built_in">df</span>[col], dist=<span class="string">&quot;norm&quot;</span>, plot=plt)</span><br><span class="line">    plt.title(col)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/004.png"
                      alt="photo"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/005.png"
                      alt="photo"
                ><br>我们可视化了各个特征的分布 发现在前半部份的特征（非投保）数据分布较为正常 在投保部分的特征 数据呈现非常明显的偏态分布 这种情况在进行异常检测时可能是异常值 但考虑到我们这个数据集是预测移动房车险购买倾向 有可能这些异常值就是那些购买保险的人 因此我们可以标记异常值</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    <span class="keyword">if</span> col == <span class="string">&#x27;移动房车险数量&#x27;</span> or <span class="built_in">df</span>[col].dtype == <span class="string">&#x27;object&#x27;</span>:</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    </span><br><span class="line">    Q1 = <span class="built_in">df</span>[col].quantile(0.25)</span><br><span class="line">    Q3 = <span class="built_in">df</span>[col].quantile(0.75)</span><br><span class="line">    IQR = Q3 - Q1</span><br><span class="line">    lower = Q1 - 1.5 * IQR</span><br><span class="line">    upper = Q3 + 1.5 * IQR</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">df</span>[col + <span class="string">&#x27;_outlier&#x27;</span>] = <span class="built_in">df</span>[col].apply(lambda x: 1 <span class="keyword">if</span> (x &lt; lower or x &gt; upper) <span class="keyword">else</span> 0)</span><br></pre></td></tr></table></figure></div>

<h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>我们计算方差和皮尔逊相关系数 删除方差过小的特征和p&gt;0.05的特征</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">low_var = df.var(numeric_only=True)</span><br><span class="line"><span class="built_in">df</span> = df.drop(columns=low_var[low_var &lt;= 0.1].index)</span><br><span class="line"></span><br><span class="line">from scipy.stats import pearsonr</span><br><span class="line"></span><br><span class="line">target_col = <span class="string">&quot;移动房车险数量&quot;</span></span><br><span class="line">numeric_cols = df.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    <span class="keyword">if</span> col == target_col:</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">if</span> col not <span class="keyword">in</span> numeric_cols:</span><br><span class="line">        <span class="built_in">df</span> = df.drop(columns=[col])</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    try:</span><br><span class="line">        corr, p = pearsonr(<span class="built_in">df</span>[col], <span class="built_in">df</span>[target_col])</span><br><span class="line">        <span class="keyword">if</span> p &gt; 0.05:</span><br><span class="line">            <span class="built_in">df</span> = df.drop(columns=[col])</span><br><span class="line">    except Exception as e:</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;Error on &#123;col&#125;: &#123;e&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">df</span> = df.drop(columns=[col])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.columns.tolist())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;剩余变量数量:&quot;</span>, len(df.columns))</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>[‘客户次类别’, ‘每房人数’, ‘客户主类别’, ‘新教比例’, ‘无宗教比例’, ‘已婚占比’, ‘同居占比’, ‘其它关系占比’, ‘单身占比’, ‘高等教育’, ‘中等教育’, ‘低等教育’, ‘高管’, ‘农场主’, ‘中层管理者’, ‘技术工人’, ‘非熟练劳工’, ‘社会阶层A’, ‘社会阶层B1’, ‘社会阶层C’, ‘社会阶层D’, ‘租房子’, ‘房主’, ‘一辆车’, ‘无车’, ‘公共社保’, ‘私人社保’, ‘收入低于30’, ‘收入45-75’, ‘收入75-122’, ‘平均收入’, ‘购买力水平’, ‘个人第三方保险’, ‘投保车险’, ‘投保机动自行车险’, ‘投保身残险’, ‘投保火险’, ‘投保船险’, ‘投保社会安全险’, ‘第三方私人险数量’, ‘投保车险数量’, ‘投保寿险数量’, ‘投保火险数量’, ‘移动房车险数量’, ‘社会阶层D_outlier’]<br>剩余变量数量: 45</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">selected_cols = df.columns.tolist()</span><br><span class="line">df_test = <span class="built_in">df</span>[selected_cols]</span><br></pre></td></tr></table></figure></div>

<h1 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">X = df.drop(columns=[<span class="string">&#x27;移动房车险数量&#x27;</span>])</span><br><span class="line">y = <span class="built_in">df</span>[<span class="string">&#x27;移动房车险数量&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train = df.drop(columns=[<span class="string">&#x27;移动房车险数量&#x27;</span>])</span><br><span class="line">y_train = <span class="built_in">df</span>[<span class="string">&#x27;移动房车险数量&#x27;</span>]</span><br><span class="line">X_test = df_test.drop(columns=[<span class="string">&#x27;移动房车险数量&#x27;</span>])</span><br><span class="line">y_test = df_test[<span class="string">&#x27;移动房车险数量&#x27;</span>]</span><br></pre></td></tr></table></figure></div>

<h1 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h1><p>我们使用了两种模型处理并优化 第一个使用了朴素贝叶斯模型 使用网格优化 得到<br>recall&#x3D;0.73 f1&#x3D;0.67<br>相较与只使用朴素贝叶斯 其召回率提高了5%<br>我们又使用多层感知机进行训练并用adam进行优化并且设置了早停 其准确率和召回率达到了0.95和0.96 并且我们更关注模型预测会购买保险的召回率：0.98 说明模型了解了购买保险人的画像</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.preprocessing import Binarizer</span><br><span class="line">from sklearn.naive_bayes import BernoulliNB</span><br><span class="line">from sklearn.metrics import accuracy_score, recall_score, classification_report</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;nb&#x27;</span>, BernoulliNB())</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">pipeline.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = pipeline.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;准确率：&#x27;</span>, accuracy_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;召回率：&#x27;</span>, recall_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分类报告：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br></pre></td></tr></table></figure></div>
<p>准确率： 0.6822323462414579<br>召回率： 0.617816091954023<br>分类报告：<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.74      0.72      0.73      1060
       1       0.60      0.62      0.61       696

accuracy                           0.68      1756
macro avg      0.67      0.67      0.67      1756
weighted avg   0.68      0.68      0.68      1756
</code></pre>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line">from sklearn.naive_bayes import BernoulliNB</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;nb&#x27;</span>, BernoulliNB())</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;nb__alpha&#x27;</span>: [0.1, 0.5, 1.0, 2.0],</span><br><span class="line">    <span class="string">&#x27;nb__binarize&#x27;</span>: [0.0, 0.5, 1.0, 2.0],</span><br><span class="line">    <span class="string">&#x27;nb__class_prior&#x27;</span>: [None, [0.3, 0.7], [0.4, 0.6]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring=<span class="string">&#x27;f1&#x27;</span>, n_jobs=-1)</span><br><span class="line"></span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = grid_search.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数：&quot;</span>, grid_search.best_params_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳模型得分：&quot;</span>, grid_search.best_score_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n分类报告：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br></pre></td></tr></table></figure></div>
<p>最佳参数： {‘nb__alpha’: 0.1, ‘nb__binarize’: 0.0, ‘nb__class_prior’: [0.4, 0.6]}<br>最佳模型得分： 0.6235479451448764</p>
<p>分类报告：<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.78      0.63      0.70      1060
       1       0.57      0.73      0.64       696

accuracy                           0.67      1756
macro avg      0.67      0.68      0.67      1756
weighted avg   0.70      0.67      0.68      1756
</code></pre>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.neural_network import MLPClassifier</span><br><span class="line">from sklearn.metrics import accuracy_score, recall_score, classification_report</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">pipeline = Pipeline([</span><br><span class="line">    (<span class="string">&#x27;scaler&#x27;</span>, StandardScaler()),</span><br><span class="line">    (<span class="string">&#x27;mlp&#x27;</span>, MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=500,</span><br><span class="line">                          solver=<span class="string">&#x27;adam&#x27;</span>, early_stopping=True,</span><br><span class="line">                          validation_fraction=0.1, n_iter_no_change=10,</span><br><span class="line">                          random_state=42))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">pipeline.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = pipeline.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;准确率：&#x27;</span>, accuracy_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;召回率（宏平均）：&#x27;</span>, recall_score(y_test, y_pred, average=<span class="string">&#x27;macro&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分类报告：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line"></span><br><span class="line">plt.plot(pipeline.named_steps[<span class="string">&#x27;mlp&#x27;</span>].loss_curve_)</span><br><span class="line">plt.title(<span class="string">&quot;Loss Curve&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iterations&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p>准确率： 0.9595671981776766<br>召回率（宏平均）： 0.9635491216655823<br>分类报告：<br>              precision    recall  f1-score   support</p>
<pre><code>       0       0.99      0.94      0.97      1060
       1       0.92      0.98      0.95       696

accuracy                           0.96      1756
macro avg      0.95      0.96      0.96      1756
weighted avg   0.96      0.96      0.96      1756
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/006.png"
                      alt="photo"
                ></p>
<h1 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h1><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import shap</span><br><span class="line"></span><br><span class="line">scaler = pipeline.named_steps[<span class="string">&#x27;scaler&#x27;</span>]</span><br><span class="line">model = pipeline.named_steps[<span class="string">&#x27;mlp&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line">explainer = shap.KernelExplainer(model.predict, X_train_scaled[:100])</span><br><span class="line">shap_values = explainer.shap_values(X_test_scaled[:100])</span><br><span class="line"></span><br><span class="line">shap.summary_plot(shap_values, X_test_scaled[:100], feature_names=X.columns)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/07/007.png"
                      alt="photo"
                ></p>
<h1 id="推荐建议"><a href="#推荐建议" class="headerlink" title="推荐建议"></a>推荐建议</h1><p>我们使用shap画出了summary_plot<br>可以看到投保车险 租房子 投保身残险 已婚占比的重要度较高<br>说明那些会购买移动房车险的客户会给自己的车购买保险 喜欢租房（爱好周游世界）看中自己的生命 已婚<br>这类人群的用户画像基本可以如此描述：他们喜欢周游世界 有足够的精力去欣赏世界的美好 有着足够的资金去支持自己的爱好<br>用户群体可能为：退休的老两口 他们的孩子有足够的独立性不需要他们去操心 他们可以安心享受退休生活 他们有着足够的资金去周游世界 去弥补年轻时没空干的事</p>
<p>同时 我们注意到 第三方社会阶层B1 私人险数量和投保船险的影响力较大 虽然在全局中不是特别重要 但是这些也起到关键作用<br>这类客户的用户画像为40岁以上 公司董事长 其公司十分成熟 在行业内有着举足轻重的地位 其无需担心自己的商业帝国会面临困难 拥有着自己的游艇 为人比较低调 不喜欢显露自己的财富<br>这类人属于高端客户 他们见过的世面很广 十分精明 虽然数量稀少 但是若成功售出 会给公司带来巨大利润</p>
<p>因此 我们的营销策略为：主要对退休的老两口进行营销 可以在房车经销商处宣发广告 在财经频道 新闻频道宣发广告<br>同时要打造高端化产品 提供足够的情绪价值 尽可能地打造几个高端的产品以吸引高端客户</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Apriori算法原理</title>
    <url>/zhihaojiang.github.io/2025/06/13/20250613Apriori%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Apriori"><a href="#Apriori" class="headerlink" title="Apriori"></a>Apriori</h1><p>Apriori 算法是<strong>关联规则学习</strong>中最经典的算法之一，用于在大规模交易记录中发现<strong>频繁项集</strong>和<strong>关联规则</strong>。</p>
<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>这是 Apriori 原理（反单调性）<br><strong>“如果一个项集是频繁的，它的所有子集也一定是频繁的”</strong><br>→ 反过来说：<strong>如果某个项集不频繁，那它的所有超集一定也不频繁</strong>。</p>
<h1 id="Apriori流程"><a href="#Apriori流程" class="headerlink" title="Apriori流程"></a>Apriori流程</h1><ol>
<li>初始化：找出所有频繁的1项集。</li>
</ol>
<ul>
<li>扫描数据，统计每个单品的支持度。</li>
<li>只保留支持度 ≥ 最小阈值（min_sup）的项。</li>
</ul>
<ol start="2">
<li>迭代生成 k 项集。</li>
</ol>
<ul>
<li>用频繁的 (k−1) 项集 生成候选 k 项集（两两组合）。</li>
<li>继续扫描数据集，统计每个候选项集的支持度。</li>
<li>只保留支持度 ≥ min_sup 的项集。</li>
</ul>
<ol start="3">
<li>重复直到无法产生更大的频繁项集。</li>
</ol>
<h1 id="找频繁项集后-→-生成关联规则"><a href="#找频繁项集后-→-生成关联规则" class="headerlink" title="找频繁项集后 → 生成关联规则"></a>找频繁项集后 → 生成关联规则</h1><p> 对每个频繁项集 L：</p>
<ul>
<li>枚举其所有非空子集 A，令 B &#x3D; L − A</li>
<li>构造规则：A → B</li>
<li>计算置信度 confidence &#x3D; support(L) &#x2F; support(A)</li>
<li>若 confidence ≥ min_conf，则保留规则<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/13/001.jpg"
                      alt="photo"
                ></li>
</ul>
<h2 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h2><p>假设发现以下频繁项集：</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>info</p>

    </div>
    <div class="notel-content">
      <p>{牛奶, 面包}，support &#x3D; 0.6<br>{牛奶}，support &#x3D; 0.8</p>

    </div>
  </div>

<p>则可以生成规则：</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>info</p>

    </div>
    <div class="notel-content">
      <p>牛奶 → 面包，confidence &#x3D; 0.6 &#x2F; 0.8 &#x3D; 0.75</p>

    </div>
  </div>
<p>如果最小置信度设为 0.7，这条规则会被保留。</p>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>超市推荐系统<br>电商商品搭配<br>网页点击路径分析<br>疾病共现分析</p>
<h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><h2 id="项（Item）"><a href="#项（Item）" class="headerlink" title="项（Item）"></a>项（Item）</h2><p>数据中的一个元素，比如：商品“牛奶”、“面包”。</p>
<h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><p>一组一起出现的项。例如：某一次购物记录是[牛奶, 面包, 鸡蛋]。</p>
<h2 id="项集（Itemset）"><a href="#项集（Itemset）" class="headerlink" title="项集（Itemset）"></a>项集（Itemset）</h2><p>一组项的组合。例如：{牛奶, 面包} 是一个 2-项集。</p>
<h1 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h1><h2 id="支持度（Support）"><a href="#支持度（Support）" class="headerlink" title="支持度（Support）"></a>支持度（Support）</h2><p>一个规则在数据集中出现的频率 表示某项集在整个数据中出现的频率。<br><code>\text&#123;Support&#125;(X) = \frac&#123;\text&#123;包含 X 的事务数&#125;&#125;&#123;\text&#123;总事务数&#125;&#125;</code></p>
<h2 id="置信度（Confidence）"><a href="#置信度（Confidence）" class="headerlink" title="置信度（Confidence）"></a>置信度（Confidence）</h2><p>规则的可靠性程度 表示在买了 X 的前提下买 Y 的概率。<br><code>\text&#123;Confidence&#125;(X \rightarrow Y) = \frac&#123;\text&#123;Support&#125;(X \cup Y)&#125;&#123;\text&#123;Support&#125;(X)&#125; </code></p>
<h2 id="提升度（Lift）"><a href="#提升度（Lift）" class="headerlink" title="提升度（Lift）"></a>提升度（Lift）</h2><p>衡量 X 和 Y 是否真正有关联<br><code>\text&#123;Lift&#125;(X \rightarrow Y) = \frac&#123;\text&#123;Confidence&#125;(X \rightarrow Y)&#125;&#123;\text&#123;Support&#125;(Y)&#125;</code></p>
<ul>
<li>若 Lift &gt; 1：X 和 Y 正相关</li>
<li>若 Lift &#x3D; 1：X 和 Y 独立</li>
<li>若 Lift &lt; 1：X 和 Y 负相关</li>
</ul>
<h1 id="Apriori算法实现–mlxtend"><a href="#Apriori算法实现–mlxtend" class="headerlink" title="Apriori算法实现–mlxtend"></a>Apriori算法实现–mlxtend</h1><p>必要的库</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>info</p>

    </div>
    <div class="notel-content">
      <p>pip install mlxtend pandas</p>

    </div>
  </div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from mlxtend.preprocessing import TransactionEncoder</span><br><span class="line">from mlxtend.frequent_patterns import apriori, association_rules</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟购物篮数据</span></span><br><span class="line">dataset = [</span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 编码转换：把列表数据转为布尔型 DataFrame</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary = te.fit(dataset).transform(dataset)</span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(te_ary, columns=te.columns_)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 使用 Apriori 找出频繁项集（设置最小支持度为0.5）</span></span><br><span class="line">frequent_itemsets = apriori(<span class="built_in">df</span>, min_support=0.5, use_colnames=True)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. 生成关联规则（设置最小置信度为0.6）</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=0.6)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4. 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;【频繁项集】&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(frequent_itemsets)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n【关联规则】&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(rules[[<span class="string">&#x27;antecedents&#x27;</span>, <span class="string">&#x27;consequents&#x27;</span>, <span class="string">&#x27;support&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>, <span class="string">&#x27;lift&#x27;</span>]])</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>【频繁项集】<br>   support  itemsets<br>0      0.8      (牛奶)<br>1      0.8      (面包)<br>2      0.8      (鸡蛋)<br>3      0.6  (牛奶, 面包)<br>4      0.6  (鸡蛋, 牛奶)<br>5      0.6  (鸡蛋, 面包)</p>
<p>【关联规则】<br>  antecedents consequents  support  confidence    lift<br>0        (牛奶)        (面包)      0.6        0.75  0.9375<br>1        (面包)        (牛奶)      0.6        0.75  0.9375<br>2        (鸡蛋)        (牛奶)      0.6        0.75  0.9375<br>3        (牛奶)        (鸡蛋)      0.6        0.75  0.9375<br>4        (鸡蛋)        (面包)      0.6        0.75  0.9375<br>5        (面包)        (鸡蛋)      0.6        0.75  0.9375</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>科技</tag>
        <tag>算法原理</tag>
      </tags>
  </entry>
  <entry>
    <title>一周科技资讯第一期</title>
    <url>/zhihaojiang.github.io/2025/06/15/20250615%E4%B8%80%E5%91%A8%E7%A7%91%E6%8A%80%E8%B5%84%E8%AE%AF%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="大模型强化学习新突破——SPO新范式助力大模型推理能力提升！"><a href="#大模型强化学习新突破——SPO新范式助力大模型推理能力提升！" class="headerlink" title="大模型强化学习新突破——SPO新范式助力大模型推理能力提升！"></a>大模型强化学习新突破——SPO新范式助力大模型推理能力提升！</h1><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p>机器之心<br><a class="link"   href="https://www.jiqizhixin.com/articles/2025-06-08-6" >https://www.jiqizhixin.com/articles/2025-06-08-6<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>当前，强化学习（RL）在提升大语言模型（LLM）推理能力方面展现出巨大潜力。DeepSeek R1、Kimi K1.5 和 Qwen 3 等模型充分证明了 RL 在增强 LLM 复杂推理能力方面的有效性。</p>
<p>然而，要实现有效的强化学习，需要解决一个根本性的挑战，即信用分配问题（credit assignment）：在大语言模型的场景下，如何将整个序列（LLM 的回复）最终的评估结果，归因到序列中具体的决策动作（token）上。</p>
<p>这一问题的困难在于奖励信号非常稀疏 — 只能在序列结束时才能获得明确的成功或失败反馈。</p>
<h2 id="当前主要方法"><a href="#当前主要方法" class="headerlink" title="当前主要方法"></a>当前主要方法</h2><p>在强化学习中，通常采用优势值估计（advantage estimation）的方法来解决信用分配问题。目前针对大语言模型的强化学习方法主要分为两类，它们之间的区别在于优势值估计的粒度不同。</p>
<p>粗粒度的轨迹级 (trajectory-level) 方法，如 DeepSeek R1 使用的 GRPO，只根据最终的奖励为整个序列计算一个优势值。这种方法虽然高效但反馈信号过于粗糙，LLM 无法对错误回答中正确的部分进行奖励，也无法对正确回答中冗余的部分进行惩罚。</p>
<p>另一种极端是细粒度的 token 级（token-level）方法，如经典的 PPO。这类方法为每个 token 估计优势值，需要依赖额外的 critic 模型来预测每个 token 的状态价值（V 值）。然而，在大语言模型的强化学习任务中，不同 prompt 对应的轨迹分布差异很大，而且在训练过程中每个 prompt 采样出来的模型回复数量非常有限，critic 模型难以训练好，造成 token 级的优势值估计误差很大。</p>
<h2 id="新的-SPO-框架"><a href="#新的-SPO-框架" class="headerlink" title="新的 SPO 框架"></a>新的 SPO 框架</h2><p>为突破这一瓶颈，来自中科院软件所和香港城市大学的的研究团队创新性提出了 Segment Policy Optimization (SPO) 框架。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-0.png"
                      alt="photo"
                ></p>
<blockquote>
<p>论文题目：Segment Policy Optimization: Effective Segment-Level Credit Assignment in RL for Large Language Models</p>
<p>作者：Yiran Guo, Lijie Xu, Jie Liu, Dan Ye, Shuang Qiu</p>
<p>链接：<a class="link"   href="https://arxiv.org/abs/2505.23564" >https://arxiv.org/abs/2505.23564<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>代码链接：<a class="link"   href="https://github.com/AIFrameResearch/SPO" >https://github.com/AIFrameResearch/SPO<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
</blockquote>
<p>SPO 使用了一种中等粒度的段级（segment-level）优势值估计方式。它不像轨迹级方法只在最后一步计算优势，也不像 token 级方法每步都计算优势，而是将生成的序列划分为若干相连的段，计算每个段的优势值。</p>
<p>这种段级的优势值估计方式具有几个明显的优势：</p>
<p>(1) 更优的信用分配：相比轨迹级方法，段级方法能够提供更局部化的优势反馈，让模型能够奖励错误回答中仍然有价值的部分，同时也能惩罚正确回答中冗余和无效的片段。</p>
<p>(2) 更准确的优势值估计：相比 token 级方法，段级方法所需的估计点数量更少，从而能够有效利用蒙特卡洛（Monte Carlo, MC）采样得到更加准确且无偏的优势值估计，而无需再依赖额外且不稳定的 critic 模型。</p>
<p>(3) 更灵活、更易调整：段级的划分方式可以任意定义，并不要求语义上的完整性，因此可以灵活地在 token 级与轨迹级之间自由调整粒度，并且可以适应不同的任务和应用场景。</p>
<p>SPO 框架主要包含三个核心部分：(1) 灵活的段级划分策略；(2) 基于蒙特卡洛采样的段级优势值估计；(3) 利用段级优势值进行策略优化。</p>
<p>这种模块化的设计使框架具备高度的灵活性，不同的部分可以有不同的实现策略，以适用不同的应用场景。</p>
<p>该团队进一步针对不同的推理场景提出 SPO 框架的两个具体实例：对于短的思维链（chain-of-thought, CoT）场景，提出了 SPO-chain，该方法使用基于切分点（cutpoint-based）的段划分和链式优势值估计；对于长 CoT 场景，提出极大提升 MC 采样效率的树形结构优势值估计方法。</p>
<p>此外，该团队还提出了一种 token 概率掩码（token probability-mask）策略优化方法，选择性的对段内的低概率 token 计算损失而非段内的所有 token。作者认为这些 token 是模型推理轨迹可能发生分叉的地方，是段级优势值产生的主要原因。这种方法可以用于 SPO-chain 和 SPO-tree，从而进一步强化信用分配。</p>
<h2 id="框架及核心技术"><a href="#框架及核心技术" class="headerlink" title="框架及核心技术"></a>框架及核心技术</h2><p>SPO 框架主要围绕以下三个具有挑战性的问题进行设计：(1) 如何将生成的序列划分为多个段？(2) 如何准确且高效地估计每个段对应的优势值？(3) 如何利用段级优势值来更新策略？SPO 的三个核心模块分别解答上面三个问题，每个模块包含多种可选策略，来适用于不同的场景：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-1.png"
                      alt="photo"
                ></p>
<ol>
<li>段划分 (Segment Partition):</li>
</ol>
<p>a) 基于切分点的段划分 (Cutpoint-based Partition): 为短思维链场景设计，将段划分点放置在状态值（V 值）更有可能发生变化的地方。根据 token 概率动态确定段边界，优先在模型 “犹豫” 或可能改变推理路径的关键点（cutpoints）进行划分，使信用分配更精确。比如，在下图例子中，标记为红色的 token 是关键点，而标记为蓝色的竖杠是分段结果。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-2.png"
                      alt="photo"
                ><br>b) 固定 token 数量段划分 (Fixed Token Count Partition): 将序列划分为固定长度的段，便于树形结构的组织和优势值估计，为 SPO-tree 设计。</p>
<ol start="2">
<li>段级优势值估计（Segment Advantage Estimation）：</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-3.png"
                      alt="photo"
                ><br>a) 链式优势值估计 (Chain-based) 方法：在短思维链场景下，MC 采样的成本不高，该团队采用一种直接的段级优势值估计方式，独立估计每个段边界的状态值（V 值），然后计算段级优势值。以下公式展示了链式优势值的估计方法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-4.png"
                      alt="photo"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-5.png"
                      alt="photo"
                ><br>b) 树形优势值估计 (Tree-based): 在长思维链场景下，MC 估计的代价很高，团队提出了一种高效的树形估计方法：将采样轨迹组织成树形结构，通过自底向上的奖励聚合计算状态价值（V 值），同一个父节点的子节点形成一个组，在组内计算每个段的优势值。这种方式将用于 V 值估计的样本同时用于策略优化，极大提高了样本效率。以下公式展示了树形优势值估计方法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-6.png"
                      alt="photo"
                ><br>3. 基于段级优势值 token 概率掩码策略优化（Policy Optimization Using Segment Advantages with Token Probability-mask）：<br>在得到段级优势值以后，为了进一步提高信用分配，团队创新性地提出 token 概率掩码策略优化方法，在策略更新仅将段级优势值分配给该段内的低概率（关键）token，而非所有 token。这种方法能更精确地将奖励 &#x2F; 惩罚赋予关键的决策点，提升学习效率和效果。下面分别展示了 SPO-chain 和 SPO-tree 的优化目标。</p>
<p>a) SPO-chain 优化目标：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-7.png"
                      alt="photo"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-8.png"
                      alt="photo"
                ><br>b) SPO-tree 优化目标：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-9.png"
                      alt="photo"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-10.png"
                      alt="photo"
                ></p>
<h2 id="对比基线方法"><a href="#对比基线方法" class="headerlink" title="对比基线方法"></a>对比基线方法</h2><p>如下图所示，在短思维链场景，使用 RhoMath1.1B 作为基座模型，使用 GSM8K 训练集进行训练，对比各种训练算法，使用 SPO 训练得到的模型测试集正确率更高。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-11.png"
                      alt="photo"
                ><br>对于长思维链场景，如下图所示，使用 DeepSeek-R1-Distill-Qwen-1.5B 作为基座模型，使用 MATH 数据集进行训练，在相同的训练时间下，测试集正确率比 GRPO 更高。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-12.png"
                      alt="photo"
                ><br>下表展示了在长思维链场景下的更多对比结果：与同期基于相同基座模型（DeepSeek-R1-Distill-Qwen-1.5B）并使用 GRPO 方法训练得到的模型（DeepScaleR、STILL-3）相比，尽管 SPO 仅使用 MATH 数据集且仅使用 4K 的最大上下文长度进行训练，SPO-tree 在各个上下文长度评测下表现优秀。值得注意的是，尽管 DeepScaleR 在 32K 上下文长度评测下表现最佳，但它在较短上下文长度（2K 与 4K）下却表现最差，甚至不及原始基座模型。这表明，GRPO 训练方法可能未有效优化模型的 token 效率，导致输出存在较多冗余，从而在上下文长度有限的情形下出现正确率下降的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-13.png"
                      alt="photo"
                ></p>
<h2 id="分段粒度的影响"><a href="#分段粒度的影响" class="headerlink" title="分段粒度的影响"></a>分段粒度的影响</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-14.png"
                      alt="photo"
                ><br>通过实验发现，很细的粒度 (int2，每个两个切分点进行分段)，相比于中等粒度 (int5)，仅有微小提升，但是过粗的粒度 (int100)，相比于中等粒度 (int5)，正确率下降很大。证明了 SPO 采用中等粒度优势值的有效性。</p>
<h2 id="段划分方式的影响"><a href="#段划分方式的影响" class="headerlink" title="段划分方式的影响"></a>段划分方式的影响</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-15.png"
                      alt="photo"
                ><br>实验表明，在短思维链场景下，采用提出的基于切分点的段划分方式效果最好，优于采用换行符进行划分（VinePPO）以及固定 token 数量划分（Fixed-token-count）。</p>
<h2 id="Token-概率掩码消融"><a href="#Token-概率掩码消融" class="headerlink" title="Token 概率掩码消融"></a>Token 概率掩码消融</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-16.png"
                      alt="photo"
                ><br>实验表明，将 token 概率掩码去除会导致 SPO-chain 正确率下降，更值得注意的是：将 token 概率掩码应用到 GRPO 上，会让其正确率有明显上升。</p>
<h2 id="不同树结构的影响"><a href="#不同树结构的影响" class="headerlink" title="不同树结构的影响"></a>不同树结构的影响</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/640-17.png"
                      alt="photo"
                ><br>实验表明，更小的树结构在早期正确率更高，可能因为更快扫过更多的数据样本。然而随着训练的进行，更大的树结构会有更好的正确率，因为更大的树结构对于段级优势值的估计更加准确。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该工作提出了一种基于中间粒度段级优势值的 RL 训练框架 SPO，在 token 级和轨迹级之间更好的平衡，具有比轨迹级更好的信用分配，同时仅需要少量优势值估计点，可以使用有效无偏的 MC 方式进行估计，不需要额外的 critic 模型。</p>
<p>文章同时提出了 SPO 的两个实例，为短思维链场景设计的 SPO-chain 以及为长思维链场景设计的 SPO-tree，通过实验证明了 SPO 框架和两个实例的有效性。</p>
<h1 id="通过扩展费马大定理背后的关键见解的范围，四位数学家在构建数学“大统一理论”方面取得了巨大进步。"><a href="#通过扩展费马大定理背后的关键见解的范围，四位数学家在构建数学“大统一理论”方面取得了巨大进步。" class="headerlink" title="通过扩展费马大定理背后的关键见解的范围，四位数学家在构建数学“大统一理论”方面取得了巨大进步。"></a>通过扩展费马大定理背后的关键见解的范围，四位数学家在构建数学“大统一理论”方面取得了巨大进步。</h1><h2 id="文章来源-1"><a href="#文章来源-1" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://www.quantamagazine.org/the-core-of-fermats-last-theorem-just-got-superpowered-20250602/%E3%80%81" >https://www.quantamagazine.org/the-core-of-fermats-last-theorem-just-got-superpowered-20250602/、<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>1994年，一个震撼数学界的证明——数学家安德鲁·怀尔斯终于解决了费马大定理——这个数论领域的核心问题，三个多世纪以来一直悬而未决。这个证明不仅让数学家们着迷，还登上了《纽约时报》的头版。<br>但为了实现它，怀尔斯（在数学家理查德泰勒的帮助下）首先必须证明一个更微妙的中间陈述——其含义超出了费马难题。</p>
<p>这个中间证明涉及证明一种名为椭圆曲线的重要方程总是可以与一个完全不同的数学对象（称为模形式）联系起来。怀尔斯和泰勒本质上打开了连接不同数学领域的大门，揭示了每个领域看起来都像是另一个领域的扭曲镜像。怀尔斯和泰勒表明，如果数学家想要理解椭圆曲线，他们可以进入模形式的世界，找到并研究该对象的镜像，然后将他们的结论带回原处。</p>
<p>这种世界之间的联系被称为“模块化”，它不仅帮助怀尔斯证明了费马大定理，数学家们也很快利用它在各种先前难以解决的问题上取得了进展。</p>
<p>模块化也构成了朗兰兹纲领的基础。朗兰兹纲领是一套旨在发展数学“大统一理论”的宏大猜想。如果这些猜想成立，那么椭圆曲线以外的各种方程都将同样与其镜像域中的对象相联系。数学家将能够随心所欲地在两个世界之间跳跃，从而解答更多问题。</p>
<p>然而，证明椭圆曲线与模形式之间的对应关系却异常困难。许多研究人员认为，建立一些更为复杂的对应关系几乎是不可能的。</p>
<p>现在，一个由四位数学家组成的团队证明了他们错了。今年二月，他们终于成功扩展了模块化连接从椭圆曲线到更复杂的方程式，即阿贝尔曲面。团队——弗兰克·卡莱加里芝加哥大学乔治·博克瑟和托比·吉伦敦帝国理工学院和Vincent Pilloni法国国家科学研究中心的研究人员证明了，属于某一主要类别的每个阿贝尔曲面总是可以与一个模形式相关联。</p>
<p>Ana Caraiani表示：“我们大多相信所有的猜测都是正确的，但看到它真正实现，我们感到非常兴奋。”伦敦帝国理工学院的数学家。“而且这是你真的以为遥不可及的事情。”</p>
<p>这只是一场耗时多年的探索的开始——数学家们最终希望证明每个阿贝尔曲面都具有模性。但这一结果已经能够帮助解答许多悬而未决的问题，就像证明椭圆曲线的模性开辟了各种新的研究方向一样。</p>
<h2 id="挑战数学界的「禁区」"><a href="#挑战数学界的「禁区」" class="headerlink" title="挑战数学界的「禁区」"></a>挑战数学界的「禁区」</h2><p>椭圆曲线是一种非常基本的方程类型，它只包含两个变量——x和y 。如果你画出它的解，你会看到一些看似简单的曲线。但这些解之间有着丰富而复杂的相互关联，并且它们出现在数论的许多重要问题中。例如，伯奇和斯温纳顿-戴尔猜想——数学中最难的开放性问题之一，第一个证明它的人将获得100万美元的奖励——就是关于椭圆曲线解的性质的。</p>
<p>椭圆曲线很难直接研究。因此，数学家有时喜欢从不同的角度来研究它们。</p>
<p>这就是模形式发挥作用的地方。模形式是一种高度对称的函数，它出现在一个表面上独立的数学研究领域——分析。由于模形式表现出如此多的良好对称性，因此更容易处理。</p>
<p>乍一看，这些对象似乎毫无关联。但泰勒和怀尔斯的证明表明，每条椭圆曲线都对应一个特定的模形式。它们具有某些共同的性质——例如，描述椭圆曲线解的一组数字也会出现在其对应的模形式中。因此，数学家可以利用模形式对椭圆曲线获得新的见解。</p>
<p>但数学家们认为泰勒和怀尔斯的模定理只是一个普遍事实的例子。除了椭圆曲线之外，还有一类更为普遍的对象。所有这些对象在更广阔的对称函数世界（例如模形式）中也应该有一个伙伴。这本质上就是朗兰兹纲领的全部内容。</p>
<p>椭圆曲线只有两个变量——x和y——因此可以画在平面纸上。但如果添加另一个变量z，就会得到一个存在于三维空间中的曲面。这种更复杂的物体被称为阿贝尔曲面，与椭圆曲线一样，它的解也具有数学家们渴望理解的复杂结构。</p>
<p>阿贝尔曲面对应着更复杂的模形式，这似乎很自然。但额外的变量使得它们的构造更加困难，解也更加难求。证明它们也满足模性定理似乎完全遥不可及。“这是一个众所周知的问题，人们不去思考，因为人们思考过却陷入了困境，”吉说道。</p>
<p>但 Boxer、Calegari、Gee 和 Pilloni 想要尝试。</p>
<h2 id="寻找桥梁"><a href="#寻找桥梁" class="headerlink" title="寻找桥梁"></a>寻找桥梁</h2><p>这四位数学家都参与了朗兰兹纲领的研究，他们想要用“现实生活中真正出现的物体，而不是某种奇怪的东西”来证明其中一个猜想，卡莱加里说。</p>
<p>阿贝尔曲面不仅在现实生活中出现——确切地说，在数学家的生活中——而且证明关于它们的模性定理将打开新的数学大门。“如果你有了这个命题，你就能做很多事情，而如果没有这个命题，你就无法做到，”卡莱加里说。</p>
<p>这两位数学家于2016年开始合作，希望遵循泰勒和怀尔斯证明椭圆曲线时的步骤。但对于阿贝尔曲面来说，这些步骤中的每一个都复杂得多。</p>
<p>因此，他们专注于一种特殊类型的阿贝尔曲面，称为普通阿贝尔曲面，这种曲面更容易处理。任何这样的曲面，都有一组数字描述其解的结构。如果他们能证明同一组数字也能从模形式推导出来，那就大功告成了。这些数字将充当一个独特的标签，让他们能够将每个阿贝尔曲面与一个模形式配对。</p>
<p>问题在于，虽然对于给定的阿贝尔曲面，这些数字很容易计算，但数学家们却不知道如何构造一个具有完全相同标记的模形式。当需求如此受限时，模形式实在太难构建了。“你正在寻找的对象，你并不知道它们真的存在，”皮洛尼说。</p>
<p>相反，数学家们证明了，只需构造一个模形式，其数值在较弱的意义上与阿贝尔曲面的数值相匹配就足够了。该模形式的数值只需在所谓的时钟算术领域等价即可。</p>
<p>想象一个时钟：如果时针从 10 开始，经过四个小时，时钟将指向 2。但是时钟算术可以用任何数字来完成，而不仅仅是（就像现实世界的时钟一样）数字 12。</p>
<p>Boxer、Calegari、Gee 和 Pilloni 只需要证明，当他们使用一个精确到 3 的时钟时，他们的两组数字相匹配。这意味着，对于给定的阿贝尔曲面，数学家在构建相关模形式时具有更大的灵活性。</p>
<p>但事实证明，即便如此，这也太难了。</p>
<p>然后，他们偶然发现了大量模形式，其对应的数字很容易计算——只要他们根据最高可达 2 的时钟来定义它们的数字。但阿贝尔曲面需要一个最高可达 3 的时钟。</p>
<p>数学家们对如何粗略地连接这两个不同的时钟已经有了想法。但他们不知道如何使这种连接严密无懈可击，以便在模形式的世界中找到与阿贝尔曲面真正匹配的公式。后来，一个新的数学概念出现了，结果证明这正是他们所需要的。</p>
<h2 id="惊喜帮助"><a href="#惊喜帮助" class="headerlink" title="惊喜帮助"></a>惊喜帮助</h2><p>2020 年，数论学家潘略发布了证明关于模块化形式的研究，起初似乎与四人组的问题无关。但他们很快意识到，他所开发的技术出奇地相关。“我没想到，”潘说。</p>
<p>经过多年的定期会议（主要通过Zoom），数学家们开始在应用潘建伟的技术方面取得进展，但主要的障碍仍然存在。后来，在2023年夏天，Boxer、Gee和Pilloni认为在德国波恩举行的一次会议是他们聚在一起的绝佳机会。唯一的问题是，Calegari原计划在同一时间前往中国发表演讲。但一次前往芝加哥中国领事馆的艰难旅程让他重新考虑了这个想法。“八小时后，我的签证被拒签了，我的车也被拖走了，”他说。他决定放弃在中国的演讲，前往德国与他的同事们会合。</p>
<p>吉为团队在豪斯多夫研究所的地下室安排了一间房间，这样他们就不太可能被四处奔波的数学家打扰。在那里，他们花了整整一周的时间研究潘氏定理，日复一日，连续工作12个小时，只是偶尔上到地面喝咖啡。“喝完咖啡后，我们总是开玩笑说，我们得回矿井了，”皮洛尼说。</p>
<p>努力终有回报。“后来虽然有很多波折，”卡莱加里说，“但到那一周结束的时候，我觉得我们差不多成功了。”</p>
<p>又花了一年半的时间，才将卡莱加里的定罪证明整理成长达 230 页的证据，并于 2 月份将其发布到网上. 把所有的碎片放在一起，他们证明了任何普通的阿贝尔曲面都有一个相关的模形式。</p>
<p>他们的新门户未来或许能像泰勒和怀尔斯的成果一样强大，揭示出比任何人想象的都更多的关于阿贝尔曲面的信息。但首先，团队必须将他们的成果扩展到非常规阿贝尔曲面。他们已经与潘合作继续探索。“十年后，如果我们还没能找到几乎所有的阿贝尔曲面，那我才惊讶，”吉说道。</p>
<p>这项工作也使数学家们得以提出新的猜想——例如伯奇和斯温纳顿-戴尔猜想的类似猜想，它涉及阿贝尔曲面而非椭圆曲线。安德鲁·萨瑟兰说：“现在我们至少知道，对于这些普通曲面来说，这种类似猜想是合理的。”麻省理工学院的数学家。“以前我们不知道这一点。”</p>
<p>“我曾经梦想有一天能够证明的很多事情，现在都因为这个定理而触手可及了，”他补充道，“它改变了一切。”</p>
<h1 id="第一张由固体秘密量子几何构成的地图"><a href="#第一张由固体秘密量子几何构成的地图" class="headerlink" title="第一张由固体秘密量子几何构成的地图"></a>第一张由固体秘密量子几何构成的地图</h1><h2 id="文章来源-2"><a href="#文章来源-2" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="http://quantamagazine.org/first-map-made-of-a-solids-secret-quantum-geometry-20250606/" >http://quantamagazine.org/first-map-made-of-a-solids-secret-quantum-geometry-20250606/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>物理学家最近利用一种有望普及的新方法绘制出了晶体量子行为背后的隐藏形状。</p>
<p>众所周知，在量子尺度上，粒子可以同时处于多个可能的位置。粒子的状态像波一样向外扩散，在其可能出现的位置达到峰值。当你测量它的位置时，这种扩散状态（称为波函数）会转变为一个确定的位置。</p>
<p>波函数的完整形状长期以来一直难以探测，因为试图测量它会破坏它。但在20世纪80年代，物理学家开始开发测量和控制简单系统波函数的方法——这些进步后来构成了量子计算的基础。而在过去几年里，一种新的方法使物理学家能够更进一步，了解整个材料的波函数。</p>
<p>里卡多·科明说：“我们正处于第二次量子革命。”麻省理工学院实验物理学家，也是这项工作的领导者之一。“现在，我们拥有了真正探索量子粒子波函数的工具。”</p>
<p>新框架将波函数描述为一个在隐藏景观中移动的物体——这个空间被称为物质的“量子几何”。这个看不见的世界的山丘和山谷决定了给定物质的波函数如何变化，以及物质可以处于什么状态。</p>
<p>马克·博克拉斯说：“你可以深入了解量子材料中发生的事情，这可能会加速新现象的发现。”他是俄亥俄州立大学的物理学家，也是量子几何学领域的领军人物。</p>
<p>Comin 和他的同事最近测量了晶体的完整量子几何形状— 首次窥视真实材料的波函数。</p>
<p>让我们探索一下即将出现的隐藏景观。</p>
<h2 id="秘密几何"><a href="#秘密几何" class="headerlink" title="秘密几何"></a>秘密几何</h2><p>物理学家通常将粒子的波函数想象成一支箭头。如果粒子有两种可能的状态，他们就把这些选项表示为箭头指向的相反方向——比如向上和向下。如果粒子同时处于两种状态，那么箭头指向球体周围的某个位置，这两种状态分别对应极点。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/000.jpg"
                      alt="photo"
                ></p>
<p>箭头的方向反映了每种可能性的相对可能性。测量粒子会使箭头指向正上方或正下方，而每种结果的概率取决于它最接近哪个极点。</p>
<p>许多粒子拥有两种以上的可能状态，在这种情况下，箭头占据着一个高维空间。这无法直观地呈现，但数学知识能让物理学家了解粒子在特定时刻的波函数。</p>
<p>对于由许多粒子构成的材料，一个高维箭头可以表示其内部所有电子的组合状态。随着材料周围环境条件（例如温度或周围磁场强度）的改变，这个集合箭头会随之摆动。为了控制一种材料，物理学家需要知道在转动这些不同的旋钮时，箭头会如何旋转。</p>
<p>为了追踪，他们绘制了一张地图。例如，想象一下，你改变施加于材料上的磁场强度。在你的地图上，你将使东西方向与磁场强度相对应。当磁场较弱时（对应地图上的西），电子的波函数会处于某种状态，你可以用箭头表示。当磁场较强时，你的位置会更靠东，波函数也会呈现不同的状态。当你在地图上从西向东移动时，箭头会旋转，显示电子的波函数如何随着磁场的增减而变化。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/001.png"
                      alt="photo"
                ><br>此图可扩展，捕捉所有可调整材质的方式。每个可调节的旋钮或参数都会在图中增加一个可移动的新维度。</p>
<p>想象一下，当你在地图上移动时，追踪箭头旋转的速度。有了这些信息，地图就变成了3D，就像你在绘制山脉一样。地图上每个部分的地势越陡峭，电子的波函数围绕这些参数值的变化就越大。如果变化很大，你就在山上。如果一点变化都没有，你就在平地上。</p>
<p>一种名为量子度量的数学对象捕捉了这种景观的形状。它通过描述两点之间最短距离的路径来实现这一点。正如从纽约飞往北京的飞机不会穿过地球，而是会在地球表面弯曲飞行一样，两个量子态之间的路径揭示了它们所处的底层几何形状。</p>
<p>波函数的这种神秘几何结构几十年来一直未被发现。但当量子材料开始以其难以解释的行为让物理学家们感到惊讶时，20世纪80年代的物理学家们意识到，其中一些行为可以用材料波函数绕弯曲形状传播来解释。</p>
<p>想象一下，一支箭在平面上移动。它的方向不会改变。但在曲面上，当它绕着一个闭合的圆环移动后，箭头指向的方向会与它开始时不同。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/002.png"
                      alt="photo"
                ><br>同样的事情也可能发生在量子态上。想象一下，改变一种材料的条件，使波函数在图中移动，然后再将材料恢复到其初始状态。如果现在它的箭头指向一个新的方向，那么这种材料就是“拓扑的”：它隐藏的底层形状迫使材料进入了一种新的状态。</p>
<p>由底层拓扑结构引起的方向变化被称为贝里相，以推广这一概念的英国理论物理学家迈克尔·贝里的名字命名这个相位在循环路径上累积的方式称为贝里曲率，指的是箭秘密穿越的弯曲形状。</p>
<p>对科明来说，贝里相是“固体量子理论中最迷人的概念之一”。尽管贝里相长期以来未被实验者发现，但它却能产生奇异的物理后果。</p>
<h2 id="撒糖甜甜圈"><a href="#撒糖甜甜圈" class="headerlink" title="撒糖甜甜圈"></a>撒糖甜甜圈</h2><p>这种抽象的几何学在像科明这样的物理学家研究晶体（原子以重复模式排列的晶格）的实验室中变得栩栩如生。近年来，他们发现二维晶体（原子的扁平晶格，电子可以在其中双向移动）具有各种各样的量子行为。让我们看看为什么二维晶体的量子几何图会呈现出一种甜甜圈状的形状，称为环面。</p>
<p>一般来说，晶体中重复的模式限制了其中电子的可能状态。电子可以快速流动、缓慢流动，或者根本不流动，每种选择都对应着不同的集体波函数。对于二维晶体，​​物理学家可以在一张纸上绘制出可能状态的图：每个坐标对应于电子在垂直和水平方向上可能的动量。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/003.png"
                      alt="photo"
                ><br>由于晶体状态图会重复出现，因此沿着平面图边缘的一个方向移动会将你带回到另一侧。为了证明这一点，物理学家将平面图卷绕两次。首先，平面图变成圆柱体，然后圆柱体的两端相接，形成一个圆环。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/004.png"
                      alt="photo"
                ><br>改变条件，例如通过晶体运行电流，将改变电子的运动，这将推动这个圆环状地图上的箭头。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/005.png"
                      alt="photo"
                ><br>尤其是对于拓扑材料来说，调节旋钮，然后回到初始条件——换句话说，沿着环面追踪一条循环路径——会使电子的箭头指向与之前不同的方向。这意味着多个箭头，或者说波函数，可以在环面上的同一点共存，从而形成一个“不连续点”。</p>
<p>当电子经过这样的点时，它们的集体箭头突然翻转，材料的状态发生剧烈变化。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/09/006.png"
                      alt="photo"
                ><br>这种效应类似于电荷通过时，电子所受的力也会发生翻转。因此，拓扑材料可以被解读为承载着幽灵电荷，这些电荷会导致电子移动，就像感受到一个并不存在的力场一样。</p>
<p>20世纪80年代发现的“幽灵场”巩固了量子态隐藏几何结构与材料行为之间的联系。这项研究成果荣获2016年诺贝尔物理学奖。</p>
<h2 id="未知领域"><a href="#未知领域" class="headerlink" title="未知领域"></a>未知领域</h2><p>拓扑材料已不再神秘：物理学家们通常利用它们来发现物质的新相，并探索其在量子计算中的潜力。但直到最近，他们才开始欣赏量子几何的更完整图景，它不仅包括贝里曲率，还包括量子度规——一种存在于环面形地图顶部的崎岖地形的形状。几年前，量子度规帮助研究人员理解了二维晶体中发生的情况，这种晶体中存在着一种奇特的新型超导性。— 无阻力的电流流动。</p>
<h1 id="新的量子算法用一个量子比特分解数字"><a href="#新的量子算法用一个量子比特分解数字" class="headerlink" title="新的量子算法用一个量子比特分解数字"></a>新的量子算法用一个量子比特分解数字</h1><p>量子计算机目前仍然能力有限。几乎每次研究人员发现这些高科技机器未来应该擅长的领域时，总会有一种经典算法在普通计算机上也能同样出色地完成。一个值得注意的例外？分解数字。1994年，数学家彼得·肖尔（Peter Shor）设计了一种算法，使量子计算机能够以比传统机器更快的速度对大数进行因式分解。这种加速至关重要，因为快速因式分解算法可以使大多数数据加密方法失效。30多年来，研究人员一直在努力提升未来量子计算机的性能，并防范其进一步发展。</p>
<p>但Shor的因式分解算法也有局限性：要分解的数字越大，所需的量子计算机就越大、性能就越好。破解一个加密方案需要一台量子计算机在数十万台计算机上运行Shor的算法。高效量子比特（qubits）的计算能力。而如今的机器还远远达不到这个水平。</p>
<p>但一篇论文发布在科学预印本网站arxiv.org上的一篇论文描述了如何用少得多的量子比特（仅需一个）对任意数进行因式分解。在这项新研究中，研究人员展示了如何用一个量子比特和三个被称为振荡器的组件（振荡器是一种通常与其他量子技术（如光学系统）相关的现成设备）对任意大小的整数进行因式分解。</p>
<p>需要明确的是，这并非一项实用的进步：这个过程所需的能量比百万量子比特的量子计算机高出数倍。但它确实阐明了解决这类问题的新方法。“这不同于我们对计算的典型思考方式——不仅是量子计算，还有经典计算，” Ulysse Chabaud说。巴黎高等师范学院的计算机科学家，他没有参与这项新方法的研究。“这看起来很疯狂，甚至是不可能的。”</p>
<h2 id="良好的振荡"><a href="#良好的振荡" class="headerlink" title="良好的振荡"></a>良好的振荡</h2><p>归根结底，新方法之所以有效，在于其信息编码方式。经典计算机使用比特，比特可以取两个值之一。而量子比特，由于量子力学的复杂性，可以取多个值。但即使是量子比特，一旦被测量，也只能取两个值之一：0 或 1。</p>
<p>但罗伯特·科尼格表示，这并不是在量子设备中编码数据的唯一方法和卢卡斯·布伦纳慕尼黑工业大学。他们的工作重点是研究如何利用连续变量对信息进行编码，这意味着它们可以采用给定范围内的任意值，而不仅仅是某些特定的值。</p>
<p>过去，研究人员曾尝试改进Shor的因式分解算法，方法是使用连续系统模拟量子比特，并扩展其可能值集。但即使你的系统使用连续量子比特进行计算，它仍然需要大量的量子比特来分解数字，而且计算速度不一定更快。“我们想知道是否有更好的方法来使用连续变量系统，”König说。</p>
<p>他们决定回归本源。肖尔算法的秘诀在于，它利用被分解的数生成一个研究人员称之为周期函数的函数，该函数的值会以固定的间隔重复出现。然后，它使用一种名为量子傅里叶变换的数学工具来确定该周期的值——也就是函数重复一次所需的时间。由此，一些简单的代数运算就能揭示出原始数的因数。</p>
<p>当 König 和 Brenner 尝试寻找另一种连续的因式分解方法时，他们很快想到了量子振荡器。量子振荡器产生的重复模式，在测量后可以呈现任何连续值（这与量子比特不同）。König 表示，这些模式就像内置的量子傅里叶变换一样。</p>
<p>“我和卢卡斯开始讨论这个混合量子比特振荡器系统，”柯尼格说。但他们当时的想法还很模糊，于是两人请来同事利博·卡哈（Libor Caha）和泽维尔·科伊特-罗伊（Xavier Coiteux-Roy）来设计基于该系统的量子算法。</p>
<p>几个月后，König 团队证明，在使用量子振荡器而非量子比特的系统中，这些物理组件的动态特性确实可以执行因式分解的数学运算——无需模拟量子比特的离散值。他们系统中的单个量子比特读取并组织振荡器中的信息，但并不像其他量子计算机中的量子比特那样执行实际的计算。与 Shor 算法一样，新方法能够在合理的时间内分解整数。</p>
<p>这项研究还指出了在量子计算中实现连续方法的新可能性。“这篇论文表明，通过使用感觉非常合理的操作，他们成功地实现了一些感觉完全不合理的事情，”Chabaud 说。“这是一件非常酷的事情，当结果出来时，我非常兴奋。”</p>
<h2 id="足够短"><a href="#足够短" class="headerlink" title="足够短"></a>足够短</h2><p>但这种方法也有一个陷阱：需要分解的数越大，振荡器进行运算所需的能量就越大。因此，分解一个大数虽然只使用一个量子比特，但却需要几乎难以想象的能量。“如果我给你一个大数进行分解，你就必须利用多颗恒星的能量才能运行算法，更不用说控制发生的一切了，”Chabaud 说。</p>
<p>对于阿拉姆·哈罗麻省理工学院的物理学家认为，这使得新的结果毫无用处。“我不明白用这种方式进行整个计算有什么意义。”</p>
<p>但慕尼黑团队已开始着手通过微调振荡器的数量及其运作方式来降低能耗。“或许，使用更多的振荡器就能降低能耗，”柯尼希说道。</p>
<p>因式分解只是这种新计算方法的应用示例之一；该团队正在寻找其他方法。“我们可以尝试将任何量子计算转化为这种装置，”König 说，“不一定非得是 Shor 算法。”他的团队已经证明，量子比特并非计算的唯一引擎，振荡器也可以充当基本的信息载体。而且，量子设备中现有的其他组件也可能被用来执行计算。</p>
<p>“对我来说，这就是这篇论文真正的创新之处，”Chabaud说。“你实际上可以使用连续变量系统运行一些有趣的算法。”</p>
<h1 id="苹果推出-iPadOS-26，带来全新外观和更强大的多任务处理功能"><a href="#苹果推出-iPadOS-26，带来全新外观和更强大的多任务处理功能" class="headerlink" title="苹果推出 iPadOS 26，带来全新外观和更强大的多任务处理功能"></a>苹果推出 iPadOS 26，带来全新外观和更强大的多任务处理功能</h1><p>iPad 迎来关键软件更新，实现其真正潜力。15年来，iPad 终于获得了可调整大小和移动窗口等重要功能。这些改进使其更像一台真正的电脑，标志着iPad发展的一个重要里程碑。<br>苹果在WWDC上发布了全新的iPadOS 26，带来了重大更新。主要亮点是改进的多任务处理功能，包括全新的窗口系统，允许用户自由调整应用窗口大小和位置。新系统还包含新的文件应用、更多Apple Intelligence功能，以及类似Mac的预览应用，用于查看和编辑PDF。iPadOS 26也采用了受Vision Pro启发的“Liquid Glass”视觉语言，并延续了苹果的命名方式，从版本号改为年份。新的窗口系统可以在Stage Manager中使用，并支持多显示器。<br>iPad 今年迎来了重大更新：苹果刚刚在 WWDC 上发布了其平板电脑操作系统 iPadOS 的新版本。iPadOS 的旗舰功能是用于跨应用多任务处理的全新窗口系统，此外还有全新的文件应用、更多 Apple Intelligence 功能，以及类似 Mac 的预览应用，可用于查看和编辑 PDF。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/10/001.png"
                      alt="photo"
                ><br>与往常一样，新 iPadOS 与新 iOS 有很多共同之处，包括受 Vision Pro 启发的新视觉语言“液态玻璃”。更新后的名称也遵循了苹果的整体方案，从版本号改为年份。iPad 在多任务处理方式、应用程序之间移动方式以及操作系统方面往往有所不同。在 iPadOS 26 中，这种差异比以往任何时候都更加明显：苹果表示，它将允许您“流畅地调整应用程序窗口大小”并将窗口放置在屏幕上的任何位置。窗口系统也可以在 Stage Manager 中使用，并且可以跨显示器工作。Stage Manager 并不总是最直观的 iPad 软件，但这看起来是朝着正确的多任务处理迈出的坚实一步。</p>
<p>iPad 一直以来都横跨 Mac 和 iPhone，有人认为它应该更像其中之一，而不是完全处于两者之间。今年 WWDC 前的传闻似乎暗示了它更以 Mac 为中心，事实也确实如此。iPad 现在有一个菜单栏，你可以从显示屏顶部向下滑动来访问，其中会显示你正在查看的应用程序的各种控制按钮。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/10/002.png"
                      alt="photo"
                ><br>此外，还有一款新的预览应用，苹果称它既可以查看 PDF，也可以标记 PDF（当然，它支持 Apple Pencil）。文件应用中也采用了更 Mac 风格的列表视图。开发者甚至可以让他们的应用在后台运行得更高效，并显示在 Live Activities 中，让你了解当前运行情况。</p>
<p>除了所有高级用户功能外，iPad 还将获得此前仅适用于 iPhone 的 Journal 应用，以及访问 Apple Games hub 的权限，方便用户畅玩所有 Apple 游戏产品。iPad 还新增了一项游戏覆盖功能，让用户无需切换应用即可更新设置并与好友聊天。</p>
<p>新操作系统今日起面向开发者开放。苹果表示，公测版将于下个月发布，更新将于今年秋季正式发布。以下是苹果官方发布的支持设备列表：</p>
<ul>
<li>iPad Pro (M4)</li>
<li>iPad Pro 12.9 英寸（第 3 代及更新机型）、iPad Pro 11 英寸（第 1 代及更新机型）</li>
<li>iPad Air（M2 及更高版本）、iPad Air（第三代及更高版本）</li>
<li>iPad (A16)、iPad（第八代及更高版本）</li>
<li>iPad mini（A17 Pro）、iPad mini（第五代及更高版本）。</li>
</ul>
<h1 id="地球望远镜为宇宙黎明提供了新的视角"><a href="#地球望远镜为宇宙黎明提供了新的视角" class="headerlink" title="地球望远镜为宇宙黎明提供了新的视角"></a>地球望远镜为宇宙黎明提供了新的视角</h1><h2 id="文章来源-3"><a href="#文章来源-3" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://phys.org/news/2025-06-earth-based-telescopes-fresh-cosmic.html" >https://phys.org/news/2025-06-earth-based-telescopes-fresh-cosmic.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>科学家首次利用地球望远镜回顾过去 130 亿年，以了解宇宙中的第一批恒星如何影响大爆炸发出的光。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/11/001.jpg"
                      alt="photo"
                ><br>天体物理学家利用位于智利北部安第斯山脉高处的望远镜测量了这种偏振微波，从而更清晰地描绘出宇宙历史上最不为人所知的时期之一——宇宙黎明。</p>
<p>“人们认为这不可能在地面上完成。天文学是一个技术受限的领域，而‘宇宙黎明’号发出的微波信号以难以测量而闻名，”项目负责人、约翰·霍普金斯大学物理学和天文学教授托拜厄斯·马里奇说道。“与太空观测相比，地面观测面临着额外的挑战。克服这些障碍使这次测量成为一项重大成就。”</p>
<p>宇宙微波的波长仅为几毫米，非常微弱。偏振微波信号则要弱上百万倍。地球上的无线电广播、雷达和卫星信号可能会掩盖它们的信号，而大气、天气和温度的变化也会使其失真。即使在理想条件下，测量这种微波也需要极其灵敏的设备。</p>
<p>美国国家科学基金会宇宙学大角度尺度探测器（CLASS）项目的科学家使用独特设计的望远镜探测到宇宙大爆炸遗迹中第一批恒星留下的“指纹”——这一壮举此前只有部署在太空的技术才能实现，例如美国国家航空航天局威尔金森微波各向异性探测器（WMAP）和欧洲航天局普朗克太空望远镜。</p>
<p>这项由约翰·霍普金斯大学和芝加哥大学领导的新研究发表在《天体物理学杂志》上。</p>
<p>通过将 CLASS 望远镜的数据与普朗克和 WMAP 太空任务的数据进行比较，研究人员发现了干扰，并缩小了来自偏振微波光的共同信号范围。</p>
<p>当光波遇到某物然后散射时，就会发生偏振。</p>
<p>“当光线照射到汽车引擎盖上时，你会看到眩光，这就是偏振。为了看得清楚，你可以戴上偏光眼镜来消除眩光，”第一作者李云阳（Yunyang Li）说道。李云阳曾是约翰·霍普金斯大学的博士生，后来在研究期间担任芝加哥大学的研究员。</p>
<p>“利用新的通用信号，我们可以确定我们所看到的有多少是从宇宙黎明号引擎盖反射出来的宇宙眩光。”</p>
<p>大爆炸之后，宇宙是一团电子雾，密度之高以至于光能无法逃逸。随着宇宙膨胀和冷却，质子捕获电子形成中性氢原子，微波由此得以自由地穿过其间的空间。在宇宙黎明时期，当第一批恒星形成时，它们强大的能量将电子从氢原子中剥离出来。研究小组测量了来自大爆炸的光子在穿越电离气体云时遇到其中一个被释放的电子并偏离轨道的概率。</p>
<h1 id="中国的复合极端事件与健康风险：综述"><a href="#中国的复合极端事件与健康风险：综述" class="headerlink" title="中国的复合极端事件与健康风险：综述"></a>中国的复合极端事件与健康风险：综述</h1><h2 id="文章来源-4"><a href="#文章来源-4" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="http://sciencedirect.com/science/article/pii/S1674283425000595?via=ihub" >http://sciencedirect.com/science/article/pii/S1674283425000595?via%3Dihub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>中国一项研究表明，复合型极端天气事件正在中国构成潜在的健康危机。这些复合事件，如干旱与热浪并存，或洪涝与空气污染齐至，其综合影响对公众健康构成日益严重的威胁。研究揭示了这些复合事件发生的频率增加，以及它们对不同地区人口健康的影响。该研究强调了应对气候变化和减轻复合极端事件对健康影响的必要性。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/11/002.jpg"
                      alt="photo"
                ><br>在全球恐慌的背景下，中国面临严峻的严酷和严重的极端气候天气事件，其中以多种气候驱动因子和&#x2F;或灾害应对而导致的复合型极端事件风险亟待突出。 本文首先回顾了中国区域复合型极端事件的定义与划分型； 然后综述了不同类型复合型极端事件的演变特征，形成了机制以及未来股票等方面的研究进展； 探讨了日夜持续型极端高温事件、温湿复合事件以及高温复合事件等三类事件对我国人群健康的潜在风险及可能的影响途径； 最后，风险阐述了复合型极端事件灾害评估框架，并在此基础上提出了基于碳中和目标的应对策略。 在总结上述研究成果的基础上，提出了五个未来预测需关注的研究方向：（1）复合事件灾害风险链的识别问题； (2)安装数据和连接模式性能的抵消问题； (3)复合型极端事件的归因与成因问题； (4)碳排放与空气质量改善的最优化路径问题； (5)多学科、多区域、多部门的合作问题。 加强上述方向的研究有助于深入对复合型极端事件的理解，并为我国气候变化适应和健康风险应对提供科技支撑</p>
<p>近百年来，受全球变暖影响，中国气候发生了显著变化。随着地表温度升高，热浪、极端降雨、干旱、台风、风暴潮等区域极端事件发生的频率和强度都有所增加，对公众健康、生态系统、粮食安全和社会经济系统构成了重大挑战。极端事件通常分为天气极端事件和气候极端事件。极端天气是指在特定时间和地点发生的罕见气象事件，具有统计概率低的特点。而气候极端事件是指气象变量在较长时期内持续异常，有可能导致极端的季节平均值或总量（IPCC，2021）。为推动全球变暖背景下极端事件的研究，世界气象组织和世界气候研究计划成立了气候变化检测和指数专家组（ETCCDI）。该团队基于统一的框架定义了27个具有代表性的极端温度和降水指数（张建军等，2011），广泛应用于全球和区域极端天气气候事件的研究。极端事件的定义通常有两种：基于固定值的绝对阈值和基于百分位数的相对阈值。例如，中国的气象业务系统将连续三天气温超过35℃的时段定义为热浪。但由于气候变量的时空异质性，研究中倾向于使用基于百分位数的相对阈值或基于极值理论的参数估计方法来定义极端事件。<br>近年来，中国极端事件呈现出三个新特点。一是极端事件分布范围不断扩大，高影响低概率事件频发，灾害影响不再局限于特定区域，而是波及范围越来越广。二是极端事件发生突发性增强，不可预见事件增多，并出现了前所未有的灾害组合。三是极端事件的极端化趋势明显，极端事件发生的频率和强度均有所增加。这些新特点对中国的民生、经济发展和社会公平产生了负面影响，也对气象灾害风险管理、应急响应和气候适应战略提出了重大挑战。与单一驱动因素引发的极端事件相比，两个或多个极端事件同时或连续发生往往造成更为严重的社会和环境后果。这种由多种气候驱动因素和&#x2F;或灾害共同作用，造成社会或环境风险的现象被称为复合极端事件。这些已经发展成为气候变化研究领域的前沿问题和重大科学挑战( Zscheischler 等，2018；Yu 等，2023 )。<br>随着中国城镇化和工业化的快速推进，大气污染已成为重大环境问题和居民健康威胁（Zheng et al.，2023）。为解决这些问题，中国政府实施了各种监管措施，例如自2013年以来实施的第一个五年清洁空气行动和蓝天保卫战计划。这些努力使PM 2.5污染明显减少，尽管水平仍未达到世界卫生组织设定的高标准（Xue et al.，2019）。然而，在暖季，中国东部地区近地面臭氧浓度仍然很高，持续性臭氧污染事件发生频率增加。这已成为影响中国夏季空气质量的主要因素。臭氧属于二次污染物，主要通过光化学反应形成，其前体物包括挥发性有机化合物、一氧化碳和氮氧化物。在人口密集的中国东部地区，供暖和交通运输严重依赖化石燃料和生物燃料，导致臭氧前体物排放急剧增加，不仅导致臭氧浓度升高，还催化光化学烟雾的形成，对公众健康、生态系统和农业生产构成严重威胁。</p>
<h1 id="数十年来AlCl偶极矩之谜得以解决"><a href="#数十年来AlCl偶极矩之谜得以解决" class="headerlink" title="数十年来AlCl偶极矩之谜得以解决"></a>数十年来AlCl偶极矩之谜得以解决</h1><h2 id="文章来源-5"><a href="#文章来源-5" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://phys.org/news/2025-06-decades-mystery-alcl-dipole-moment.html" >https://phys.org/news/2025-06-decades-mystery-alcl-dipole-moment.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在一项填补基础科学领域长期存在的知识空白的研究中，加州大学河滨分校的研究人员 Boerge Hemmerling 和 Stephen Kane 成功测量了氯化铝 (AlCl) 的电偶极矩，AlCl 是一种简单但在科学上至关重要的双原子分子。</p>
<p>他们的研究成果发表在《物理评论A》上，对量子技术、天体物理学和行星科学具有重要意义。论文题为《利用斯塔克能级光谱法测量氯化铝的电偶极矩》。</p>
<p>到目前为止，AlCl的偶极矩仅被估算，而没有实验证实。这项研究的精确测量如今用可靠的实验数据取代了理论预测。</p>
<p>当分子内部正负电荷分离，导致电子分布不均匀时，就会产生电偶极矩。对于像氯化铝这样的分子来说，它决定了分子之间以及与周围环境的相互作用。</p>
<p>“在化学中，偶极矩影响从键合行为到溶剂相互作用的一切，”物理学和天文学副教授赫默林说。</p>
<p>在生物学中，它们影响着水中氢键等现象。在物理学和天文学中，可以利用偶极矩使相邻分子相互作用，例如，在它们之间建立量子纠缠。</p>
<p>Hemmerling解释说，AlCl在多个科学领域发挥着至关重要的作用。他表示，这种分子已成为超冷量子计算平台开发中一个很有希望的候选材料，而精确理解由偶极矩驱动的分子间相互作用至关重要。</p>
<p>“之前假设的约1.5德拜只是一个历史性的占位符，”Hemmerling说。“我们的实验结果提供的约1.68德拜的最终值可以用于规划高精度实验，并提高理论模型的准确性。”</p>
<p>在渐近巨星支（AGB）恒星的大气中检测到了氯化铝（AlCl），这些恒星正处于恒星演化的晚期阶段。AGB恒星经历了显著的质量损失和元素重新分布；了解它们的化学成分对于追踪恒星和行星的演化至关重要。</p>
<p>地球与行星科学系行星天体物理学教授凯恩说：“准确的偶极矩数据可以改善我们对星光中分子特征的解读。”</p>
<p>我们的发现将有助于改进迄今为止依赖于替代值或估计值的天体物理模型。这包括用于分析詹姆斯·韦伯太空望远镜等尖端天文台数据的模型。</p>
<p>凯恩认为，铝和氯在行星形成的地球化学中分别扮演着不同的角色。他表示，放射性铝同位素有助于核心分化，而氯的分布则有助于绘制行星演化图。</p>
<p>他说：“通过 AlCl 测量揭示的恒星中铝与氯的比例为恒星核合成和这些天体的物质历史提供了关键线索。”</p>
<p>该研究采用了加州大学河滨分校历时七年开发的复杂实验装置，包括定制激光器、真空系统和专为高精度光谱设计的电子设备。</p>
<p>通过在真空中产生 AlCl 光束并分析其光谱行为，该团队与康涅狄格大学的 Daniel McCarron 合作，此前首次能够确定该分子的超精细结构和同位素位移。</p>
<p>加州大学河滨分校的研究小组旨在继续探索 AlCl。</p>
<p>赫默林说：“从提高我们对遥远恒星的理解到实现下一代量子计算机，精确测量 AlCl 的电偶极矩是迈向未来发现的基础性一步。”</p>
<p>“我们现在还可以高精度地研究其他分子和原子，为天体化学、基础物理学和材料科学领域激动人心的新发现铺平道路。”</p>
<p>该团队的下一个目标之一是 HoF，一种可能有助于测试物理学标准模型边界的分子。</p>
<p>“这项研究提醒我们，我们对哪怕是最基本的分子也并非完全了解，”赫默林说，“但现代技术为我们提供了探索的工具。”</p>
<p>该项目与洛斯阿拉莫斯国家实验室的理论家 Brian Kendrick 合作。</p>
<blockquote>
<p>更多信息： Li-Ren Liu 等人，利用斯塔克能级光谱测量 AlCl 的电偶极矩，《物理评论 A》（2025 年）。DOI ：10.1103&#x2F;hwwm-1mn7</p>
<p>期刊信息： Physical Review A </p>
</blockquote>
<h1 id="苹果的一项新研究质疑人工智能模型是否真正通过问题进行“推理”"><a href="#苹果的一项新研究质疑人工智能模型是否真正通过问题进行“推理”" class="headerlink" title="苹果的一项新研究质疑人工智能模型是否真正通过问题进行“推理”"></a>苹果的一项新研究质疑人工智能模型是否真正通过问题进行“推理”</h1><h2 id="文章来源-6"><a href="#文章来源-6" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://arstechnica.com/ai/2025/06/new-apple-study-challenges-whether-ai-models-truly-reason-through-problems/" >https://arstechnica.com/ai/2025/06/new-apple-study-challenges-whether-ai-models-truly-reason-through-problems/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>6月初，苹果研究人员发布了一项研究，表明模拟推理 (SR) 模型（例如 OpenAI 的o1和o3、DeepSeek-R1和Claude 3.7 Sonnet Thinking）在面对需要系统性思维的新型问题时，其输出结果与训练数据的模式匹配结果一致。研究人员的发现与美国数学奥林匹克(USAMO) 4 月份的一项研究结果类似，表明这些模型在新型数学证明方面得分较低。</p>
<p>这项新研究名为“思考的错觉：通过问题复杂性的视角理解推理模型的优势和局限性”，由苹果公司的 Parshin Shojaee 和 Iman Mirzadeh 领导的团队完成，Keivan Alizadeh、Maxwell Horton、Samy Bengio 和 Mehrdad Farajtabar 也参与其中。</p>
<p>研究人员研究了他们所谓的“大型推理模型”（LRM），该模型试图通过生成有时被称为“思路链推理”的审议性文本输出来模拟逻辑推理过程，表面上以逐步的方式帮助解决问题。</p>
<p>为了做到这一点，他们让人工智能模型对抗四个经典谜题——汉诺塔（在桩之间移动圆盘）、跳棋（消除棋子）、过河（在限制条件下运输物品）和积木世界（堆叠积木）——从非常简单（比如一个圆盘的汉诺塔）到极其复杂（20 个圆盘的汉诺塔需要超过一百万次移动）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/12/001.png"
                      alt="photo"
                ><br>研究人员写道：“目前的评估主要侧重于已建立的数学和编码基准，强调最终答案的准确性。” 换句话说，如今的测试只关心模型是否能够正确回答可能已经存在于其训练数据中的数学或编码问题——它们并不考察模型是否真正推理出了答案，还是仅仅根据之前见过的例子进行了模式匹配。</p>
<p>最终，研究人员得出的结果与前述USAMO 的研究一致：这些模型在新型数学证明上的准确率大多低于 5%，只有一个模型达到了 25%，并且在近 200 次尝试中没有一个模型能达到完美证明。两个研究团队都记录了在需要扩展系统推理的问题上性能的严重下降。</p>
<h2 id="已知的怀疑论者和新证据"><a href="#已知的怀疑论者和新证据" class="headerlink" title="已知的怀疑论者和新证据"></a>已知的怀疑论者和新证据</h2><p>人工智能研究员加里·马库斯（Gary Marcus）长期以来一直认为神经网络难以实现分布外的泛化，他称苹果的研究结果“对法学硕士（LLM）来说相当具有毁灭性”。尽管马库斯多年来一直提出类似的论点，并以对人工智能的怀疑态度而闻名，但这项新研究为他独特的批评观点提供了新的实证支持。</p>
<p>马库斯写道：“法学硕士无法可靠地解决汉诺塔问题，这真是令人尴尬。”他指出，人工智能研究员赫伯·西蒙早在1957年就解决了这个难题，而且网络上也有很多算法解决方案。马库斯指出，即使研究人员提供了解决汉诺塔问题的明确算法，模型性能也没有提高——该研究的联合负责人伊曼·米尔扎德认为，这一发现表明“他们的流程既不合逻辑，也不智能”。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/12/002.jpg"
                      alt="photo"
                ><br>苹果团队发现，模拟推理模型的表现与“标准”模型（如 GPT-4o）根据谜题难度的不同而有所不同。在简单任务（例如只有几个圆盘的汉诺塔）中，标准模型实际上胜出，因为推理模型会“过度思考”，并产生导致错误答案的长串思维。在中等难度的任务中，SR 模型的系统性方法使其更具优势。但在真正困难的任务（例如拥有 10 个或更多圆盘的汉诺塔）中，两种模型都彻底失败，无论给予多少时间都无法完成谜题。</p>
<p>研究人员还发现了所谓的“反直觉扩展极限”。随着问题复杂性的增加，模拟推理模型最初会产生更多的思考标记，但随后会在超过阈值后减少推理努力，尽管拥有足够的计算资源。</p>
<p>该研究还揭示了模型失败过程中令人费解的不一致之处。Claude 3.7 Sonnet 在汉诺塔游戏中最多可以完成 100 步正确移动，但在过河游戏中仅移动 5 步就失败了——尽管后者所需的总移动步数更少。这表明，这些失败可能与特定任务有关，而非纯粹的计算问题。</p>
<h2 id="出现相互竞争的解释"><a href="#出现相互竞争的解释" class="headerlink" title="出现相互竞争的解释"></a>出现相互竞争的解释</h2><p>然而，并非所有研究人员都认同这些结果体现了基本推理能力的局限性。多伦多大学经济学家凯文·A·布莱恩（Kevin A. Bryan）在X上指出，观察到的局限性可能反映的是刻意的训练限制，而非内在的缺陷。</p>
<p>“如果你让我解决一个需要用纸笔写一个小时的问题，但给我五分钟，我可能会给你一个近似解或启发式方法。这正是强化学习（RL）所要求具备思维的基础模型所做的事情。”布莱恩写道，他建议通过强化学习（RL）对模型进行专门训练，以避免过度计算。</p>
<p>Bryan 认为，一些未指定的行业基准测试表明，“在几乎每个尝试过的问题领域，随着用于推理的 token 数量的增加，性能都会严格提升”，但他指出，部署的模型会刻意限制这种性能，以防止对简单查询进行“过度思考”。这种观点表明，苹果的论文衡量的可能是人为设定的约束，而非基本的推理极限。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/06/12/003.jpg"
                      alt="photo"
                ><br>软件工程师Sean Goedecke在他的博客上对苹果的论文提出了类似的批评，他指出，当面对需要超过 1000 步移动的汉诺塔游戏时，DeepSeek-R1“立即认定‘手动生成所有这些移动是不可能的’，因为这需要追踪超过一千步移动。因此，它不停地寻找捷径，最终失败了。” Goedecke 认为，这代表模型选择不尝试这项任务，而不是无法完成它。</p>
<p>其他研究人员也质疑这些基于谜题的评估方法是否适用于法学硕士（LLM）。独立人工智能研究员西蒙·威利森（Simon Willison）在接受Ars Technica采访时表示，汉诺塔方法“无论是否具备推理能力，都并非应用LLM的合理方法”，并指出失败可能仅仅反映了上下文窗口（AI模型能够处理的最大文本量）中标记耗尽，而非推理能力不足。他认为这篇论文可能存在夸大其词的现象，之所以受到关注，主要是因为其“令人无法抗拒的标题”——苹果声称LLM不具备推理能力。</p>
<p>苹果研究人员本人也警告不要过度推断他们的研究结果，并在其局限性部分承认，“谜题环境只代表了推理任务的一小部分，可能无法捕捉现实世界或知识密集型推理问题的多样性。” 该论文还承认，推理模型在“中等复杂度”范围内有所改进，并继续在一些现实世界的应用中展现出实用性。</p>
<h2 id="其影响仍有争议"><a href="#其影响仍有争议" class="headerlink" title="其影响仍有争议"></a>其影响仍有争议</h2><p>这两项研究是否彻底摧毁了关于人工智能推理模型的论断的可信度？未必。</p>
<p>这些研究或许表明，SR 模型所使用的扩展上下文推理技巧或许并非像某些人所希望的那样，成为通往通用智能的途径。在这种情况下，通往更稳健推理能力的道路可能需要从根本上改变方法，而不是对现有方法进行改进。</p>
<p>正如威利森上文所述，苹果公司的研究结果迄今为止在人工智能界引起了轰动。生成式人工智能是一个备受争议的话题，围绕该模型的普遍实用性展开的意识形态之争中，许多人倾向于极端立场。许多生成式人工智能的支持者对苹果公司的研究结果提出了质疑，而批评者则认为这项研究是对法学硕士（LLM）可信度的致命一击。</p>
<p>苹果的成果，加上USAMO的发现，似乎强化了像马库斯这样的批评者的观点，即这些系统依赖于复杂的模式匹配，而不是其营销宣传中暗示的那种系统性推理。公平地说，生成式人工智能领域的大部分内容都比较新，甚至连其发明者都还不完全理解这些技术的工作原理和原理。与此同时，人工智能公司或许可以通过缓和一些关于推理和智能突破的宣传来建立信任。</p>
<p>然而，这并不意味着这些人工智能模型毫无用处。即使是复杂的模式匹配机器，只要了解它们的缺点和虚构性，也能为使用者节省不少体力。正如 Marcus 所承认的：“至少在未来十年，法学硕士（无论是否具备推理时间）仍将有其用处，尤其是在编程、头脑风暴和写作方面。”</p>
<h1 id="如果公司愿意，每周工作四天可以提高效率"><a href="#如果公司愿意，每周工作四天可以提高效率" class="headerlink" title="如果公司愿意，每周工作四天可以提高效率"></a>如果公司愿意，每周工作四天可以提高效率</h1><h2 id="文章来源-7"><a href="#文章来源-7" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://phys.org/news/2025-06-day-week-productive-company-committed.html" >https://phys.org/news/2025-06-day-week-productive-company-committed.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>如果企业真正致力于推行四天工作制，那么每周四天工作制可以提高生产力，改善工作与生活的平衡，并留住人才。这些是“创新工作”（InnovaWorking）项目的部分结论。该项目由马德里卡洛斯三世大学（卡三）协调，是一个欧洲科研项目。该项目今天在欧洲议会提交了这项研究。其研究重点关注欧盟各国工会与雇主之间协商制定的创新工作时间政策。</p>
<p>“我们得出的结论是，每周四天工作制以及远程办公、假期购物和弹性工作时间等灵活的工作时间安排非常有效。最重要的是，当公司或实体真正致力于此时，”InnovaWorking 项目首席研究员、卡三法学院经济与法律研究所 (IUDEC) 的安娜·贝伦·穆尼奥斯·鲁伊斯 (Ana Belén Muñoz Ruiz) 解释道。</p>
<p>在本研究项目中，我们对六个欧洲国家的公共和私营部门的工作与生活平衡政策进行了分析：西班牙、芬兰、法国、匈牙利、爱尔兰和荷兰。</p>
<p>这项科学项目已确定，工作时间安排的创新变革可以提高生产力，改善员工的工作与生活平衡，并留住人才。“每周四天工作制吸引了众多技术工人。率先实施该制度的公司将拥有更加敬业的员工，并且更不愿意跳槽到竞争对手那里。”</p>
<p>参与 InnovaWorking 项目的另一位研究人员、马德里康普顿斯大学劳动和社会保障法系的 Pablo Gimeno Díaz de Atauri 表示：“因此，对于先锋公司来说，在这些措施成为普遍规则之前选择这些措施是具有战略意义的。”</p>
<p>研究人员还分析了工人通过工会参与的重要性，但他们指出，最好避免使用“神奇公式”。“并非所有行业都能提供相同的解决方案。为了使一切顺利进行，重要的是企业要考虑到其具体的生产、组织和轮班条件，并让工人代表表达他们的需求，”卡三社会与国际私法系教授安娜·贝伦·穆尼奥斯·鲁伊斯（Ana Belén Muñoz Ruiz）说道。</p>
<h2 id="科技领域以外的劳动力创新"><a href="#科技领域以外的劳动力创新" class="headerlink" title="科技领域以外的劳动力创新"></a>科技领域以外的劳动力创新</h2><p>该项目研究的案例表明，这些措施可以应用于科技行业以外的领域，例如建筑、金属或餐饮业。然而，研究发现，并非所有国家对弹性工作时间的反应都相同。</p>
<p>例如，在法国和西班牙等国家立法保障集体谈判且集体协议具有约束力的国家，集体谈判模式更具创新性。另一方面，在匈牙利和爱尔兰，社会对话较弱，法律僵化程度较高，谈判传统也较弱，因此集体谈判的倡议往往来自企业。</p>
<p>欧洲大多数国家人口老龄化持续加剧，导致劳动力年龄结构发生变化。一些公司正在采取各种举措，例如减少每周工作时间，以鼓励年长员工留在公司。</p>
<p>研究人员认为，在这种新形势下，有必要重新思考工作时间的安排，使其适应多元化劳动力的需求以及当前的社会和经济挑战。事实上，InnovaWorking 的研究成果可能会对欧洲关于工作场所数字化扩展的劳工政策产生影响，同时也证明了有必要规范劳动者的数字脱节权。</p>
<h1 id="你的呼吸方式就像指纹一样，可以识别你"><a href="#你的呼吸方式就像指纹一样，可以识别你" class="headerlink" title="你的呼吸方式就像指纹一样，可以识别你"></a>你的呼吸方式就像指纹一样，可以识别你</h1><h2 id="文章来源-8"><a href="#文章来源-8" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://www.nature.com/articles/d41586-025-01835-0" >https://www.nature.com/articles/d41586-025-01835-0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>研究表明，你的吸气和呼气模式不仅是独一无二的，它还可以作为你身体和精神状态的标志。<br>就像指纹中的漩涡一样，一个人的呼吸模式可能是独一无二的——这不仅可以用来识别个人，还可以识别他们的一些身体和心理特征。</p>
<p>一组研究人员对97名健康受试者进行了24小时的呼吸测量，发现仅凭呼吸模式就能相对准确地识别参与者。此外，他们还发现这些模式与体质指数（BMI）以及抑郁和焦虑的迹象存在关联。</p>
<p>“某种程度上，我们是通过鼻子来读心的，”该研究的共同作者、以色列雷霍沃特魏茨曼科学研究所的神经生物学家诺姆·索贝尔（Noam Sobel）说道。“这可能是一种非常强大的诊断工具。” 该团队的研究成果今天发表在《当代生物学》1期上。</p>
<h2 id="深吸一口气"><a href="#深吸一口气" class="headerlink" title="深吸一口气"></a>深吸一口气</h2><p>呼吸与大脑息息相关。每一次吸气和呼气都相互协调，为大脑提供管理身体系统所需的氧气。索贝尔和他的团队不禁思考：如果每​​个人的大脑功能都不同，那么每个人的呼吸方式是否也应该独一无二？</p>
<p>为了验证这一点，研究人员开发了一种定制的可穿戴设备，用于记录人每个鼻孔的气流。该设备安装在颈后，鼻下装有管子，可以追踪人们日常生活中的呼吸情况，无论清醒还是睡眠。<br>为了描述一个人的呼吸模式，研究团队从气流数据中提取了24个参数，包括吸气和呼气的持续时间以及鼻孔间气流的不对称性。他们将参与者的清醒和睡眠时间分开，并利用这些数据训练机器学习算法。</p>
<p>当42名参与者在几周、几个月甚至两年后回到实验室，参加另一次24小时测量时，经过训练的算法可以根据他们的呼吸模式识别他们。参与者清醒时的数据比睡眠时的数据结果更准确，但当研究人员使用包含100个参数的完整数据集（而非仅包含24个参数的数据集）时，他们能够以96.8%的准确率识别出个体。</p>
<p>鉴于这一成功，索贝尔和他的同事开始思考是否可以从呼吸模式中了解更多信息。</p>
<h2 id="健康呼吸"><a href="#健康呼吸" class="headerlink" title="健康呼吸"></a>健康呼吸</h2><p>研究人员收集了参与者的BMI数据，以及评估抑郁和焦虑程度的问卷。分析发现，尽管大多数参与者的问卷得分较低，但这些信息与呼吸模式之间存在相关性。</p>
<p>例如，BMI 较高的人睡眠时的呼吸曲线与 BMI 较低的人不同。焦虑或抑郁问卷得分较高的人，其吸气和呼气的模式也有所不同。<br>“这是一项非常酷的研究，”斯德哥尔摩卡罗琳斯卡医学院的神经科学家 Artin Arshamian 说。</p>
<p>加州大学洛杉矶分校的精神病学家海伦·拉夫雷茨基（Helen Lavretsky）表示，研究呼吸的科学家一直在尝试将呼吸特征与健康联系起来——这类似于心电图（利用放置在人体手指、手臂或其他身体部位的电极来测量心脏活动）可以揭示异常节律。索贝尔表示，这项研究是呼吸模式领域的“一项进步”，该领域通常收集较短时间段内的呼吸数据。她还表示，这项研究为设计呼吸疗法打开了大门。</p>
<p>拉夫列茨基说：“我们能用的最有效的工具就是呼吸。” 例如，美国军队的一些部门会训练军人控制呼吸，以应对压力，并在高压时刻保持专注。</p>
<p>索贝尔和他的同事们目前正在尝试找出哪种呼吸模式与低水平的压力和焦虑相关，看看能否抵消这些感觉。索贝尔说，如果成功，他们将尝试“教人们以一种能够缓解这些症状的方式呼吸”。</p>
<h1 id="介绍-V-JEPA-2-世界模型和物理推理的新基准"><a href="#介绍-V-JEPA-2-世界模型和物理推理的新基准" class="headerlink" title="介绍 V-JEPA 2 世界模型和物理推理的新基准"></a>介绍 V-JEPA 2 世界模型和物理推理的新基准</h1><h2 id="文章来源-9"><a href="#文章来源-9" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://ai.meta.com/blog/v-jepa-2-world-model-benchmarks/" >https://ai.meta.com/blog/v-jepa-2-world-model-benchmarks/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>元视频联合嵌入预测架构 2 (V-JEPA 2) 是一个世界模型，在物理世界中的视觉理解和预测方面实现了最佳性能。我们的模型也可用于零样本机器人规划，以便在新环境中与陌生物体进行交互。</li>
<li>V-JEPA 2 代表着我们朝着实现高级机器智能 (AMI) 和构建可在物理世界中运行的有用的 AI 代理的目标迈出了下一步。</li>
<li>我们还发布了三个新的基准来评估现有模型从视频推断物理世界的能力。</li>
</ul>
<p>今天，我们很高兴地宣布 V-JEPA 2 正式发布。这是首个基于视频训练的世界模型，它能够实现最先进的理解和预测能力，以及在新环境中进行零样本规划和机器人控制。在我们努力实现高级机器智能 (AMI) 的目标的过程中，拥有能够像人类一样学习世界、规划如何执行不熟悉的任务并高效适应周围不断变化的世界的 AI 系统至关重要。</p>
<p>V-JEPA 2 是一个拥有 12 亿个参数的模型，它是使用我们在 2022 年首次分享的元联合嵌入预测架构(JEPA) 构建的。我们之前的工作表明，JEPA 在图像和3D 点云等模态下表现良好。V -JEPA是我们去年发布的第一个视频训练模型，在此基础上，V-JEPA 2 改进了动作预测和世界建模功能，使机器人能够与不熟悉的物体和环境交互以完成任务。我们还分享了三个新的基准，以帮助研究界评估他们现有的模型使用视频学习和推理世界的程度。通过分享这项工作，我们旨在让研究人员和开发人员能够访问最佳模型和基准，以帮助加速研究和进步，最终带来更优秀、更强大的 AI 系统，从而改善人们的生活。</p>
<h2 id="什么是世界模型？"><a href="#什么是世界模型？" class="headerlink" title="什么是世界模型？"></a>什么是世界模型？</h2><p>我们都知道，如果你把一个网球抛向空中，重力会把它拉回来。如果它悬空，突然在空中旋转飞向另一个方向，或者突然变成一个苹果，那真是令人惊讶。这种身体直觉并非成年人经过多年教育就能获得的——幼儿在能够说出完整句子之前，就通过观察周围的世界培养出了这种直觉。</p>
<p>预测世界将如何回应我们的行为（或他人的行为）的能力是人类一直以来都在运用的，尤其是在规划行动以及如何最好地应对新情况时。不妨想想这种生理直觉在我们日常生活中是如何体现的。当我们穿过陌生拥挤的区域时，我们会一边朝着目的地前进，一边努力避免撞到沿途的人或障碍物。打冰球时，我们会滑向冰球即将飞向的方向，而不是它当前的位置。用炉子做饭时，我们会考虑锅还要烧多久，或者是否要调低火候。我们内在的世界模型不仅为我们提供了这种直觉，还充当着一个内在模拟器，让我们能够预测假设行动的结果，最终根据我们认为最能实现目标的方式，选择最佳行动。</p>
<p>在采取行动之前，我们会使用世界模型来设想潜在的后果。在我们致力于构建能够先思考后行动的 AI 代理的过程中，让它们学习能够实现以下功能的世界模型至关重要：</p>
<ul>
<li>理解：世界模型应该能够理解对世界的观察，包括识别视频中的物体、动作和运动等。</li>
<li>预测：世界模型应该能够预测世界将如何发展，以及如果代理采取行动，世界将如何变化。</li>
<li>规划：基于预测能力，世界模型应该有助于规划实现给定目标的行动序列。</li>
</ul>
<h2 id="V-JEPA-2-简介"><a href="#V-JEPA-2-简介" class="headerlink" title="V-JEPA 2 简介"></a>V-JEPA 2 简介</h2><p>我们的长期愿景是，世界模型将使 AI 代理能够在物理世界中进行规划和推理。为了实现这一愿景，我们即将发布 V-JEPA 2，这是一个主要基于视频进行训练的世界模型——视频是丰富且易于获取的世界信息来源。通过将 V-JEPA 2 代码和模型检查点开放给商业和研究应用，我们希望围绕这项研究建立一个广泛的社区，推动我们朝着最终目标迈进，即开发能够改变 AI 与物理世界交互方式的世界模型。</p>
<p>V-JEPA 2 采用联合嵌入预测架构 (JEPA) 构建，包含两个主要组件：</p>
<ul>
<li>编码器，接收原始视频并输出嵌入，以捕获有关观察世界状态的有用语义信息。</li>
<li>预测器，它接受视频嵌入和关于要预测的内容的附加上下文，并输出预测的嵌入。</li>
</ul>
<p>我们使用基于视频的自监督学习来训练 V-JEPA 2，这使得我们无需额外的人工注释即可在视频上进行训练。V-JEPA 2 训练包含两个阶段：无动作预训练，以及后续的动作条件训练。</p>
<p>在第一阶段——预训练阶段，我们使用了来自不同来源的超过 100 万小时的视频和 100 万张图像。这些丰富的视觉数据有助于模型深入了解世界的运作方式，包括人与物体的互动方式、物体在物理世界中的移动方式以及物体与其他物体的互动方式。我们发现，在预训练阶段之后，模型已经展现出与理解和预测相关的关键能力。例如，通过在冻结编码器特征的基础上训练轻量级的注意力读出模型，V-JEPA 2 在 Something-Something v2 动作识别任务中取得了卓越的表现，该任务依赖于运动理解。同样，通过在冻结编码器和预测器特征的基础上训练注意力读出模型，V-JEPA 2 在 Epic-Kitchens-100 动作预测任务中创造了新的最高纪录，该任务可以根据以自我为中心的视频预测未来 1 秒将执行的动作（由名词和动词组成）。最后，将 V-JEPA 2 与语言模型相结合，可以在视频问答基准（例如感知测试和 TempCompass）上实现最先进的性能。</p>
<p>在无动作预训练阶段之后，模型可以预测世界未来如何演变——然而，这些预测并未直接考虑代理将采取的具体动作。在训练的第二阶段，我们专注于利用机器人数据（包括视觉观察（视频）和机器人正在执行的控制动作）来提升模型的规划能力。我们通过向预测器提供动作信息，将这些数据整合到 JEPA 训练流程中。在使用这些额外数据进行训练后，预测器学会在进行预测时考虑具体动作，然后即可用于控制。第二阶段我们不需要大量的机器人数据——在我们的技术报告中，我们展示了仅使用 62 小时的机器人数据进行训练就能构建出一个可用于规划和控制的模型。</p>
<p>我们演示了如何在新环境中使用 V-JEPA 2 进行零样本机器人规划，并涉及训练期间未见过的物体。与其他机器人基础模型（通常需要一些来自部署模型的特定机器人实例和环境的训练数据）不同，我们在开源DROID 数据集上训练该模型，然后将其直接部署到我们实验室的机器人上。我们展示了 V-JEPA 2 预测器可用于执行一些基础任务，例如伸手够到、拾取物体并将其放置在新位置。</p>
<p>对于短期任务，例如拾取或放置物体，我们以图像的形式指定目标。我们使用 V-JEPA 2 编码器获取当前状态和目标状态的嵌入。机器人从观察到的当前状态出发，利用预测器进行规划，设想采取一系列候选动作的后果，并根据候选动作与期望目标的接近程度对其进行评级。在每个时间步，机器人都会重新规划并通过模型预测控制执行排名最高的下一个动作，以实现该目标。对于长期任务，例如拾取物体并将其放置在正确位置，我们指定一系列视觉子目标，机器人会尝试按顺序实现这些目标，类似于人类观察到的视觉模仿学习。凭借这些视觉子目标，V-JEPA 2 在新环境和未知环境中拾取和放置新物体的成功率达到 65% 至 80%。</p>
<h2 id="物理理解的基准测试"><a href="#物理理解的基准测试" class="headerlink" title="物理理解的基准测试"></a>物理理解的基准测试</h2><p>随着我们在世界模型领域不断取得进展，我们很高兴与开源社区分享我们的工作成果并支持其发展。我们将发布三个新的基准测试，以评估现有模型从视频理解和推理物理世界的能力。虽然人类在这三个基准测试中都表现良好（准确率达到 85% 到 95%），但人类的表现与包括 V-JEPA 2 在内的顶级模型相比仍存在显著差距，这为模型的改进指明了重要的方向。</p>
<p>IntPhys 2专门用于衡量模型区分物理上合理和不合理场景的能力，它在早期的IntPhys 基准的基础上进行构建和扩展。我们设计 IntPhys 2 的方式类似于发展认知科学家通过违反预期范式来评估年轻人何时获得直觉物理学的方式。我们使用一个游戏引擎来实现这一点，该引擎会生成成对的视频，其中两个视频在某个点之前相同，然后两个视频中的一个视频中发生了违反物理的事件。然后，模型必须识别哪个视频发生了违反物理的事件。虽然人类在各种场景和条件下都能在这项任务上达到近乎完美的准确率，但我们发现当前的视频模型处于或接近偶然性。</p>
<p><strong>最小视频对 (MVPBench)</strong> 通过多项选择题来衡量视频语言模型的物理理解能力。与文献中的其他视频问答基准测试不同，MVPBench 旨在缓解视频语言模型中常见的捷径解决方案，例如依赖肤浅的视觉或文本线索和偏见。MVPBench 中的每个示例都包含一个最小变化对：视觉上相似的视频，以及相同的问题，但答案相反。为了获得一个示例的评分，模型也必须正确完成其最小变化对。</p>
<p><strong>CausalVQA</strong>衡量视频语言模型回答与物理因果关系相关问题的能力。该基准测试旨在关注对物理世界视频中因果关系的理解，包括反事实问题（如果……会发生什么）、预期问题（接下来可能会发生什么）以及规划问题（为了实现目标，下一步应该采取什么行动）。我们发现，虽然大型多模态模型越来越能够回答视频中“发生了什么”的问题，但它们仍然难以回答“可能发生什么”和“接下来可能会发生什么”的问题，这表明，在预测物理世界在给定动作和事件空间的情况下可能如何演变方面，人类的表现与人类存在巨大差距。</p>
<h2 id="迈向高级机器智能的下一步"><a href="#迈向高级机器智能的下一步" class="headerlink" title="迈向高级机器智能的下一步"></a>迈向高级机器智能的下一步</h2><p>随着我们继续推进世界模型的研究，我们计划在多个领域进一步探索。目前，V-JEPA 2 可以在单一时间尺度上学习并进行预测。然而，许多任务需要跨多个时间尺度进行规划。想象一下，将一个高级任务分解成更小的步骤，例如装载洗碗机或烘烤蛋糕。我们希望专注于训练能够跨多个时间和空间尺度进行学习、推理和规划的分层 JEPA 模型。另一个重要方向是多模态 JEPA 模型，这些模型可以使用多种感官进行预测，包括视觉、听觉和触觉。一如既往，我们期待在未来分享更多成果，并继续与研究界进行重要的讨论。</p>
<h1 id="《思考的错觉的错觉》"><a href="#《思考的错觉的错觉》" class="headerlink" title="《思考的错觉的错觉》"></a>《思考的错觉的错觉》</h1><p>几天前，苹果一篇《思考的错觉》论文吸睛无数又争议不断，其中研究了当今「推理模型」究竟真正能否「推理」的问题，而这里的结论是否定的。</p>
<p>论文中写到：「我们的研究表明，最先进的 LRM（例如 o3-mini、DeepSeek-R1、Claude-3.7-Sonnet-Thinking）仍然未能发展出可泛化的解决问题能力 —— 在不同环境中，当达到一定复杂度时，准确度最终会崩溃至零。」</p>
<p>不过，这篇论文的研究方法也受到了不少质疑，而现在，我们迎来了对这项研究更强有力的质疑：《思考的错觉的错觉》。是的，你没有看错，这就是这篇来自 Anthropic 和 Open Philanthropy 的评论性论文的标题！其中指出了那篇苹果论文的 3 个关键缺陷：</p>
<ol>
<li>汉诺塔实验在报告的失败点系统性地超出了模型输出 token 的限制，而模型在其输出中明确承认了这些限制；</li>
<li>苹果论文作者的自动评估框架未能区分推理失败和实际约束，导致对模型能力分类错误；</li>
<li>最令人担忧的是，由于船容量不足，当 N ≥ 6 时，他们的「过河（River Crossing）」基准测试包含在数学上不可能出现的实例，但模型却因未能解答这些本就无法解决的问题而被评为失败</li>
</ol>
<h2 id="1-研究背景与核心争议"><a href="#1-研究背景与核心争议" class="headerlink" title="1.研究背景与核心争议"></a>1.研究背景与核心争议</h2><p>Shojaee等人的研究声称，当面对复杂度超过一定阈值的规划问题（如河渡问题、汉诺塔问题）时，大型推理模型的表现会显著下降，甚至完全失效。这被解释为模型在复杂推理上存在根本性的局限。</p>
<p>本文作者对此提出了质疑，认为这些“失败”并非源于模型推理能力的不足，而是由以下三方面原因导致：</p>
<ul>
<li>输出长度限制 ：模型在处理某些问题时因生成内容超出token上限而被迫截断；</li>
<li>评估框架误判 ：自动化评估系统未能区分模型是否理解问题但选择不完整输出；</li>
<li>测试问题不可解 ：部分测试实例本身无解，模型未能得分是因为正确识别了这一点。</li>
</ul>
<h2 id="2-对Shojaee等人的主要反驳点"><a href="#2-对Shojaee等人的主要反驳点" class="headerlink" title="2.对Shojaee等人的主要反驳点"></a>2.对Shojaee等人的主要反驳点</h2><p>2.1 模型能够识别并主动应对输出限制<br>作者引用了一个Twitter上的复现案例，展示了模型在解决汉诺塔问题时明确表示“为了不过于冗长，我在这里停止”。这表明模型不仅理解解决方案的模式，还具备自我调节输出长度的能力。将这种行为归类为“推理崩溃”是对其能力的误解。</p>
<p>此外，作者通过数学建模分析了token数量与问题规模之间的关系，指出在当前上下文窗口限制下，模型无法完整输出超大规模问题的解答是预料之中的技术限制，而非推理失败。</p>
<h3 id="2-2-自动化评估系统的误分类问题"><a href="#2-2-自动化评估系统的误分类问题" class="headerlink" title="2.2 自动化评估系统的误分类问题"></a>2.2 自动化评估系统的误分类问题</h3><p>作者指出，若以字符级或token级精度来评判模型表现，即使每个token的准确率为99.9%，在生成数万个token时整体成功概率也会极低。这种统计学上的“必然失败”不应被错误解读为模型不具备解决问题的能力。</p>
<p>更进一步地，作者强调评估系统应当具备区分“不能解”与“不愿穷举”的能力，否则容易得出误导性结论。</p>
<h3 id="2-3-测试集包含不可解问题"><a href="#2-3-测试集包含不可解问题" class="headerlink" title="2.3 测试集包含不可解问题"></a>2.3 测试集包含不可解问题</h3><p>在River Crossing问题中，作者指出当N ≥ 6且船容量b &#x3D; 3时，问题本身在数学上已被证明无解。然而，Shojaee等人仍将模型未能给出答案视为“失败”，等同于惩罚一个SAT求解器在面对不可满足公式时返回“unsatisfiable”。</p>
<p>这是一个严重的评估失误，反映出程序化自动评分机制在缺乏人类判断或逻辑验证的情况下可能产生反效果。</p>
<h2 id="3-实验改进与新发现"><a href="#3-实验改进与新发现" class="headerlink" title="3. 实验改进与新发现"></a>3. 实验改进与新发现</h2><p>作者通过改变问题的输入&#x2F;输出形式，要求模型输出一个Lua函数来表示解决方案，而非逐条列出所有移动步骤。结果显示，在Tower of Hanoi N&#x3D;15的问题上，多个主流模型（包括Claude Opus、Gemini 2.5等）均能高效生成正确的递归算法实现，仅需不到5,000个token。</p>
<p>这说明：</p>
<p>模型确实具备解决高复杂度问题的推理能力；<br>问题的关键在于如何引导模型以合适的表达方式呈现其知识；<br>token预算限制应被视为工程瓶颈，而非认知瓶颈。</p>
<h2 id="4-对问题复杂度指标的再思考"><a href="#4-对问题复杂度指标的再思考" class="headerlink" title="4. 对问题复杂度指标的再思考"></a>4. 对问题复杂度指标的再思考</h2><p>作者指出，Shojaee等人使用“最小步数”作为衡量问题复杂度的标准并不恰当。他们列举了不同规划问题的特性：</p>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>解决方案长度</th>
<th>分支因子</th>
<th align="left">是否需要搜索</th>
</tr>
</thead>
<tbody><tr>
<td>Tower of Hanoi</td>
<td>2^N − 1</td>
<td>1</td>
<td align="left">否</td>
</tr>
<tr>
<td>River Crossing</td>
<td>~4N</td>
<td>&gt;4</td>
<td align="left">是（NP-hard）</td>
</tr>
<tr>
<td>Blocks World</td>
<td>~2N</td>
<td>O(N²)</td>
<td align="left">是（PSPACE）</td>
</tr>
</tbody></table>
<p>这说明，尽管汉诺塔问题需要指数级的操作次数，但每一步的选择是确定的；而河渡问题虽然操作次数少，却涉及复杂的约束满足和搜索过程。因此，仅凭操作次数难以反映实际难度。</p>
<h2 id="5-结论与未来建议"><a href="#5-结论与未来建议" class="headerlink" title="5. 结论与未来建议"></a>5. 结论与未来建议</h2><p>本文有力地反驳了Shojaee等人关于模型存在“根本推理限制”的主张，指出其实验结果更多反映了技术限制和评估设计的缺陷。作者提出未来研究应注重以下几个方向：</p>
<p>区分推理能力和输出限制 ：评估系统应能识别模型是否具备解决问题的知识，即便未完整执行。<br>验证测试问题的可解性 ：避免将模型在不可解问题上的正确响应误判为失败。<br>采用合理的复杂度指标 ：应考虑问题内在的计算难度，而非仅看操作数量。<br>多样化解决方案表示方式 ：鼓励模型以抽象、函数式等方式表达解决方案，减少对穷举路径的依赖。</p>
<h2 id="6-总体评价"><a href="#6-总体评价" class="headerlink" title="6. 总体评价"></a>6. 总体评价</h2><p>这是一篇具有重要理论价值和实践意义的评论文章。它提醒我们在评估AI推理能力时，必须更加谨慎地设计实验和评估标准。模型的“失败”未必意味着其没有能力，而可能是我们尚未找到合适的方式来激发和观察其潜能。</p>
<p>正如作者所言：“问题不是模型能否推理，而是我们的评估能否区分推理与打字。”</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>科技前沿</tag>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>一周科技资讯第二期</title>
    <url>/zhihaojiang.github.io/2025/06/22/20250622%E4%B8%80%E5%91%A8%E7%A7%91%E6%8A%80%E8%B5%84%E8%AE%AF%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="SpaceX-的下一艘星际飞船刚刚在德克萨斯州南部的试验台上爆炸"><a href="#SpaceX-的下一艘星际飞船刚刚在德克萨斯州南部的试验台上爆炸" class="headerlink" title="SpaceX 的下一艘星际飞船刚刚在德克萨斯州南部的试验台上爆炸"></a>SpaceX 的下一艘星际飞船刚刚在德克萨斯州南部的试验台上爆炸</h1><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://arstechnica.com/space/2025/06/starships-rough-year-gets-worse-after-a-late-night-explosion-in-south-texas/" >https://arstechnica.com/space/2025/06/starships-rough-year-gets-worse-after-a-late-night-explosion-in-south-texas/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>周三晚间，SpaceX 的下一代星际飞船火箭在南德克萨斯州的地面测试中发生爆炸，这对近几个月来一直在努力克服三次连续失败的计划又一次造成了打击。</p>
<p>深夜，位于德克萨斯州星际基地的SpaceX火箭研发中心发生爆炸，摧毁了原定于下一次星际飞船试飞中发射的子弹形上面级火箭。强大的爆炸引发了SpaceX位于梅西试验场周围的火灾，该试验场距离该公司的星际飞船工厂和发射台仅几英里。</p>
<p>NASASpaceflight.com 和 LabPadre 媒体机构在 Starbase 周围部署的摄像机拍摄的现场直播视频显示，这枚 15 层楼高的火箭在当地时间晚上 11 点（美国东部时间凌晨 12 点；世界协调时凌晨 4 点）后不久爆炸起火。据报告，远至 30 英里外的当地居民都看到并感受到了爆炸。</p>
<p>SpaceX 证实，该公司库存中编号为 36 的星际飞船在测试台上“出现了重大异常”，当时该飞船正准备点燃其六台猛禽发动机进行静态点火测试。这些压紧式点火测试通常是星际飞船发射活动的最后里程碑之一，之后 SpaceX 将火箭移至发射台。</p>
<p>爆炸发生时，SpaceX正将超冷甲烷和液氧推进剂装入星际飞船，准备进行静态点火测试。该公司表示，测试场地周围的所有人员均已疏散，事故发生后，所有人员均安全无虞。布朗斯维尔消防局的消防员已被派往现场。</p>
<p>SpaceX 在 X 上发布消息称：“我们的 Starbase 团队正与当地官员合作，积极努力确保试验场及其周边地区的安全。周边社区的居民不会受到任何威胁，我们请求个人在安全作业继续进行期间不要试图接近该区域。”</p>
<p>SpaceX 创始人兼首席执行官埃隆·马斯克在 X 的另一篇文章中写道，初步数据显示，星际飞船有效载荷舱内的高压氮气罐发生故障。许多火箭都配备这样的氮气罐，即复合材料包裹的压力容器，内含用于吹扫和加压火箭内部不同舱室的高压气体。这些氮气罐（简称 COPV）可能非常不稳定。SpaceX 工程师将猎鹰 9 号火箭在 2015 年和 2016 年发生的仅有的两次灾难性故障归咎于与 COPV 相关的硬件。</p>
<p>马斯克写道，氮气COPV似乎在低于其耐压值的情况下失效，而这种情况本不该损坏储罐。“如果进一步调查证实确实发生了这种情况，那么这将是该设计首次出现这种情况，”马斯克补充道。</p>
<h2 id="收拾残局"><a href="#收拾残局" class="headerlink" title="收拾残局"></a>收拾残局</h2><p>周三早些时候，就在星际基地发生深夜爆炸的几个小时前，美国联邦航空管理局（FAA）发布的一份公告显示，SpaceX 已将 6 月 29 日定为下一次星际飞船试飞的暂定发射日期。目前还无法确定，SpaceX 何时才能准备好另一艘星际飞船进行试飞，目前还不得而知。</p>
<p>梅西试验场因曾经占据该地产的射击场而得名，位于格兰德河的一个河湾处，距离墨西哥边境仅几百英尺。该试验场目前是SpaceX在宣布火箭准备发射之前，唯一可以对星际飞船进行验证测试和静态点火测试的地方。</p>
<p>梅西试验场地面设备的损坏程度目前尚不清楚，因此现在判断该试验场将停用多久还为时过早。不过，目前爆炸导致SpaceX失去了支持星际飞船飞行前测试的设施。</p>
<p>梅西百货的爆炸事件，让人想起SpaceX在将星际飞船推进到如今这个阶段的坎坷历程。2020年和2021年，SpaceX在地面和飞行测试中因故障损失了数艘星际飞船原型。36号飞船起火的画面，让人想起了之前的爆炸，以及2016年猎鹰9号火箭在发射台上因类似周三晚间事件的情况而燃烧殆尽的惨剧。</p>
<p>自2023年4月以来，SpaceX已发射了9枚全尺寸的星际飞船（Starship）火箭。爆炸发生前，该公司原本计划于本月晚些时候进行第10次试飞。今年迄今为止，星际飞船的业绩惨淡，最近三次试飞均提前结束。然而，在2024年取得辉煌胜利之后，SpaceX在星际飞船的每次亚轨道试飞中都取得了显著进展，并最终在发射台塔架上首次用巨型机械臂成功接住了火箭的巨型超重型助推器。</p>
<p>超重型火箭助推级和星际飞船上面级叠放在一起，高度超过400英尺，是迄今为止建造的最大火箭。SpaceX已经成功发射过一枚可重复使用的超重型火箭助推器，该公司还设计了可回收和重复使用的星际飞船。</p>
<p>在去年取得成功之后，SpaceX 似乎有望在 2025 年实现一次完整的轨道飞行、尝试捕获并回收星际飞船本身，以及进行一次重要的太空加油演示。加油演示已正式推迟到 2026 年，SpaceX 能否在未来几个月取得足够的进展，以便在年底前尝试回收飞船，这一点仍值得怀疑。</p>
<h2 id="雄心与现实的碰撞"><a href="#雄心与现实的碰撞" class="headerlink" title="雄心与现实的碰撞"></a>雄心与现实的碰撞</h2><p>SpaceX 于今年 1 月试飞，首次展示了升级版的星际飞船设计，称为“版本 2”或“Block 2”。但自那以后，它却接连遭遇挫折。</p>
<p>新的星际飞船设计比SpaceX在2023年和2024年试飞的星际飞船略高。它配备了改进的隔热罩，以更好地抵御重返大气层时的极端高温。SpaceX还安装了新的燃料输送管线系统，将甲烷燃料输送到飞船的猛禽发动机，并安装了改进的推进航空电子模块，用于控制飞船的阀门和读取传感器。</p>
<p>尽管（或许正是因为）星际飞船二号（Starship Version 2）进行了所有这些改进，SpaceX 仍未能复制过去两年星际飞船的成功。今年 1 月和 3 月进行试飞的飞船在升空几分钟后就失控旋转，碎片散落在海面上，至少有一次还砸到了特克斯和凯科斯群岛的一辆汽车上。</p>
<p>SpaceX 工程师得出结论，1 月份的故障很可能是由剧烈震动引起的，这种震动引发了火箭发动机舱的燃料泄漏和起火，最终导致火箭发动机提前关闭。工程师们表示，这些震动很可能与火箭的固有频率产生共振，导致震动强度超出了 SpaceX 的预期。</p>
<p>三月份的飞行也出现了类似的故障，但 SpaceX 的调查人员确定，最可能的根本原因是飞船一台发动机出现硬件故障，与两个月前的故障模式不同。</p>
<p>在上个月SpaceX最新一次星际飞船试飞中，火箭按计划完成了任务的上升阶段，似乎克服了前两次发射中遇到的难题。然而，猛禽发动机关闭后不久，燃料泄漏导致飞船开始在太空中翻滚，导致其无法完成引导再入，从而无法测试新型隔热材料的性能。</p>
<p>SpaceX 正在研发第三代星际飞船（Starship）的设计，名为“星际飞船3号”（Version 3），该公司表示，该飞船可能在今年年底前完成试飞。升级后的“星际飞船3号”设计将能够将更重的货物（重达200公吨）送入轨道，这得益于更大的推进剂箱和更强大的猛禽发动机。“星际飞船3号”还将具备在近地轨道加油的能力。</p>
<p>版本 3 预计将永久性地解决目前拖慢 SpaceX 星际飞船研发进度的问题。SpaceX 的工程师们还有无数问题需要解决，从发动机可靠性和飞船的共振频率，到加强飞船的隔热罩，再到修复其不稳定的有效载荷舱门。</p>
<p>一旦官员们解决了这些问题，SpaceX就可以将星际飞船从近地轨道送回地面。之后，SpaceX还有更多酷炫的计划，比如轨道加油以及与NASA的阿尔忒弥斯计划合作执行月球任务。NASA与SpaceX签订了价值超过40亿美元的合同，用于开发一艘载人星际飞船，能够将宇航员送上月球并安全送回太空。</p>
<p>特朗普政府为NASA提出的预算方案将取消阿尔忒弥斯计划中极其昂贵的SLS火箭和猎户座载人舱，这些火箭将在完成两次飞行后继续执行，而商用重型运载火箭将接管宇航员从地球到月球的发射任务。SpaceX的星际飞船已经与NASA签订了载人着陆器合同，根据特朗普提出的预算方案，它最终可能会赢得更多政府合同，以取代SLS和猎户座火箭。其他火箭，例如蓝色起源的“新格伦”火箭，也有望在载人太空探索中发挥更大作用。</p>
<p>NASA官方计划将首批阿尔忒弥斯宇航员登陆月球的时间安排在2027年左右，届时将使用SLS火箭和猎户座火箭将宇航员运送到月球附近，与SpaceX的“星际飞船”月球着陆器汇合。在这次被称为“阿尔忒弥斯三号”的任务之后，NASA将转向使用埃隆·马斯克的SpaceX和杰夫·贝佐斯的蓝色起源的商用火箭来取代太空发射系统（SLS）。</p>
<p>与此同时，SpaceX的创始人兼首席执行官马斯克也把目光投向了火星。上个月，马斯克告诉员工，他计划在2026年底向这颗红色星球发射首批星际飞船，届时地球和火星在太阳系中的位置将使直接旅行成为可能。他乐观地​​表示，希望从2028年开始用星际飞船将人类送上火星。</p>
<p>所有这些任务都取决于 SpaceX 掌握星际飞船的常规发射操作、飞船和助推器的快速重复使用、在轨低温加油，以及适应星际旅行的生命支持、通信和深空导航等系统。</p>
<p>SpaceX 的星际飞船计划任务繁重，以至于在未来几年内实现火星登陆似乎不太可能。NASA 2027 年的阿尔忒弥斯三号登月任务计划也很紧凑，这不仅仅是因为星际飞船的延误。宇航员在月球上穿着的新型宇航服的研发也可能使阿尔忒弥斯三号的计划面临风险。NASA 的 SLS 火箭和猎户座飞船在其历史上都曾遭遇过重大延误，因此它们能否在 2027 年准备就绪尚不确定。</p>
<p>虽然现在还无法知道周三晚上爆炸的具体影响，但我们可以有信心地说，星际飞船今天完成这些大胆计划的可能性比昨天要低。</p>
<h1 id="可靠的量子计算就在这里”：微软科学家称，新的纠错方法可以将未来系统中的错误减少-1000-倍"><a href="#可靠的量子计算就在这里”：微软科学家称，新的纠错方法可以将未来系统中的错误减少-1000-倍" class="headerlink" title="可靠的量子计算就在这里”：微软科学家称，新的纠错方法可以将未来系统中的错误减少 1000 倍"></a>可靠的量子计算就在这里”：微软科学家称，新的纠错方法可以将未来系统中的错误减少 1000 倍</h1><h2 id="文章来源-1"><a href="#文章来源-1" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://www.livescience.com/technology/computing/reliable-quantum-computing-is-here-new-approach-error-correction-reduce-errors-up-to-1000-times-microsoft-scientists-say" >https://www.livescience.com/technology/computing/reliable-quantum-computing-is-here-new-approach-error-correction-reduce-errors-up-to-1000-times-microsoft-scientists-say<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>微软科学家开发出一种 4D 几何编码方法，可将量子计算机中的错误减少 1,000 倍。</p>
<p>计算机科学家表示，借助新的“4D 代码”，他们已经破解了量子计算机纠错背后的科学原理。</p>
<p>这些新代码由微软开发，于 6 月 19 日发布的一篇博客文章中披露，旨在解决容错问题——这可以说是量子计算的最大瓶颈。</p>
<p>所有计算机都可能出错。在传统计算中，纠错是通过对发送的每一位信息进行多份复制来实现的。即使一个或多个位丢失或损坏，剩余的位仍然包含原始信息。</p>
<p>然而，量子比特无法复制。如果不经历所谓的“坍缩”，它们就无法被测量。这使得在错误发生时检测和缓解错误（错误发生的频率远高于传统比特）变得更加困难。</p>
<p>典型的量子纠错装置涉及在系统中添加额外的“物理”量子比特。这些量子比特与通常承载量子信息的“逻辑”量子比特纠缠在一起。科学家无需测量逻辑量子比特，从而避免发生这种坍缩，而是可以通过测量纠缠的物理量子比特来检查错误。这使得计算过程能够继续进行。</p>
<p>科学家通常在量子纠错过程中使用四维码，通过在四维晶格上重建量子处理表面的拓扑结构。这创造了一种自校正形式的量子记忆。</p>
<p>问题在于，目前大多数纠错技术要么难以扩展，要么资源密集，或者两者兼而有之。为量子系统提供容错能力所需的物理量子比特越多，需要的纠错次数越多，计算所需的能量就越大。</p>
<p>微软量子高级量子开发技术研究员 Krysta Svore 在博客文章中表示：“微软的新型四维几何代码每个逻辑量子位只需要很少的物理量子位，可以一次性检查错误，并将错误率降低 1,000 倍。 ”</p>
<h2 id="量子纠错的转折"><a href="#量子纠错的转折" class="headerlink" title="量子纠错的转折"></a>量子纠错的转折</h2><p>该研究结果于 6 月 18 日上传至arXiv预印本数据库，主要研究如何对某些量子计算系统中用于纠错的环面形 4D 几何代码进行字面扭曲。</p>
<p>科学家们开发了几何代码，可以叠加在系统中，利用四维拓扑结构检测错误。该四维代码通过纠缠将样本空间（运行校正代码的地方）与操作空间（量子比特包含信息的地方）连接起来。</p>
<p>它使用数学表达式在四维空间中工作，本质上允许纠缠点在“圆环”的表面上建立连接，可以想象成甜甜圈形状。</p>
<p>虽然 4D 代码在过去曾被用来创建自校正量子存储器，但它们在这里的使用被认为是新颖的，因为研究人员计算了几何中的“扭曲”，使得相同数量的代码能够使用更少的物理量子位纠缠覆盖相同数量的系统空间。</p>
<p>通过“扭曲”几何结构，4D代码叠加层创建了一个更大的表征空间，可以反映实际使用量子比特的更大一部分量子态。这样做可以让研究人员在不干扰系统内实际发生的量子过程的情况下检测代码中的错误。</p>
<p>研究人员在现有的量子计算机上运行了新的“扭曲”代码，并通过实验证实了他们的理论，并在另一篇预印本论文中进行了验证。该论文于6月13日发表在arXiv预印本服务器上。两篇论文均未经过同行评审。</p>
<p>科学家在研究中表示：“通用容错量子计算机可以使用 4D 几何代码来实现，这种代码旨在利用适量的物理量子比特有效地实现越来越多的逻辑量子比特，同时实现低深度逻辑循环和通用容错。”</p>
<p>此外，研究人员据称还展示了一项突破性的技术，用于在量子比特原子丢失时“替换”它们。在某些量子计算系统中，量子比特是通过用激光镊子捕获中性原子并将其捕获到位而产生的。在计算过程中，这些原子可能会丢失或掉落。</p>
<p>研究人员表示，他们可以使用原子束取代在循环中期丢失的原子，从而迫使新原子进入阵列，而不会中断计算——科学家在研究中表示，这是第一次。</p>
<p>根据这些发现，新的4D码系列可能代表着短短几周内量子纠错领域的第二次突破。6月10日，IBM也发表了类似的声明，宣布其已开发出量子纠错技术，这将推动到2029年开发出可证明实用的量子计算机。</p>
<p>IBM 的新方法采用自上而下的开发方法，充分利用其定制的硬件，而微软的方法则是自下而上地构建来解决容错问题，所采用的方法可能具有超出其测试的硬件和用例的其他应用程序。</p>
<h1 id="创纪录的-DDoS-攻击使网站遭受了曾经难以想象的-7-3Tbps-垃圾流量的重创、"><a href="#创纪录的-DDoS-攻击使网站遭受了曾经难以想象的-7-3Tbps-垃圾流量的重创、" class="headerlink" title="创纪录的 DDoS 攻击使网站遭受了曾经难以想象的 7.3Tbps 垃圾流量的重创、"></a>创纪录的 DDoS 攻击使网站遭受了曾经难以想象的 7.3Tbps 垃圾流量的重创、</h1><h2 id="文章来源-2"><a href="#文章来源-2" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://arstechnica.com/security/2025/06/record-ddos-pummels-site-with-once-unimaginable-7-3tbps-of-junk-traffic/" >https://arstechnica.com/security/2025/06/record-ddos-pummels-site-with-once-unimaginable-7-3tbps-of-junk-traffic/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<blockquote>
<p>攻击者在短短 45 秒内就下载了相当于 9,300 部完整高清电影的数据。</p>
</blockquote>
<p>大规模攻击旨在通过向互联网服务发送超过其处理能力的流量来使其瘫痪，其规模越来越大，迄今为止最大的一次攻击流量达到每秒 7.3 太比特，这是互联网安全和性能提供商 Cloudflare 于周五报告的。</p>
<p>此次 7.3Tbps 的攻击总计 37.4TB 的垃圾流量，仅用 45 秒就击中目标。这几乎是一个难以想象的数据量，相当于在不到一分钟的时间内传输了超过 9,300 部完整高清电影或 7,500 小时的高清流媒体内容。</p>
<h2 id="不分皂白的目标轰炸"><a href="#不分皂白的目标轰炸" class="headerlink" title="不分皂白的目标轰炸"></a>不分皂白的目标轰炸</h2><p>Cloudflare表示，攻击者“地毯式轰炸”了目标 IP 地址平均近 22,000 个目标端口，而该 IP 地址仅被确认为 Cloudflare 客户。总计有 34,500 个端口成为攻击目标，这表明此次攻击的彻底性和精心策划的性质。</p>
<p>此次攻击的绝大部分内容是以用户数据报协议 (UDP) 数据包的形式进行的。合法的 UDP 传输通常用于对时间特别敏感的通信，例如视频播放、游戏应用程序和 DNS 查询。UDP 通过在数据传输前不正式建立连接来加快通信速度。与更常见的传输控制协议 (TCP) 不同，UDP 不会等待两台计算机通过握手建立连接，也不会检查对方是否正确接收了数据。相反，它会立即将数据从一台计算机发送到另一台计算机。</p>
<p>UDP 洪水攻击会向目标 IP 上的随机或特定端口发送大量数据包。此类洪水攻击可能会导致目标的互联网链路饱和，或使内部资源因数据包数量超过其处理能力而不堪重负。</p>
<p>由于 UDP 无需握手，攻击者可以利用它向目标服务器发送大量流量，而无需事先获得服务器的传输许可。UDP 泛洪攻击通常会向目标系统的多个端口发送大量数据报。目标系统则必须发送相同数量的数据包，以表明端口无法访问。最终，目标系统不堪重负，导致合法流量被拒绝。</p>
<p>一小部分攻击（占比仅为 0.004%）是通过反射攻击发起的。反射攻击会将恶意流量导向一个或多个第三方中介，例如用于同步服务器时钟的网络时间协议 (NTP) 服务。攻击者会伪造恶意数据包的发送方 IP，使其看起来像是由最终目标发送的。当第三方发送响应时，响应会被发送到目标，而不是原始流量来源的目的地。</p>
<p>反射攻击为攻击者提供了多重好处。首先，此类攻击使得 DDoS 攻击从各种各样的目的地发起。这使得目标更难抵御攻击。此外，通过选择已知会生成比原始请求大数千倍的响应的中间服务器，攻击者可以将可用的攻击火力放大千倍甚至更多。Cloudflare 和其他公司经常建议服务器管理员锁定服务器，以防止它们响应欺骗数据包，但不可避免的是，许多人并没有听从这些建议。</p>
<p>Cloudflare 表示，创纪录的 DDoS 攻击利用了各种反射或放大向量，包括前面提到的网络时间协议、每日报价协议（它在 UDP 端口 17 上监听并以简短的报价或消息进行响应）、Echo 协议（它使用接收到的相同数据进行响应）以及用于识别通过远程过程调用连接的应用程序可用资源的 Portmapper 服务。</p>
<p>Cloudflare 表示，此次攻击还通过一个或多个基于 Mirai 的僵尸网络发起。此类僵尸网络通常由家庭和小型办公室路由器、网络摄像头以及其他已遭入侵的物联网设备组成。</p>
<p>过去三十年来，DDoS 规模持续稳步攀升。今年3 月，诺基亚报告称，一个名为 Eleven11bot 的僵尸网络发起了一次峰值流量达 6.5Tbps 的 DDoS 攻击。5 月，KrebsonSecurity表示其遭受了一次峰值流量达 6.3Tbps 的 DDoS 攻击。</p>
<h1 id="苹果公司高管称其计划利用人工智能设计芯片"><a href="#苹果公司高管称其计划利用人工智能设计芯片" class="headerlink" title="苹果公司高管称其计划利用人工智能设计芯片"></a>苹果公司高管称其计划利用人工智能设计芯片</h1><h2 id="文章来源-3"><a href="#文章来源-3" class="headerlink" title="文章来源"></a>文章来源</h2><p><a class="link"   href="https://www.ctvnews.ca/business/article/apple-eyes-using-ai-to-design-its-chips-technology-executive-says/" >https://www.ctvnews.ca/business/article/apple-eyes-using-ai-to-design-its-chips-technology-executive-says/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>旧金山——苹果公司高级硬件技术主管上个月在私下表示，苹果有意利用生成人工智能来帮助加快其设备核心定制芯片的设计。</p>
<p>苹果硬件技术高级副总裁约翰尼·斯鲁吉 (Johny Srouji) 在比利时发表演讲时发表了上述言论，当时他正在接受 Imec 颁发的奖项。Imec 是一家独立的半导体研发集团，与全球大多数最大的芯片制造商都有密切的合作。</p>
<p>路透社查阅了此次演讲的录音，斯鲁吉在演讲中概述了苹果定制芯片的开发情况，从 2010 年 iPhone 中的第一款 A4 芯片到最新为 Mac 台式电脑和 Vision Pro 耳机供电的芯片。</p>
<p>他说，苹果学到的一个重要教训是，需要使用最先进的工具来设计芯片，包括电子设计自动化 (EDA) 公司的最新芯片设计软件。</p>
<p>该行业的两大参与者 Cadence Design Systems 和 Synopsys 一直在竞相将人工智能添加到其产品中。</p>
<p>Srouji 在发言中表示：“EDA 公司对于我们芯片设计的复杂性至关重要。生成式 AI 技术具有在更短时间内完成更多设计工作的巨大潜力，可以大幅提高生产力。”</p>
<p>斯鲁吉表示，苹果在设计自己的芯片时学到的另一个重要教训是大胆尝试，不要回头。</p>
<p>2020 年，当苹果公司将其历史最悠久的活跃产品线 Mac 电脑从英特尔芯片转换为自家芯片时，并没有制定任何应急计划，以防转换失败。</p>
<p>“将 Mac 迁移到 Apple Silicon 平台对我们来说是一次巨大的赌注。我们没有备用方案，也没有拆分产品线的计划，所以我们全力以赴，包括投入了巨大的软件开发精力，”斯鲁吉说道。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>科技前沿</tag>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>关于1999C煤矸石堆积的研读报告</title>
    <url>/zhihaojiang.github.io/2025/07/01/20250701%E5%85%B3%E4%BA%8E1999C%E7%85%A4%E7%9F%B8%E7%9F%B3%E5%A0%86%E7%A7%AF%E7%9A%84%E7%A0%94%E8%AF%BB%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>此竞赛题目解决的是煤矸石堆积的问题 在面对矸石山不断堆积的情况下 需要制定合理的年度征地计划和给出在不同出矸率的情况下处理矸石的最低费用</p>
<h1 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h1><p>为了简化问题 此文章做了如下假设<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/01/001.png"
                      alt="photo"
                ></p>
<p>我认为这些假设是比较合理的 通过查询相关资料 其假设的数据符合实际生活中的数据</p>
<h1 id="建模准备"><a href="#建模准备" class="headerlink" title="建模准备"></a>建模准备</h1><p>在建模前他们首先给出了轨道长度与体积的关系、矸石山占地面积与体积的关系、占地面积与安息角的关系 在阅读的时候 我一开始不理解为什么要列出这些公式 在后续的阅读中我了解到了 轨道长度决定了运矸车运输的距离 从而影响能耗 成本 矸石堆积体积越大 轨道需要延伸得越长 建立轨道长度与体积的关系是为了后续计算运输成本 能量消耗等提供基础 占地面积决定率征地需求</p>
<p>征地费用是主要经济支出之一 因此需要知道给定体积下 占地多少土地 安息角决定了矸石自然堆积的最大坡度 坡度不同 相同体积下的占地面积就不同<br>我使用python对轨道长度与体积的关系、矸石山占地面积与体积的关系、占地面积与安息角的关系进行了复现 在假设体积为1000 安息角为35 轨道倾角为5时 得到轨道长度为61.3176 占地面积为35853292.5453 占地面积与安息角的关系如图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/01/002.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">V = 1000  <span class="comment"># 矸石山体积</span></span><br><span class="line">beta_deg = 1  <span class="comment"># 轨道倾角（度）</span></span><br><span class="line">alpha_deg_range = np.linspace(1, 55, 500)  <span class="comment"># 安息角范围</span></span><br><span class="line"></span><br><span class="line">beta = np.deg2rad(beta_deg)</span><br><span class="line">alpha_rad = np.deg2rad(alpha_deg_range)</span><br><span class="line"></span><br><span class="line">def compute_a(alpha, beta):</span><br><span class="line">    tan_alpha_sq = np.tan(alpha)**2</span><br><span class="line">    tan_beta_sq = np.tan(beta)**2</span><br><span class="line">    <span class="built_in">return</span> tan_beta_sq / (tan_alpha_sq - tan_beta_sq)</span><br><span class="line"></span><br><span class="line">def compute_a1(a):</span><br><span class="line">    sqrt_a = np.sqrt(a)</span><br><span class="line">    <span class="built_in">return</span> 1 + (np.pi / 2 + np.arctan(sqrt_a)) * sqrt_a</span><br><span class="line"></span><br><span class="line">def compute_S(V, alpha, beta):</span><br><span class="line">    a = compute_a(alpha, beta)</span><br><span class="line">    a1 = compute_a1(a)</span><br><span class="line">    numerator = 9 * a1 * V**2</span><br><span class="line">    denominator = np.sqrt(a) * np.tan(alpha)**2</span><br><span class="line">    S = (numerator / denominator)**(1/3)</span><br><span class="line">    <span class="built_in">return</span> S</span><br><span class="line"></span><br><span class="line">S_values = compute_S(V, alpha_rad, beta)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(10, 6))</span><br><span class="line">plt.plot(alpha_deg_range, S_values, label=r<span class="string">&#x27;$S(\alpha)$&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.xlabel(r<span class="string">&#x27;$\alpha$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">plt.title(r<span class="string">&#x27;S VS $\alpha$&#x27;</span>)</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p>这与论文中的图标几乎一致 论文中的\alpha范围应该进行了归一化处理 我这里没有进行处理 有些许不同 但无关紧要</p>
<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p>为了制定合理的年度征地计划 该论文建立了土地需求量公式 地价公式 电费公式 每年计划征地经费公式 征地规划模型<br>这些模型不是孤立存在的 而是环环相扣的 其最终目标优化土地使用 控制成本 合理安排资金流</p>
<h2 id="土地需求量公式"><a href="#土地需求量公式" class="headerlink" title="土地需求量公式"></a>土地需求量公式</h2><p>在论文中 通过几何分析与经验拟合 得到矸石山占地面积：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">S_i\ =\ 0.0015\left(\frac&#123;9a_ii^2V_0^2&#125;&#123;\sqrt a&#123;tan&#125;^2\alpha&#125;\right)^\frac&#123;1&#125;&#123;3&#125;</span><br></pre></td></tr></table></figure></div>
<p>此公式中参数a和a1来源于对堆积体形状的几何分析<br>a受\alpha，β的影响 反映了轨道倾角\beta与安息角\alpha对堆积形态的影响 a1可以看成一个修正因子 用于描述此煤矸石底面积变化趋势 0.0015是一个系数 由于体积的单位是立方米 而占地面积要转换成亩 因此乘以0.0015用于系数转换<br>∆Si &#x3D; Si - Si-1<br>这是一个显而易见的公式 表明了增加的变化量<br>因此土地需求量公式为<br>Si‘ &#x3D; 1+b∆Si<br>通过python复现当\beta&#x3D;25°时S1‘为10.663024317273257这与论文中的数值是一样的<br>不过我认为论文中的\beta&#x3D;25°不妥当此数值设置得并不合理 可能要讨论不同仰角的变化 不过在后续的灵敏度分析中讨论了不同轨道仰角的效率和经费剩余</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def compute_a(alpha_deg, beta_deg):</span><br><span class="line">    alpha = np.deg2rad(alpha_deg)</span><br><span class="line">    beta = np.deg2rad(beta_deg)</span><br><span class="line">    tan_alpha_sq = np.tan(alpha)**2</span><br><span class="line">    tan_beta_sq = np.tan(beta)**2</span><br><span class="line">    a = tan_beta_sq / (tan_alpha_sq - tan_beta_sq)</span><br><span class="line">    <span class="built_in">return</span> a</span><br><span class="line"></span><br><span class="line">def compute_a1(a):</span><br><span class="line">    sqrt_a = np.sqrt(a)</span><br><span class="line">    a1 = 1 + (np.pi / 2 + np.arctan(sqrt_a)) * sqrt_a</span><br><span class="line">    <span class="built_in">return</span> a1</span><br><span class="line"></span><br><span class="line">def compute_G0(d, e):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求g0:每年产生的煤矸石质量</span></span><br><span class="line"><span class="string">    d:原煤年产量</span></span><br><span class="line"><span class="string">    e:出矸率</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    g0 = (10000 * d * e) / (1 - e)</span><br><span class="line">    <span class="built_in">return</span> g0</span><br><span class="line"></span><br><span class="line">def compute_V0(g0, rho):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求v0:每年产生的煤矸石体积</span></span><br><span class="line"><span class="string">    g0:每年产生的煤矸石质量</span></span><br><span class="line"><span class="string">    rho:煤矸石容量</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    v0 = g0 / rho</span><br><span class="line">    <span class="built_in">return</span> v0</span><br><span class="line">def compute_Vi(i, v0):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求vi:第i年产生的煤矸石体积</span></span><br><span class="line"><span class="string">    i:第i年</span></span><br><span class="line"><span class="string">    v0:每年产生的煤矸石体积</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    vi = i * v0</span><br><span class="line">    <span class="built_in">return</span> vi</span><br><span class="line">def compute_Si(i, v0, alpha, beta):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求Si:第i年煤矸石占地面积</span></span><br><span class="line"><span class="string">    i:第i年</span></span><br><span class="line"><span class="string">    v0:每年产生的煤矸石体积</span></span><br><span class="line"><span class="string">    alpha:安息角</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    a:计算参数a 根据compute_a可以计算得到</span></span><br><span class="line"><span class="string">    a1:计算参数a1 根据compute_a1可以计算得到</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    a = compute_a(alpha, beta)</span><br><span class="line">    a1 = compute_a1(a)</span><br><span class="line">    tan_alpha = np.tan(np.deg2rad(alpha))</span><br><span class="line">    si = 0.0015 * ((<span class="number">9</span> * a1 * i**<span class="number">2</span> * v0**<span class="number">2</span>) / (np.sqrt(a) * tan_alpha**<span class="number">2</span>)) ** (1/3)</span><br><span class="line">    <span class="built_in">return</span> si</span><br><span class="line"></span><br><span class="line">def compute_delta_Si(i, v0, alpha, beta):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求第i年末煤矸石占地面积的增量</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> i == 0:</span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> compute_Si(i, v0, alpha, beta) - compute_Si(i - 1, v0, alpha, beta)</span><br><span class="line"></span><br><span class="line">def compute_S_dot_i(i, v0, alpha, beta, b):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求第i年土地需求量</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    delta_Si = compute_delta_Si(i, v0, alpha, beta)</span><br><span class="line">    s_dot_i = (1 + b) * delta_Si</span><br><span class="line">    <span class="built_in">return</span> s_dot_i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">beta = 25 <span class="comment"># 轨道倾角</span></span><br><span class="line">d = 300 <span class="comment"># 原煤年产量</span></span><br><span class="line">e = 0.07 <span class="comment"># 出矸率</span></span><br><span class="line">rho = 2 <span class="comment"># 煤矸石容量</span></span><br><span class="line">alpha = 55 <span class="comment"># 安息角</span></span><br><span class="line">i = 1 <span class="comment"># 第 i 年</span></span><br><span class="line">b = 0.1# 土地预留系数</span><br><span class="line">g0 = compute_G0(d, e)</span><br><span class="line">v0 = compute_V0(g0, rho)</span><br><span class="line"></span><br><span class="line">result = compute_S_dot_i(i, v0, alpha, beta, b)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">def compute_C1i(i):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    求第i年的地价</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    c0 = 8 <span class="comment">#手动输入 根据假设6给定</span></span><br><span class="line">    lam = 0.1 <span class="comment">#手动输入 根据假设6给定</span></span><br><span class="line">    c1i = c0 * (1 + lam) ** (i - 1)</span><br><span class="line">    <span class="built_in">return</span> c1i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">i = 1  <span class="comment"># 第 i 年</span></span><br><span class="line">c1i = compute_C1i(i)</span><br><span class="line"><span class="built_in">print</span>(c1i)</span><br></pre></td></tr></table></figure></div>
<h2 id="征地规划模型"><a href="#征地规划模型" class="headerlink" title="征地规划模型"></a>征地规划模型</h2><p>通过复现征地规划模型 我们得到了其结果 这个结果与论文中的一致 值得注意的是 在年数少于20时 其前几年得到的结果与论文中的不一致 经过排查得到在不同年数时资金时间价值累积效应 贷款安排策略 囤地策略会受到影响 本论文并未讨论不同年数对征地规划的影响 我认为此讨论是有必要的 为了增强论文的鲁棒性以及案例的迁移性 应该增加不同年份的征地策略 经过我的验证 当n&#x3D;5时 只有前两年会选择贷款 并且每年的累计余额也不同 随着年数的增加 贷款会越来越激进 说明征地的短期与长期规划是截然不同的 在前期时利润是偏低的 但到了后期利润是巨大的<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/01/003.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">n = 20</span><br><span class="line">R1 = 0.05  <span class="comment"># 自有资金利率</span></span><br><span class="line">R2 = 0.05  <span class="comment"># 贷款利率</span></span><br><span class="line">c1 = [8, 8.8, 9.68, 10.648, 11.7128,</span><br><span class="line">      12.88, 14.17, 15,59, 17,15, 18.86,</span><br><span class="line">      20.75, 22.82, 25.11, 27.62, 30.38,</span><br><span class="line">      33.42, 36.76, 40.44, 44.48, 48.93]           <span class="comment"># 每年土地价格（万元/亩）</span></span><br><span class="line"></span><br><span class="line">f1 = [97.11, 92.33, 90.31, 88.68, 87.26,</span><br><span class="line">      85.97, 84.78, 83.67, 82.61, 81.6,</span><br><span class="line">      80.62, 79.69, 78.78, 77.89, 77.03,</span><br><span class="line">      76.19, 75.37, 74.56, 73.77, 72.99]        <span class="comment"># 每年收入（万元）</span></span><br><span class="line"></span><br><span class="line">S_given = [10.66, 6.26, 5.25, 4.69, 4.31,</span><br><span class="line">           4.03, 3.81, 3.63, 3.48, 3.36,</span><br><span class="line">           3.25, 3.15, 3.06, 2.99, 2.92,</span><br><span class="line">           2.85, 2.79, 2.74, 2.69, 2.64]       <span class="comment"># 每年实际围地面积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model = pulp.LpProblem(<span class="string">&quot;1999C_Coal_Gangue_Model&quot;</span>, pulp.LpMaximize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 决策变量</span></span><br><span class="line">g = pulp.LpVariable.dicts(<span class="string">&quot;g&quot;</span>, range(n + 1), lowBound=0)         <span class="comment"># 实际支出</span></span><br><span class="line">u = pulp.LpVariable.dicts(<span class="string">&quot;u&quot;</span>, range(n + 1), lowBound=0)         <span class="comment"># 贷款金额</span></span><br><span class="line">w = pulp.LpVariable.dicts(<span class="string">&quot;w&quot;</span>, range(n + 1), lowBound=0)         <span class="comment"># 征地费用</span></span><br><span class="line">S_star = pulp.LpVariable.dicts(<span class="string">&quot;S_star&quot;</span>, range(n + 1), lowBound=0)  <span class="comment"># 累计囤地</span></span><br><span class="line">p = pulp.LpVariable.dicts(<span class="string">&quot;p&quot;</span>, range(n + 1), lowBound=0)         <span class="comment"># 经费余额</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始约束</span></span><br><span class="line">model += p[0] == 0, <span class="string">&quot;初始经费&quot;</span></span><br><span class="line">model += S_star[0] == 0, <span class="string">&quot;初始囤地&quot;</span></span><br><span class="line">model += u[0] == 0, <span class="string">&quot;初始贷款&quot;</span></span><br><span class="line">model += u[n] == 0, <span class="string">&quot;最后一年不贷款&quot;</span></span><br><span class="line">model += S_star[n] == 0, <span class="string">&quot;最终囤地为0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标函数</span></span><br><span class="line">model += p[n], <span class="string">&quot;最终经费最大&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐年约束</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1, n + 1):</span><br><span class="line">    <span class="comment"># 征地费用计算</span></span><br><span class="line">    model += w[i] == g[i] - u[i - 1] * (1 + R2) + u[i], f<span class="string">&quot;征地费用_&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 囤地数量递推</span></span><br><span class="line">    model += S_star[i] == S_star[i - 1] + w[i] * (1.0 / c1[i - 1]) - S_given[i - 1], f<span class="string">&quot;囤地数量递推_&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 经费余额</span></span><br><span class="line">    model += p[i] == (p[i - 1] + f1[i - 1] - g[i]) * (1 + R1), f<span class="string">&quot;经费累计余额_&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 支出限制</span></span><br><span class="line">    model += g[i] &lt;= p[i - 1] + f1[i - 1], f<span class="string">&quot;支出限制_&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能超额围地</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1, n):</span><br><span class="line">    model += S_star[i] &lt;= <span class="built_in">sum</span>(S_given[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(i, n)), f<span class="string">&quot;围地策略_&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">model.solve(pulp.PULP_CBC_CMD(msg=0))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pulp.LpStatus[model.status] != <span class="string">&#x27;Optimal&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;求解失败，状态：&quot;</span>, pulp.LpStatus[model.status])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;求解成功，目标函数值（第20年末经费余额）:&quot;</span>, round(p[n].varValue, 2), <span class="string">&quot;万元&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n + 1):</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;\n第&#123;i&#125;年：&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;  支出 g_&#123;i&#125; = &#123;g[i].varValue:.2f&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;  贷款 u_&#123;i&#125; = &#123;u[i].varValue:.2f&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;  囤地 S*_i = &#123;S_star[i].varValue:.2f&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;  征地费用 w_&#123;i&#125; = &#123;w[i].varValue:.2f&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;  经费余额 p_&#123;i&#125; = &#123;p[i].varValue:.2f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p>我们同样复现了此模型 得到：	<br>Optimal - objective value -35.832721<br>这个结果与论文中的一致 同样 我们发现 在不同的年数其最优解存在不同因此 我认为该论文添加上对不同年份的经费讨论</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pulp</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">d = 3000000      <span class="comment"># 原煤年产量（吨）</span></span><br><span class="line">rho = 2          <span class="comment"># 煤矸石容量（吨/立方米）</span></span><br><span class="line">alpha = 55       <span class="comment"># 安息角（度）</span></span><br><span class="line">beta = 25        <span class="comment"># 轨道倾角（度）</span></span><br><span class="line">n = 20           <span class="comment"># 规划年限</span></span><br><span class="line">R1 = 0.05        <span class="comment"># 经费累计余额利率</span></span><br><span class="line">R2 = 0.05        <span class="comment"># 贷款利率</span></span><br><span class="line"></span><br><span class="line">c1 = [8, 8.8, 9.68, 10.648, 11.7128,</span><br><span class="line">      12.88, 14.17, 15,59, 17,15, 18.86,</span><br><span class="line">      20.75, 22.82, 25.11, 27.62, 30.38,</span><br><span class="line">      33.42, 36.76, 40.44, 44.48, 48.93]         <span class="comment"># 每年土地价格（万元/亩）</span></span><br><span class="line"></span><br><span class="line">f1 = [97.11, 92.33, 90.31, 88.68, 87.26,</span><br><span class="line">      85.97, 84.78, 83.67, 82.61, 81.6,</span><br><span class="line">      80.62, 79.69, 78.78, 77.89, 77.03,</span><br><span class="line">      76.19, 75.37, 74.56, 73.77, 72.99]        <span class="comment"># 每年收入（万元）</span></span><br><span class="line"></span><br><span class="line">S_prime = [10.66, 6.26, 5.25, 4.69, 4.31,</span><br><span class="line">           4.03, 3.81, 3.63, 3.48, 3.36,</span><br><span class="line">           3.25, 3.15, 3.06, 2.99, 2.92,</span><br><span class="line">           2.85, 2.79, 2.74, 2.69, 2.64]       <span class="comment"># 每年实际围地面积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 a 和 a1</span></span><br><span class="line">def compute_a(alpha_deg, beta_deg):</span><br><span class="line">    alpha = np.deg2rad(alpha_deg)</span><br><span class="line">    beta = np.deg2rad(beta_deg)</span><br><span class="line">    tan_alpha_sq = np.tan(alpha)**2</span><br><span class="line">    tan_beta_sq = np.tan(beta)**2</span><br><span class="line">    a = tan_beta_sq / (tan_alpha_sq - tan_beta_sq)</span><br><span class="line">    <span class="built_in">return</span> a</span><br><span class="line"></span><br><span class="line">def compute_a1(a):</span><br><span class="line">    sqrt_a = np.sqrt(a)</span><br><span class="line">    a1 = 1 + (np.pi / 2 + np.arctan(sqrt_a)) * sqrt_a</span><br><span class="line">    <span class="built_in">return</span> a1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算第 i 年的占地面积 Si</span></span><br><span class="line">def compute_Si(i, v0, alpha):</span><br><span class="line">    a = compute_a(alpha, beta)</span><br><span class="line">    a1 = compute_a1(a)</span><br><span class="line">    si = 0.0015 * ((<span class="number">9</span> * a1 * i**<span class="number">2</span> * v0**<span class="number">2</span>) / (np.sqrt(a) * np.tan(np.deg2rad(alpha))**2)) ** (1/3)</span><br><span class="line">    <span class="built_in">return</span> si</span><br><span class="line"></span><br><span class="line">def solve_model(v0, e):</span><br><span class="line">    <span class="comment"># 计算第一年占地 S1</span></span><br><span class="line">    S1 = compute_Si(1, v0, alpha)</span><br><span class="line"></span><br><span class="line">    model = pulp.LpProblem(<span class="string">&quot;Minimum_Delta_q&quot;</span>, pulp.LpMinimize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决策变量</span></span><br><span class="line">    delta_q = pulp.LpVariable(<span class="string">&quot;delta_q&quot;</span>, lowBound=None, upBound=None)</span><br><span class="line">    g_vars = pulp.LpVariable.dicts(<span class="string">&quot;g&quot;</span>, range(1, n+1), lowBound=0)</span><br><span class="line">    u_vars = pulp.LpVariable.dicts(<span class="string">&quot;u&quot;</span>, range(n+1), lowBound=0)</span><br><span class="line">    S_star = pulp.LpVariable.dicts(<span class="string">&quot;S_star&quot;</span>, range(n+1), lowBound=0)</span><br><span class="line">    p_vars = pulp.LpVariable.dicts(<span class="string">&quot;p&quot;</span>, range(n+1), lowBound=0)</span><br><span class="line">    w_vars = pulp.LpVariable.dicts(<span class="string">&quot;w&quot;</span>, range(1, n+1), lowBound=0)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目标 最小化经费增量</span></span><br><span class="line">    model += delta_q, <span class="string">&quot;Minimize_Delta_q&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 约束条件</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n+1):</span><br><span class="line">        <span class="comment"># 经费余额公式</span></span><br><span class="line">        model += p_vars[i] == (p_vars[i-1] + f1[i-1] - g_vars[i] + delta_q) * (1 + R1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 支出额限制</span></span><br><span class="line">        model += g_vars[i] &lt;= p_vars[i-1] + f1[i-1] + delta_q</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 征地费用公式</span></span><br><span class="line">        model += w_vars[i] == g_vars[i] - u_vars[i-1] * (1 + R2) + u_vars[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 围地数量递推关系</span></span><br><span class="line">        inv_c1 = 1.0 / c1[i-1]</span><br><span class="line">        model += S_star[i-1] + w_vars[i] * inv_c1 - S_prime[i-1] == S_star[i]</span><br><span class="line"></span><br><span class="line">        model += S_star[i] &gt;= 0, f<span class="string">&quot;Non-negative_S_star_&#123;i&#125;&quot;</span></span><br><span class="line">        model += g_vars[i] &gt;= 0, f<span class="string">&quot;Non-negative_g_&#123;i&#125;&quot;</span></span><br><span class="line">        model += u_vars[i] &gt;= 0, f<span class="string">&quot;Non-negative_u_&#123;i&#125;&quot;</span></span><br><span class="line">        model += w_vars[i] &gt;= 0, f<span class="string">&quot;Non-negative_w_&#123;i&#125;&quot;</span></span><br><span class="line">        model += p_vars[i] &gt;= 0, f<span class="string">&quot;Non-negative_p_&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    model += p_vars[0] == 0</span><br><span class="line">    model += p_vars[n] == 0 </span><br><span class="line">    model += S_star[0] == 0</span><br><span class="line">    model += S_star[n] == 0</span><br><span class="line">    model += u_vars[0] == 0</span><br><span class="line">    model += u_vars[n] == 0</span><br><span class="line"></span><br><span class="line">    model.solve()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> delta_q.varValue, S1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历不同出矸率</span></span><br><span class="line">e_values = np.arange(0.07, 0.11, 0.01)  <span class="comment"># 出矸率从 5% 到 15%</span></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> e_values:</span><br><span class="line">    g0 = (d * e) / (1 - e)</span><br><span class="line">    v0 = g0 / rho</span><br><span class="line"></span><br><span class="line">    delta_q_opt, S1 = solve_model(v0, e)</span><br><span class="line"></span><br><span class="line">    results.append(&#123;</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>: round(e, 2),</span><br><span class="line">        <span class="string">&#x27;v0&#x27;</span>: round(v0, 2),</span><br><span class="line">        <span class="string">&#x27;S1&#x27;</span>: round(S1, 2),</span><br><span class="line">        <span class="string">&#x27;delta_q&#x27;</span>: round(delta_q_opt, 2)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:&lt;6&#125; &#123;:&lt;12&#125; &#123;:&lt;10&#125; &#123;:&lt;12&#125;&quot;</span>.format(<span class="string">&quot;e (%)&quot;</span>, <span class="string">&quot;v0 (m³)&quot;</span>, <span class="string">&quot;S1 (亩)&quot;</span>, <span class="string">&quot;Δq (万元)&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;&#123;res[&#x27;e&#x27;]*100:.0f&#125;%\t&#123;res[&#x27;v0&#x27;]&#125;\t\t&#123;res[&#x27;S1&#x27;]&#125;\t\t&#123;res[&#x27;delta_q&#x27;]&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h1 id="灵敏度稳健性分析"><a href="#灵敏度稳健性分析" class="headerlink" title="灵敏度稳健性分析"></a>灵敏度稳健性分析</h1><p>该论文讨论了地价涨幅 矸石容量 机械效率 电费增长 贷款利率变化 对经费的变化 通过调整相应的参数 发现地价涨幅 矸石容量 机械效率 电费增长对结果影响不大 这与论文结果一致 然而该论文并未讨论安息角与轨道仰角的灵敏度分析 并且论文中的安息角均取55°通过查询得知55°为最大安息角 论文中均取的最大安息角会导致模型高估了堆料稳定性 低估了实际占地面积 这会使模型不具推广性 仅适用于特定场景 模型得到的经费剩余偏低 我认为安息角的设置应该用保守的估计策略 例如40°左右 我们需要考虑到实际操作时产生的误差<br>我们通过分析安息角对经费和占地面积的影响得到了如下图表<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/01/005.png"
                      alt="photo"
                ></p>
<p>分析发现这个增长率蛮大的 因此 我认为在进行灵敏度分析的时候应该加上安息角的灵敏度分析 </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def run_model(c1, f1, S_given, R1=0.05, R2=0.05, n=5):</span><br><span class="line">    model = pulp.LpProblem(<span class="string">&quot;1999C_Coal_Gangue_Model&quot;</span>, pulp.LpMaximize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决策变量</span></span><br><span class="line">    g = pulp.LpVariable.dicts(<span class="string">&quot;g&quot;</span>, range(n + 1), lowBound=0)</span><br><span class="line">    u = pulp.LpVariable.dicts(<span class="string">&quot;u&quot;</span>, range(n + 1), lowBound=0)</span><br><span class="line">    w = pulp.LpVariable.dicts(<span class="string">&quot;w&quot;</span>, range(n + 1), lowBound=0)</span><br><span class="line">    S_star = pulp.LpVariable.dicts(<span class="string">&quot;S_star&quot;</span>, range(n + 1), lowBound=0)</span><br><span class="line">    p = pulp.LpVariable.dicts(<span class="string">&quot;p&quot;</span>, range(n + 1), lowBound=0)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始约束</span></span><br><span class="line">    model += p[0] == 0</span><br><span class="line">    model += S_star[0] == 0</span><br><span class="line">    model += u[0] == 0</span><br><span class="line">    model += u[n] == 0</span><br><span class="line">    model += S_star[n] == 0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目标函数</span></span><br><span class="line">    model += p[n]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 约束条件</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n + 1):</span><br><span class="line">        model += w[i] == g[i] - u[i - 1] * (1 + R2) + u[i]</span><br><span class="line">        model += S_star[i] == S_star[i - 1] + w[i] * (1.0 / c1[i - 1]) - S_given[i - 1]</span><br><span class="line">        model += p[i] == (p[i - 1] + f1[i - 1] - g[i]) * (1 + R1)</span><br><span class="line">        model += g[i] &lt;= p[i - 1] + f1[i - 1]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            model += S_star[i] &lt;= <span class="built_in">sum</span>(S_given[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(i, n))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求解</span></span><br><span class="line">    model.solve(pulp.PULP_CBC_CMD(msg=False))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回最终经费余额</span></span><br><span class="line">    <span class="keyword">if</span> pulp.LpStatus[model.status] == <span class="string">&#x27;Optimal&#x27;</span>:</span><br><span class="line">        <span class="built_in">return</span> p[n].varValue</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> None</span><br><span class="line"></span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def compute_S_given(alpha_deg, base_S):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;根据安息角调整土地需求&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    alpha_rad = math.radians(alpha_deg)</span><br><span class="line">    scale_factor = 1 / (math.tan(alpha_rad)**2)</span><br><span class="line">    <span class="built_in">return</span> [s * scale_factor <span class="keyword">for</span> s <span class="keyword">in</span> base_S]</span><br><span class="line"></span><br><span class="line">base_S = S_given[:n]  <span class="comment"># 原始占地需求</span></span><br><span class="line">alphas = np.linspace(30, 55, 10)  <span class="comment"># 安息角从30°~55°</span></span><br><span class="line">alpha_results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alpha <span class="keyword">in</span> alphas:</span><br><span class="line">    S_given_alpha = compute_S_given(alpha, base_S)</span><br><span class="line">    final_balance = run_model(c1=c1[:n], f1=f1[:n], S_given=S_given_alpha, n=n)</span><br><span class="line">    alpha_results.append(&#123;</span><br><span class="line">        <span class="string">&quot;alpha&quot;</span>: alpha,</span><br><span class="line">        <span class="string">&quot;final_balance&quot;</span>: final_balance,</span><br><span class="line">        <span class="string">&quot;scale_factor&quot;</span>: 1 / (math.tan(math.radians(alpha)) ** 2)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取绘图数据</span></span><br><span class="line">x_alphas = [r[<span class="string">&quot;alpha&quot;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> alpha_results]</span><br><span class="line">y_balances = [r[<span class="string">&quot;final_balance&quot;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> alpha_results]</span><br><span class="line">y_scales = [r[<span class="string">&quot;scale_factor&quot;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> alpha_results]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安息角 vs 最终经费</span></span><br><span class="line">plt.figure(figsize=(12, 5))</span><br><span class="line">plt.subplot(1, 2, 1)</span><br><span class="line">plt.plot(x_alphas, y_balances, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;安息角对最终经费的影响&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;安息角 α (°)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;最终经费余额（万元）&quot;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安息角 vs 占地规模因子</span></span><br><span class="line">plt.subplot(1, 2, 2)</span><br><span class="line">plt.plot(x_alphas, y_scales, marker=<span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;安息角对占地规模的影响&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;安息角 α (°)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;占地缩放因子&quot;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<h1 id="模型拓展"><a href="#模型拓展" class="headerlink" title="模型拓展"></a>模型拓展</h1><p>该论文讨论了仰角\beta的最优解 其最优解为29°<br>我认为可以在此基础上添加上仰角对占地面积的关系 再由占地面积推导出对经费的影响</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始参数</span></span><br><span class="line">base_S = [10.66, 6.26, 5.25, 4.69, 4.31][:5]  <span class="comment"># 原始占地需求</span></span><br><span class="line">c1 = [8, 8.8, 9.68, 10.648, 11.7128][:5]      <span class="comment"># 地价</span></span><br><span class="line">f1 = [97.11, 92.33, 90.31, 88.68, 87.26][:5]  <span class="comment"># 每年收入</span></span><br><span class="line">n = 5                                           <span class="comment"># 年数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 β 的变化范围</span></span><br><span class="line">beta_values = np.linspace(15, 43, 10)  <span class="comment"># 从 5° 到 25°，共 10 个点</span></span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beta <span class="keyword">in</span> beta_values:</span><br><span class="line">    S_given_beta = compute_S_given(beta, base_S)</span><br><span class="line">    final_balance = run_model(c1=c1, f1=f1, S_given=S_given_beta, n=n)</span><br><span class="line">    </span><br><span class="line">    results.append(&#123;</span><br><span class="line">        <span class="string">&quot;beta&quot;</span>: beta,</span><br><span class="line">        <span class="string">&quot;final_balance&quot;</span>: final_balance,</span><br><span class="line">        <span class="string">&quot;avg_land&quot;</span>: <span class="built_in">sum</span>(S_given_beta) / len(S_given_beta),</span><br><span class="line">        <span class="string">&quot;total_land&quot;</span>: <span class="built_in">sum</span>(S_given_beta)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取绘图数据</span></span><br><span class="line">x_betas = [r[<span class="string">&quot;beta&quot;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> results]</span><br><span class="line">y_balance = [r[<span class="string">&quot;final_balance&quot;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> results]</span><br><span class="line">y_total_land = [r[<span class="string">&quot;total_land&quot;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> results]</span><br><span class="line"></span><br><span class="line">plt.plot(x_betas, y_total_land, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;轨道仰角 vs 总占地面积&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;轨道仰角 β (°)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;总占地面积（亩）&quot;</span>)</span><br><span class="line">plt.grid(True)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>《煤矿安全规程》<br>第三百七十五条规定：采用轨道运输的巷道，其坡度不宜超过 15°<br>矿山机械设计手册》<br>一般矿用机车最大允许坡度为 15°~20° ；<br>超过 20° 的轨道需采取特殊措施</p>
</blockquote>
<p>因此 我认为 这个最优解只是一个理想的最优解</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>关于2003D抢渡长江的研读报告</title>
    <url>/zhihaojiang.github.io/2025/07/02/20250702%E5%85%B3%E4%BA%8E2003D%E6%8A%A2%E6%B8%A1%E9%95%BF%E6%B1%9F%E7%9A%84%E7%A0%94%E8%AF%BB%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>本论文一抢渡长江为背景 需要完成在已知江宽 水流速度分布 选手游泳速度的前提下 建立模型计算出选手应采取的最佳游泳方向或路径 </p>
<h1 id="建模准备"><a href="#建模准备" class="headerlink" title="建模准备"></a>建模准备</h1><p>建模前先推导了正弦定理和余弦定理</p>
<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/02/001.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/02/002.jpg"
                      alt="photo"
                ></p>
<p>我对论文中的相关公式进行了推导<br>由论文中给出的参数得知<br>$$<br>\tan \angle BAE &#x3D; \frac{x}{c}<br>$$</p>
<h2 id="10-4"><a href="#10-4" class="headerlink" title="(10-4)"></a>(10-4)</h2><p>theta是游泳者的合成速度方向<br>$$<br>\theta &#x3D; \angle FAE &#x3D; \frac{\pi}{2} - \angle BAE &#x3D; \frac{\pi}{2} - \arctan\left(\frac{x}{c}\right)<br>$$</p>
<p>论文中的<br>$$<br>\frac{v_0}{\sin \angle AEF} &#x3D; \frac{v_1}{\sin(\theta)}<br>$$<br>用到了正弦定理<br>在三角形AEF中<br>$$<br>\frac{AF}{\sin \angle AEF} &#x3D; \frac{EF}{\sin(\angle FAE)}<br>$$<br>由于</p>
<blockquote>
<p>EF &#x3D; DA &#x3D; v1<br>sin(theta) &#x3D; sin(∠FAE)</p>
</blockquote>
<p>因此推导出<br>$$<br>\frac{v_0}{\sin \angle AEF} &#x3D; \frac{v_1}{\sin(\theta)}<br>$$<br>经过变换得<br>$$<br>\angle AEF &#x3D; \arcsin \left( \frac{v_0 \sin \theta}{v_1} \right)<br>$$</p>
<h2 id="10-5"><a href="#10-5" class="headerlink" title="(10-5)"></a>(10-5)</h2><p>游泳者的速度方向角<br>$$<br>\alpha &#x3D; \angle FAD &#x3D; \angle FAE + \angle EAD<br>$$<br>观察四边形ADEF<br>此处的合成速度v2（对应向量 AE）由两个分速度v0和v1​通过矢量相加的方式合成 作为矢量 速度的合成遵循平行四边形法则 即以v0和v1为邻边构成的平行四边形 其对角线表示合速度v2的大小和方向<br>因此∠AEF &#x3D; ∠EAD(对顶角相等)<br>得到<br>$$<br>\alpha &#x3D; \angle FAD &#x3D; \theta + \angle AEF<br>$$</p>
<p>在三角形AEF中 根据余弦定理<br>$$<br>AE &#x3D; \sqrt{AF^2 + EF^2 - 2AF EF\cos\angle AEF}<br>$$<br>又由于<br>$$<br>-\cos(\alpha) &#x3D; \cos(x - \alpha)<br>$$</p>
<h2 id="10-6"><a href="#10-6" class="headerlink" title="(10-6)"></a>(10-6)</h2><p>因此<br>$$<br>v_2 &#x3D; \sqrt{v_0^2 + v_1^2 + 2v_0v_1\cos\alpha}<br>$$</p>
<h2 id="10-7"><a href="#10-7" class="headerlink" title="(10-7)"></a>(10-7)</h2><p>根据速度公式t &#x3D; s&#x2F;v<br>在论文中其将路程分为了AP PC两段 因此公式中前半部份是AP的时间 后半部份是PC的时间 由于在PC时v0 v1方向同向 因此是v0+v1<br>$$<br>t &#x3D; \frac{\sqrt{c^2 + x^2}}{v_2} + \frac{a - x}{v_0 + v_1}<br>$$</p>
<h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><p>通过一下代码求的相对应的结果</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知参数</span></span><br><span class="line">a = 1000</span><br><span class="line">c = 1160</span><br><span class="line">v0 = 1.89  <span class="comment"># 水的流速</span></span><br><span class="line">v1 = 1.5  <span class="comment"># 游泳速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 公式</span></span><br><span class="line">def calculate_theta(x, c):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    计算theta</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算theta</span></span><br><span class="line">    theta = math.pi / 2 - math.atan(x / c)</span><br><span class="line">    <span class="comment"># 返回theta</span></span><br><span class="line">    <span class="built_in">return</span> theta</span><br><span class="line"></span><br><span class="line">def calculate_AEF(theta, v0, v1):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    计算AEF</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    AEF = math.asin(v0 * math.sin(theta) / v1)</span><br><span class="line">    <span class="built_in">return</span> AEF</span><br><span class="line"></span><br><span class="line">def calculate_alpha(theta, AEF):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    计算alpha</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    alpha = theta + AEF</span><br><span class="line">    <span class="built_in">return</span> alpha</span><br><span class="line"></span><br><span class="line">def calculate_v2(v0, v1, alpha):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    计算v2</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    cos_alpha = math.cos(alpha)</span><br><span class="line">    v2 = math.sqrt(v0**2 + v1**2 + 2 * v0 * v1 * cos_alpha)</span><br><span class="line">    <span class="built_in">return</span> v2</span><br></pre></td></tr></table></figure></div>

<p>通过一下代码可以得到当v1 &#x3D; 1.5 1.89 2.11 v0 &#x3D; 1.89时游泳时间与x的趋势</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">a = 1000</span><br><span class="line">c = 1160</span><br><span class="line">v0 = 1.89</span><br><span class="line">v1 = 1.5  <span class="comment"># 给定游泳速度</span></span><br><span class="line"></span><br><span class="line">model = SwimModel(a=a, c=c, v0=v0, v1=v1)</span><br><span class="line"></span><br><span class="line">x_values = list(range(900, 1001, 5))</span><br><span class="line">t_values = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> x_values:</span><br><span class="line">    result = model.forward(x)</span><br><span class="line">    t_values.append(result[<span class="string">&quot;time&quot;</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(8, 5))</span><br><span class="line">plt.plot(x_values, t_values, marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;t VS x&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;t&quot;</span>)</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<p>通过以下代码可以解得在x &#x3D; 1000时游泳者的速度 方向 时间</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">from scipy.optimize import fsolve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知参数</span></span><br><span class="line">T_target = 910</span><br><span class="line">x = 1000</span><br><span class="line">c = 1160</span><br><span class="line">v0 = 1.89</span><br><span class="line">a = 1000</span><br><span class="line"><span class="comment"># 求theta</span></span><br><span class="line">theta = math.atan(c / x)</span><br><span class="line"></span><br><span class="line">def time_equation(v1):</span><br><span class="line"></span><br><span class="line">    ratio = (v0 * math.sin(theta)) / v1</span><br><span class="line">    <span class="keyword">if</span> abs(ratio) &gt; 1:</span><br><span class="line">        <span class="built_in">return</span> 1e9</span><br><span class="line"></span><br><span class="line">    AEF = math.asin(ratio)</span><br><span class="line">    alpha = theta + AEF</span><br><span class="line">    v2 = math.sqrt(v0**2 + v1**2 + 2 * v0 * v1 * math.cos(alpha))</span><br><span class="line">    T_computed = math.sqrt(x**2 + c**2) / v2 + (a - x) / (v0 + v1)</span><br><span class="line">    <span class="built_in">return</span> T_computed - T_target</span><br><span class="line"></span><br><span class="line">v1_guess = 1.0</span><br><span class="line">v1_solution = fsolve(time_equation, v1_guess)[0]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;所需的游泳者速度 v1 ≈ &#123;v1_solution:.4f&#125; m/s&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>所需的游泳者速度 v1 ≈ 1.5003 m&#x2F;s</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">from scipy.optimize import fsolve</span><br><span class="line"></span><br><span class="line">class SwimModel:</span><br><span class="line">    def __init__(self, a, c, v0, v1=None):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        a: 终点</span></span><br><span class="line"><span class="string">        c: 距离</span></span><br><span class="line"><span class="string">        v0: 水流速度</span></span><br><span class="line"><span class="string">        v1: 游泳速度</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.c = c</span><br><span class="line">        self.v0 = v0</span><br><span class="line">        self.v1 = v1</span><br><span class="line"></span><br><span class="line">    def theta(self, x):</span><br><span class="line">        <span class="built_in">return</span> math.pi / 2 - math.atan(x / self.c)</span><br><span class="line"></span><br><span class="line">    def AEF(self, theta, v1):</span><br><span class="line">        ratio = self.v0 * math.sin(theta) / v1</span><br><span class="line">        <span class="built_in">return</span> math.asin(ratio)</span><br><span class="line"></span><br><span class="line">    def alpha(self, theta, AEF):</span><br><span class="line">        <span class="built_in">return</span> theta + AEF</span><br><span class="line"></span><br><span class="line">    def v2(self, v1, alpha):</span><br><span class="line">        <span class="built_in">return</span> math.sqrt(self.v0**2 + v1**2 + 2 * self.v0 * v1 * math.cos(alpha))</span><br><span class="line"></span><br><span class="line">    def total_time(self, v2, v1, x):</span><br><span class="line">        swim_time = math.sqrt(self.c**2 + x**2) / v2</span><br><span class="line">        flow_time = (self.a - x) / (self.v0 + v1)</span><br><span class="line">        <span class="built_in">return</span> swim_time + flow_time</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;前向：已知 x 和 v1，输出 α, v2, t&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.v1 is None:</span><br><span class="line">            raise ValueError(<span class="string">&quot;请先设置 v1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        theta = self.theta(x)</span><br><span class="line">        AEF = self.AEF(theta, self.v1)</span><br><span class="line">        alpha = self.alpha(theta, AEF)</span><br><span class="line">        v2 = self.v2(self.v1, alpha)</span><br><span class="line">        t = self.total_time(v2, self.v1, x)</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;theta_rad&quot;</span>: theta,</span><br><span class="line">            <span class="string">&quot;alpha_rad&quot;</span>: alpha,</span><br><span class="line">            <span class="string">&quot;alpha_deg&quot;</span>: math.degrees(alpha),</span><br><span class="line">            <span class="string">&quot;v2&quot;</span>: v2,</span><br><span class="line">            <span class="string">&quot;time&quot;</span>: t</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    def inverse_solve_v1(self, x, T_target):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;已知 T_target 和 x，求 v1&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        def equation(v1):</span><br><span class="line">            theta = self.theta(x)</span><br><span class="line">            AEF = self.AEF(theta, v1)</span><br><span class="line">            alpha = self.alpha(theta, AEF)</span><br><span class="line">            v2 = self.v2(v1, alpha)</span><br><span class="line">            t = self.total_time(v2, v1, x)</span><br><span class="line">            <span class="built_in">return</span> t - T_target</span><br><span class="line"></span><br><span class="line">        result = fsolve(equation, 1.0)[0]</span><br><span class="line">        <span class="built_in">return</span> result</span><br><span class="line"></span><br><span class="line">model = SwimModel(a=1000, c=1160, v0=1.89, v1=1.50)</span><br><span class="line">result = model.forward(x=1000)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;α: &#123;result[&#x27;alpha_deg&#x27;]:.2f&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;v2: &#123;result[&#x27;v2&#x27;]:.4f&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;t:  &#123;result[&#x27;time&#x27;]:.2f&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>α: 121.85<br>v2: 1.6822<br>t:  910.46</p>
</blockquote>
<h1 id="选手成功到达终点的概率"><a href="#选手成功到达终点的概率" class="headerlink" title="选手成功到达终点的概率"></a>选手成功到达终点的概率</h1><p>论文中定义概率<br>$$<br>p &#x3D; \frac{d(v_1)}{f(v_{\text{max}})}<br>$$<br>其意思是 在游泳速度为v1时成功的概率&#x2F;在游泳速度最大时成功的概率<br>检测在2002年时的最低游泳成功的速度</p>
<h2 id="代码复现-1"><a href="#代码复现-1" class="headerlink" title="代码复现"></a>代码复现</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = 1.89  <span class="comment"># 流速</span></span><br><span class="line">X = 1000.0</span><br><span class="line">Y = 1160.0</span><br><span class="line"></span><br><span class="line">def v_min(u, X, Y):</span><br><span class="line">    <span class="built_in">return</span> np.sqrt(u**2 + (X/Y)**2)</span><br><span class="line"></span><br><span class="line">v_thresh = v_min(u, X, Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2002 阈值速度 v_min =&quot;</span>, v_thresh, <span class="string">&quot;m/s&quot;</span>)  <span class="comment"># ~2.08 m/s</span></span><br><span class="line"></span><br><span class="line">vs = np.linspace(0.5, 4.0, 36)</span><br><span class="line">results = [<span class="string">&quot;可成功&quot;</span> <span class="keyword">if</span> v&gt;=v_thresh <span class="keyword">else</span> <span class="string">&quot;失败&quot;</span> <span class="keyword">for</span> v <span class="keyword">in</span> vs]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v, res <span class="keyword">in</span> zip(vs, results):</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;速度 &#123;v:.2f&#125; m/s: &#123;res&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def v_min(u, Y, X):</span><br><span class="line">    <span class="built_in">return</span> u * Y / X</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">u_2002 = 1.3</span><br><span class="line">Y_2002 = 1160 <span class="comment"># 江宽</span></span><br><span class="line">X_2002 = 1000 <span class="comment"># 起点到终点的水平距离</span></span><br><span class="line"></span><br><span class="line">v_threshold_1934 = v_min(u_2002, Y_2002, X_2002)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;2002 年成功游过江所需最低速度为：&#123;v_threshold_1934:&#125; m/s&quot;</span>)</span><br><span class="line"></span><br><span class="line">def v_min(u, Y, X):</span><br><span class="line">    <span class="built_in">return</span> u * Y / X</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">u_1934 = 1.2</span><br><span class="line">Y_1934 = 1400 <span class="comment"># 江宽</span></span><br><span class="line">X_1934 = 3800 <span class="comment"># 起点到终点的水平距离</span></span><br><span class="line"></span><br><span class="line">v_threshold_1934 = v_min(u_1934, Y_1934, X_1934)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;1934 年成功游过江所需最低速度为：&#123;v_threshold_1934:&#125; m/s&quot;</span>)  <span class="comment"># 约 0.44</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>2002 年成功游过江所需最低速度为：1.508 m&#x2F;s<br>1934 年成功游过江所需最低速度为：0.4421052631578947 m&#x2F;s</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def d(v1, a, c):</span><br><span class="line">    v0 = 1.89  <span class="comment"># 水的流速</span></span><br><span class="line">    upper = a - c * math.tan(math.acos(v1 / v0))</span><br><span class="line">    d = upper / a</span><br><span class="line">    <span class="built_in">return</span> d</span><br><span class="line">p_2002 = d(1.5, 1000, 1160) / d(1.7, 1000, 1160)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;2002 年成功游过江的概率 p_2002 = &#123;p_2002&#125;&quot;</span>)</span><br><span class="line">p_1934 = d(1.5, 3800, 1400) / d(1.7, 3800, 1400)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;1934 年成功游过江的概率 p_1934 = &#123;p_1934&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>2002 年成功游过江的概率 p_2002 &#x3D; 0.2538695839819621<br>1934 年成功游过江的概率 p_1934 &#x3D; 0.8740249877014562</p>
</blockquote>
<h1 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/02/003.jpg"
                      alt="photo"
                ></p>
<h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>求最优的成绩 因此目标函数就是最小时间(最小半江宽时间*2)</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>第1个约束</strong><br>每段的游泳时间</p>
<p><strong>第2个约束</strong><br>游泳者的速度 &gt;&#x3D; 水流在垂直方向的分量<br>v1 &gt; v0说明游泳者能能克服水流的影响</p>
<p><strong>第3个约束</strong><br>游泳者相对水流方向的夹角</p>
<p><strong>第4个约束</strong><br>速度与水速的夹角即抵消水流的角度</p>
<p><strong>第5个约束</strong><br>每一段的合成速度约束</p>
<p><strong>第6个约束</strong><br>自由变量</p>
<p><strong>第7个约束</strong><br>半江宽约束</p>
<h2 id="代码复现-2"><a href="#代码复现-2" class="headerlink" title="代码复现"></a>代码复现</h2><p>通过代码复现得</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.optimize import minimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">c1, c2 = 200, 380</span><br><span class="line">v01, v02 = 1.47, 2.11</span><br><span class="line">v1 = 1.5</span><br><span class="line">a_total = 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标函数</span></span><br><span class="line">def objective(a):</span><br><span class="line">    <span class="comment"># min f</span></span><br><span class="line">    a1, a2 = a</span><br><span class="line">    t1 = time_segment(a1, c1, v01)</span><br><span class="line">    t2 = time_segment(a2, c2, v02)</span><br><span class="line">    <span class="built_in">return</span> 2 * (t1 + t2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 约束条件</span></span><br><span class="line">def time_segment(ai, ci, v0i):</span><br><span class="line">    <span class="comment"># ti(ai)</span></span><br><span class="line">    theta = np.pi / 2 - np.arctan(ai / ci)</span><br><span class="line">    alpha = theta + np.arcsin((v0i * np.sin(theta)) / v1)</span><br><span class="line">    v2i = np.sqrt(v0i**2 + v1**2 + 2 * v0i * v1 * np.cos(alpha))</span><br><span class="line">    s = np.sqrt(ai**2 + ci**2)</span><br><span class="line">    <span class="built_in">return</span> s / v2i</span><br><span class="line"></span><br><span class="line">def eq_constraint(a):</span><br><span class="line">    <span class="comment"># a1 + a2 = 0.5a</span></span><br><span class="line">    <span class="built_in">return</span> a[0] + a[1] - a_total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ineq_constraint1(a):</span><br><span class="line">    <span class="comment"># v0i * c_i / sqrt(ai^2 + ci^2) ≤ v1</span></span><br><span class="line">    a1 = a[0]</span><br><span class="line">    <span class="built_in">return</span> v1 - v01 * c1 / np.sqrt(a1**2 + c1**2)</span><br><span class="line"></span><br><span class="line">def ineq_constraint2(a):</span><br><span class="line">    a2 = a[1]</span><br><span class="line">    <span class="built_in">return</span> v1 - v02 * c2 / np.sqrt(a2**2 + c2**2)</span><br><span class="line"></span><br><span class="line">def compute_alpha(ai, ci, v0i):</span><br><span class="line">    <span class="comment"># alpha(i)</span></span><br><span class="line">    theta = np.pi / 2 - np.arctan(ai / ci)</span><br><span class="line">    alpha = theta + np.arcsin((v0i * np.sin(theta)) / v1)</span><br><span class="line">    <span class="built_in">return</span> np.degrees(alpha)</span><br><span class="line"></span><br><span class="line">a_init = [100, 400]</span><br><span class="line">bounds = [(10, 490), (10, 490)]</span><br><span class="line"></span><br><span class="line">constraints = [</span><br><span class="line">    &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;eq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: eq_constraint&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: ineq_constraint1&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: ineq_constraint2&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">res = minimize(objective, a_init, bounds=bounds, constraints=constraints, method=<span class="string">&#x27;SLSQP&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.success:</span><br><span class="line">    a1, a2 = res.x</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;最优解：a1 = &#123;a1:.2f&#125;, a2 = &#123;a2:.2f&#125;, a1 + a2 = &#123;a1 + a2:.2f&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;总时间 = &#123;res.fun:.2f&#125; 秒&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;α1 = &#123;compute_alpha(a1, c1, v01):.2f&#125;°, α2 = &#123;compute_alpha(a2, c2, v02):.2f&#125;°&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优化失败：&quot;</span>, res.message)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>最优解：a1 &#x3D; 96.84, a2 &#x3D; 403.16, a1 + a2 &#x3D; 500.00<br>总时间 &#x3D; 904.02 秒<br>α1 &#x3D; 126.06°, α2 &#x3D; 118.06°</p>
</blockquote>
<h1 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h1><p>问题四的公式和问题三的类似 主要的不同点是问题三的速度v0i是两个离散的数值 问题四的v0i是连续数值离散化 可以有n个<br>论文中给出的v0i的公式<br>$$<br>v_{0i} &#x3D;<br>\begin{cases}<br>k(i - 0.5)c_{11} \<br>knc_{11}<br>\end{cases}<br>$$</p>
<p>其中k为水速斜率 其公式为<br>$$<br>k\ &#x3D;\ ∆v∆y<br>$$<br>意思是水速在∆y内变化了∆v<br>论文中由于水速是分段给出的连续分布 因此水速的变化是线性的 因此其水速斜率是一个常数<br>水速在200米内变化了2.28 （岸边速度为0 ～水速最大为2.28）<br>因此<br>$$<br>k\ &#x3D;\ \frac{2.28}{200}<br>$$</p>
<h2 id="代码复现-3"><a href="#代码复现-3" class="headerlink" title="代码复现"></a>代码复现</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def time_segment(a_i, c1i, v0i, debug=False):</span><br><span class="line">    theta_i = np.pi / 2 - np.arctan(a_i / c1i)</span><br><span class="line">    sin_theta = v0i * np.sin(theta_i) / v1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> np.abs(sin_theta) &gt; 1:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span>(f<span class="string">&quot;[警告] sin_theta=&#123;sin_theta:.4f&#125; 超出 [-1, 1]&quot;</span>)</span><br><span class="line">        sin_theta = np.clip(sin_theta, -1, 1)</span><br><span class="line"></span><br><span class="line">    alpha_i = theta_i + np.arcsin(sin_theta)</span><br><span class="line">    v2i = np.sqrt(v0i**2 + v1**2 + 2 * v0i * v1 * np.cos(alpha_i))</span><br><span class="line">    s = np.sqrt(a_i**2 + c1i**2)</span><br><span class="line">    <span class="keyword">time</span> = s / v2i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;a = &#123;a_i:.2f&#125;, c1 = &#123;c1i&#125;, v0 = &#123;v0i:.3f&#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;θ = &#123;np.degrees(theta_i):.2f&#125;°, α = &#123;np.degrees(alpha_i):.2f&#125;°, v2 = &#123;v2i:.3f&#125;, s = &#123;s:.2f&#125;, time = &#123;time:.2f&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">time</span></span><br><span class="line"></span><br><span class="line">a_list = [-30, 80, 420]</span><br><span class="line">c1_list = [100, 100, 380]</span><br><span class="line">v0i_list = [0.57, 1.71, 2.28]</span><br><span class="line">v1 = 1.5</span><br><span class="line">total_time = 0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(3):</span><br><span class="line">    t = time_segment(a_list[i], c1_list[i], v0i_list[i])</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;t&#123;i+1&#125;: &#123;t:.2f&#125; s&quot;</span>)</span><br><span class="line">    total_time += t</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;总时间：&#123;2 * total_time:&#125; 秒&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>t1: 84.65 s<br>t2: 73.11 s<br>t3: 334.95 s<br>总时间：985.430963388645 秒</p>
</blockquote>
<p>可以在论文中看到其路径是先往上游游在往下游游<br>这有点不符合直觉<br>我们假设若按照直线游<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/02/004.jpg"
                      alt="photo"
                ></p>
<p>通过代码可以得到</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alpha = np.arctan(1160 / 1000)</span><br><span class="line"></span><br><span class="line">d = 1160/ np.sin(alpha)</span><br><span class="line"></span><br><span class="line">v = 1.79/np.cos(alpha)</span><br><span class="line"></span><br><span class="line">t = d/v</span><br><span class="line"></span><br><span class="line">2 * t</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>1117.31843575419</p>
</blockquote>
<p>这不是最短的时间 因此该路径看似不符合直觉但是确实是最短的时间</p>
<h1 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h1><p>调整上述代码中的参数<br>将v1速度改为1.515和1.48</p>
<blockquote>
<p>t1: 83.56 s<br>t2: 71.79 s<br>t3: 334.99 s<br>总时间：980.6787856865337 秒</p>
</blockquote>
<blockquote>
<p>t1: 85.77 s<br>t2: 74.54 s<br>t3: 334.89 s<br>总时间：990.4005321378754 秒</p>
</blockquote>
<p><strong>T对v1敏感</strong></p>
<p>将k的值改为0.011和0.0118</p>
<blockquote>
<p>t1: 84.65 s<br>t2: 73.11 s<br>t3: 334.95 s<br>总时间：985.430963388645 秒</p>
</blockquote>
<p><strong>t对k不敏感</strong></p>
<h1 id="模型拓展"><a href="#模型拓展" class="headerlink" title="模型拓展"></a>模型拓展</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/07/02/005.jpg"
                      alt="photo"
                ></p>
<p>由于问题四中的模型的速度建模思路为：将连续分布所在的江宽等分为若干区间 使得水速在每个区间近似为常数<br>因此在问题四中k是常数 水速是线性的<br>当水速不是线性的时候<br>其定义了v关于y的公式<br>$$<br>v(y) &#x3D;<br>\begin{cases}<br>f_1(y), &amp; 0 \leq y \leq 200 \<br>2.28, &amp; 200 &lt; y &lt; 960 \<br>f_2(y), &amp; 960 \leq y \leq 1160<br>\end{cases}<br>$$</p>
<p>在[0,200]区间中水流满足</p>
<blockquote>
<p>v(0) &#x3D; 0<br>v(200) &#x3D; 2.28</p>
</blockquote>
<p>为了满足此条件 其选择了一个开口向上的抛物线形式<br>解得 k &#x3D; 2.28&#x2F;200^2</p>
<p>由于f1(y)和f2(y)关于江心中心对称<br>在[960,1160]区间同理</p>
<p>选择抛物线函数的原因（论文中未提及 可以添加）<br>$$<br>v(y)\ &#x3D;\ ky^2<br>$$</p>
<p>物理现象水流速度分布 在自然河流中 靠近岸边的地方水流较慢 越靠近江心水流越快 江心处水流速度达到最大值<br>这种分布不是连续且平滑变化的 抛物线是一种最简单的非线性函数 能够很好地模拟这种先慢后快再慢的对称分布趋势</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
</search>
