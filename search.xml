<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/zhihaojiang.github.io/2025/01/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>广州旅游</title>
    <url>/zhihaojiang.github.io/2024/07/31/20240731%E5%B9%BF%E5%B7%9E%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/super-213/hexo-images/blob/main/articles/2024/07/31/2024-05811.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05829.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05837.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05840.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05883.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05884.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05904.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/001.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>嘉兴大学演出</title>
    <url>/zhihaojiang.github.io/2024/10/17/20241017%E5%98%89%E5%85%B4%E5%A4%A7%E5%AD%A6%E6%BC%94%E5%87%BA/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07355.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07363.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07436.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07465.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07470.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07494.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07495.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07496.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语句</title>
    <url>/zhihaojiang.github.io/2025/01/06/20250106MySQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>本位与2025-01-06在CSDN上发布 现将其转移至自己的博客</p>
<h2 id="引擎相关"><a href="#引擎相关" class="headerlink" title="引擎相关"></a>引擎相关</h2><h3 id="查看存储引擎："><a href="#查看存储引擎：" class="headerlink" title="查看存储引擎："></a>查看存储引擎：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure></div>
<h3 id="查看显示支持的存储引擎信息："><a href="#查看显示支持的存储引擎信息：" class="headerlink" title="查看显示支持的存储引擎信息："></a>查看显示支持的存储引擎信息：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;have%&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="查看默认的存储引擎："><a href="#查看默认的存储引擎：" class="headerlink" title="查看默认的存储引擎："></a>查看默认的存储引擎：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;storage_engine&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数据库相关操作-增-删-改"><a href="#数据库相关操作-增-删-改" class="headerlink" title="数据库相关操作(增 删 改)"></a>数据库相关操作(增 删 改)</h2><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create datbase [<span class="keyword">if</span> not exists] db_name</span><br><span class="line">[[DEFAULT] CHARACTER SET charset_name]</span><br><span class="line">[[DEFALUT] COLLATE collation_name]</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>“[ ]”中的是可选项 可写可不写<br>将db_name替换成你想给数据库取的名字</p>

    </div>
  </div>

<h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></div>

<h3 id="查看数据库的详细信息"><a href="#查看数据库的详细信息" class="headerlink" title="查看数据库的详细信息"></a>查看数据库的详细信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show create database db_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用某个数据库"><a href="#使用某个数据库" class="headerlink" title="使用某个数据库"></a>使用某个数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">use db_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter database [db_name]</span><br><span class="line">[DEFAULT CHARACTER SET charset_name]| [[DEFAULT]COLLATE collation_name]</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>例1：将schoolDB的编码方式有GBK修改为UTF8。</p>
<p>法1:ALTER DATABASE schoolDB CHARACTER SET UTF8;</p>
<p>法2:ALTER DATABASE schoolDB collate utf8_general_ci;</p>

    </div>
  </div>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop database [<span class="keyword">if</span> exists] db_name;</span><br></pre></td></tr></table></figure></div>
<h2 id="表的相关操作（增删改查）"><a href="#表的相关操作（增删改查）" class="headerlink" title="表的相关操作（增删改查）"></a>表的相关操作（增删改查）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table [<span class="keyword">if</span> exists] t_name(</span><br><span class="line">    name_1 int [primary key],</span><br><span class="line">    name_2 varchar(10)[...],</span><br><span class="line">    name_3 <span class="built_in">float</span>(5, 3)[...]</span><br><span class="line">)[engine = INNODB charset = UTF-8];</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>这里t_name是表名</p>
<p>name_1 name_2 name_3 是字段名</p>
<p>字段名后面[ ]中的是完整性约束(可选填)</p>
<p> 完整性约束条件：<br> PRIMARY KEY主键（唯一来标识的，每一个表都一个，自动非空）<br> AUTO_INCREMENT自增长<br> FOREIGN KEY外键<br> NOT NULL非空<br> UNIQUE KEY唯一<br> DEFAULT默认值<br>最下面的[ ] 中的是引擎和编码方式的选择</p>

    </div>
  </div>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="在name-3的（前面-后面）-增加新列name-4"><a href="#在name-3的（前面-后面）-增加新列name-4" class="headerlink" title="[在name_3的（前面|后面）] 增加新列name_4"></a>[在name_3的（前面|后面）] 增加新列name_4</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    add name_4 [first|after name_3];</span><br></pre></td></tr></table></figure></div>

<h4 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h4><p>将name_2的数据类型修改成float(4,3)</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    modify name_2 <span class="built_in">float</span>(4,3)</span><br></pre></td></tr></table></figure></div>

<h4 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h4><p>将表t_name中的name_1列的名字修改成new_name_1</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    change name_1 new_name_1;</span><br></pre></td></tr></table></figure></div>

<h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><p>将表t_name的名字修改成new_t_name</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    rename [to] new_t_name;</span><br></pre></td></tr></table></figure></div>

<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p>将表t_name中的name_1列删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">drop column name_1；</span><br></pre></td></tr></table></figure></div>

<h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">delete from t_name</span><br><span class="line"><span class="built_in">where</span> 条件表达式；</span><br></pre></td></tr></table></figure></div>

<h4 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h4><p>将表t_name的存储引擎修改成INNODB</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    engine = INNODB;</span><br></pre></td></tr></table></figure></div>

<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><p>查看表名</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></div>

<p>查看表的结构</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#法1</span></span><br><span class="line">show create table t_name；</span><br><span class="line"> </span><br><span class="line"><span class="comment">#法2</span></span><br><span class="line">describe t_name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#法3</span></span><br><span class="line">desc t_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table [<span class="keyword">if</span> not existe] t_name</span><br><span class="line">[like t_name_2]</span><br><span class="line">[as 表信息]</span><br><span class="line"> </span><br><span class="line"><span class="comment">#like可以复制表的结构 表中的信息不会被复制 复制出来的是个空表</span></span><br><span class="line"><span class="comment">#as 可以复制表中的信息 相当于CV大法</span></span><br></pre></td></tr></table></figure></div>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>将表t_name删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop table t_name；</span><br></pre></td></tr></table></figure></div>

<h2 id="数据相关操作"><a href="#数据相关操作" class="headerlink" title="数据相关操作"></a>数据相关操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">insert [into]</span><br><span class="line">    t_name(name_1, name_2, name_3)</span><br><span class="line">    values(12,<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;2025-01-04&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="查看插入信息"><a href="#查看插入信息" class="headerlink" title="查看插入信息"></a>查看插入信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from t_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">update t_name</span><br><span class="line"><span class="built_in">set</span> name_1 = x,</span><br><span class="line">    name_2 = y,</span><br><span class="line">    name_3 = z</span><br><span class="line">[<span class="built_in">where</span> 条件表达式];</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>若where不写<br>则更新全部记录</p>

    </div>
  </div>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">delate from t_name</span><br><span class="line">[<span class="built_in">where</span> 条件表达式];</span><br></pre></td></tr></table></figure></div>

<p>完全清除某个表<br>完全清除表t_name：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">truncate</span> [table] t_name;</span><br></pre></td></tr></table></figure></div>

<h2 id="单表查询（重点）"><a href="#单表查询（重点）" class="headerlink" title="单表查询（重点）"></a>单表查询（重点）</h2><p>先给出语法：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [distinct] name_1 [as new_name],</span><br><span class="line">       [distinct] name_2 [as new_name],</span><br><span class="line">from t_name</span><br><span class="line">[<span class="built_in">where</span> 条件表达式,]</span><br><span class="line">[group by name [ASC|DESC],]</span><br><span class="line">[order by name [ASC|DESC],]</span><br><span class="line">[<span class="built_in">limit</span> 条数]；</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>SELECT子句：<br>指定要查询的列名称，列与列之间用逗号隔开。<br>还可以为列指定新的别名，显示在输出的结果中。<br>ALL关键字表示显示所有的行，包括重复行，是系统默认的<br>DISTINCT表示显示的结果要消除重复的行。<br>FROM子句：指定要查询的表，可以指定两个以上的表，表与表之间用逗号隔开。<br>WHERE子句：指定要查询的条件。<br>如果有WHERE子句，就按照“条件表达式”指定的条件进行查询；<br>如果没有WHERE子句，就查询所有记录。</p>
<p>GROUP BY ：<br>子句用于对查询结构进行分组。<br>按照“列名1”指定的字段进行分组；<br>如果GROUP BY子句后带着HAVING关键字，那么只有满足“条件表达式2”中指定的条件的才能够输出。<br>GROUP BY子句通常和COUNT()、SUM()等聚合函数一起使用。</p>
<p>HAVING子句：<br>指定分组的条件，通常放Group by字句之后</p>
<p>ORDER BY子句：用于对查询结果的进行排序。<br>排序方式由ASC和DESC两个参数指出；<br>ASC参数表示按升序进行排序。默认情况下是ASC。<br>DESC参数表示按降序的顺序进行排序。升序表示值按从小到大的顺序排列。</p>
<p>LIMIT 子句：限制查询的输出结果的行数。</p>

    </div>
  </div>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>等值连接</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> x_name_1,</span><br><span class="line">       y_name_2</span><br><span class="line">from t_x </span><br><span class="line">inner <span class="built_in">join</span> t_y on t_x.id = t_y.id</span><br><span class="line"><span class="built_in">where</span>...;</span><br></pre></td></tr></table></figure></div>
<p>左连接、右连接和联合查询不过多赘述</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>带in关键词的子查询</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">from t_name_1</span><br><span class="line"><span class="built_in">where</span> name_1 <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> name_2 from t_name_2</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>带比较运算符的子查询</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">from t_name_1</span><br><span class="line"><span class="built_in">where</span> name = (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">id</span></span><br><span class="line">    from t_name_2</span><br><span class="line">    <span class="built_in">where</span> <span class="built_in">id</span> = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>引:<br>    面试题：select id,name,age from sd where name&#x3D;’张飞’<br>    怎么优化？最佳方案是什么？<br>    答：在name上创建索引：<br>    create index in name on sd(name);</p>
<h3 id="语法（已存在的表）："><a href="#语法（已存在的表）：" class="headerlink" title="语法（已存在的表）："></a>语法（已存在的表）：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create index in_id</span><br><span class="line">on t_name(<span class="built_in">id</span>);</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>in_id:索引名 （自己取）<br>t_name:表名<br>id:列名</p>

    </div>
  </div>

<h3 id="在创建表的时候创建索引"><a href="#在创建表的时候创建索引" class="headerlink" title="在创建表的时候创建索引"></a>在创建表的时候创建索引</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table t_name(</span><br><span class="line">...</span><br><span class="line">[unique|fulltext|spatial] index|key [in_id](name[长度])[ASC|DESC]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create view view_name as</span><br><span class="line"><span class="comment">#查询语句:</span></span><br><span class="line"><span class="keyword">select</span>...</span><br><span class="line">[with [cascaded|<span class="built_in">local</span>] check option];</span><br></pre></td></tr></table></figure></div>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop view view_name;</span><br></pre></td></tr></table></figure></div>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create user <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identifiednby <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from mysql.user;</span><br></pre></td></tr></table></figure></div>

<h3 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grant 权限 on 库.表 to <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#触发器设置</span></span><br><span class="line">CREATE TRIGGER before_position_update</span><br><span class="line">BEFORE UPDATE ON staff</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    IF OLD.position != NEW.position THEN</span><br><span class="line">        CASE NEW.position</span><br><span class="line">            WHEN <span class="string">&#x27;董事长&#x27;</span> THEN</span><br><span class="line">                SET NEW.role = 9;</span><br><span class="line">            WHEN <span class="string">&#x27;经理&#x27;</span> THEN</span><br><span class="line">                SET NEW.role = 6;</span><br><span class="line">            ELSE</span><br><span class="line">                SET NEW.role = 2;</span><br><span class="line">        END CASE;</span><br><span class="line">    END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>这里是当position设置为经理或董事长时 自动更改权限等级</p>

    </div>
  </div>

<h3 id="显示设置的触发器"><a href="#显示设置的触发器" class="headerlink" title="显示设置的触发器"></a>显示设置的触发器</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示设置的触发器</span></span><br><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure></div>

<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>备份数据库到文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p db_name &gt; backup.sql</span><br></pre></td></tr></table></figure></div>

<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>从文件恢复数据库。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u username -p db_name &lt; backup.sql</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>澳洲旅游</title>
    <url>/zhihaojiang.github.io/2025/01/25/20250125%E6%BE%B3%E6%B4%B2%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09682.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09718.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09763.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09941.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09945.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09946.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09958.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09967.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习作业笔记</title>
    <url>/zhihaojiang.github.io/2025/03/28/20250328%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>我们需要利用回归分析预测世界大学综合得分</p>
<p>#Jupyter notebook代码<br>基本库导入</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line">from sklearn.metrics import mean_squared_error,r2_score</span><br><span class="line">from scipy import stats</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.metrics import root_mean_squared_error</span><br><span class="line">from sklearn import linear_model</span><br><span class="line">from sklearn import metrics</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university = pd.read_csv(<span class="string">&#x27;cwurData.csv&#x27;</span>)</span><br><span class="line">university.head()</span><br></pre></td></tr></table></figure></div>
<p>此时可能会出现报错</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>报错信息</p>

    </div>
    <div class="notel-content">
      <p>File parsers.pyx:574, in pandas._libs.parsers.TextReader.<strong>cinit</strong>()</p>
<p>File parsers.pyx:663, in pandas._libs.parsers.TextReader._get_header()</p>
<p>File parsers.pyx:874, in pandas._libs.parsers.TextReader._tokenize_rows()</p>
<p>File parsers.pyx:891, in pandas._libs.parsers.TextReader._check_tokenize_status()</p>
<p>File parsers.pyx:2053, in pandas._libs.parsers.raise_parser_error()</p>
<p>File <frozen codecs>:322, in decode(self, input, final)</p>
<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode bytes in position 3864-3865: invalid continuation byte</p>

    </div>
  </div>
<p>不用担心，这是因为pd.read_csv()在不指明encoding时默认使用utf-8编码<br>这段报错是因为该文件不是使用utf-8进行编码。<br>我们可以写一段代码判断文件的编码格式</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import chardet</span><br><span class="line"></span><br><span class="line">with open(<span class="string">&#x27;cwurData.csv&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) as f:</span><br><span class="line">    university = f.read()</span><br><span class="line">    encoding = chardet.detect(university)</span><br><span class="line">    <span class="built_in">print</span>(encoding)</span><br></pre></td></tr></table></figure></div>
<p>之后将其输出的encoding写入pd.read_csv()即可</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university = pd.read_csv(<span class="string">&#x27;cwurData.csv&#x27;</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">university.head()</span><br></pre></td></tr></table></figure></div>
<p>输出结果为<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/001.png"
                      alt="photo"
                ><br>通过该数据可知其数字应该是越小越好<br>因此相关性应该是负数 且越小越好</p>
<p>之后我们查看文件的维度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university.shape</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:(2200, 14)<br>说明该文件总共有2200行数据，14个特征</p>
<p>接下来我们分析下文件是否有异常</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university.describe()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/002.png"
                      alt="photo"
                ><br>从第一行(count)看到 broad_impact数据与其他数据不同<br>上述从head()函数我猜测broad_impact列全是NA<br>仔细查看文件后可知:2012年和2013年的broad_impact存在缺失<br>其他数据看起来没什么问题 数据质量基本完整</p>
<p>先用相关性矩阵看看各个数据之间的关系</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = university[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">X = university.drop([<span class="string">&quot;score&quot;</span>,<span class="string">&quot;institution&quot;</span>,<span class="string">&quot;country&quot;</span>, <span class="string">&quot;year&quot;</span>,<span class="string">&quot;broad_impact&quot;</span>],axis=1)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">correlation_matrix = pd.concat([X_train, y_train], axis=1).corr()</span><br><span class="line"></span><br><span class="line">sns.heatmap(correlation_matrix, annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/003.png"
                      alt="photo"
                ><br>通过上图可以看到world_rank与publications、influence、citations有强相关性<br>我们用matplotlib.pyplot库做出这些图</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;publications&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;publications&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/004.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;influence&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;influence&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/005.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;citations&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;citations&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/006.png"
                      alt="photo"
                ></p>
<p>从上述三幅图可以看到world_rank与publications、influence有强相关性<br>world_rank与citations也有一定的相关性 但不是很明显<br>再继续做几张图看看其他数据之间的关系怎么样</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;publications&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;influence&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;influence&amp;publications&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/007.png"
                      alt="photo"
                ><br>从图中可以看出点近似集中在一条直线上<br>说明出版物与影响力成正比</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;broad_impact&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;score&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;score&amp;broad_impact&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/008.png"
                      alt="photo"
                ><br>从图中可以看出broad_impact与score成非线性关系 broad_impact的大小与score无关<br><br>用相关性进行检测</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;broad_impact&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;score&quot;</span>]</span><br><span class="line">correlation = x.corr(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r:&quot;</span>, correlation)</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:r: -0.5315904271503679</p>
<p>呈现负相关 因此确定 broad_impact的大小与score无关<br>并且broad_impact中存在缺失值<br>缺失值的处理一般会使用用众数填充、前或后一个数填充、删除缺失列来处理<br>这里broad_impact的大小与score无关<br>因此可以将此列删去<br>同时也可以降低维度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = university[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">X = university.drop([<span class="string">&quot;score&quot;</span>,<span class="string">&quot;institution&quot;</span>,<span class="string">&quot;country&quot;</span>, <span class="string">&quot;year&quot;</span>,<span class="string">&quot;broad_impact&quot;</span>],axis=1)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">lr.intercept_</span><br><span class="line"></span><br><span class="line">coefs_lr = pd.Series(lr.coef_).round()</span><br><span class="line">coefs_lr.index = X_train.columns</span><br><span class="line">coefs_lr</span><br></pre></td></tr></table></figure></div>

<p>其结果为:<br>63.60601390140695</p>
<p>world_rank              0.0<br>national_rank          -0.0<br>quality_of_education   -0.0<br>alumni_employment      -0.0<br>quality_of_faculty     -0.0<br>publications           -0.0<br>influence              -0.0<br>citations              -0.0<br>patents                -0.0<br>dtype: float64</p>
<p>说明模型拟合得不好<br>查看其均方根误差和决定系数</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lr_train_pred = lr.predict(X_train)</span><br><span class="line">lr_test_pred = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;训练集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(lr_train_pred,y_train), r2_score(lr_train_pred,y_train))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;测试集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(lr_test_pred,y_test), r2_score(lr_test_pred,y_test))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>训练集上的均方根误差和决定系数分别为: 5.441831802594455 0.079429595738992<br>测试集上的均方根误差和决定系数分别为: 5.369301125131177 0.06344204755145388</p>
<p>上述系数过小可能是数值之间差别过大导致拟合得不好<br>将其进行标准化</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train_scaled, y_train)</span><br><span class="line">coefs_lr = pd.Series(lr.coef_).round()</span><br><span class="line">coefs_lr.index = X_train.columns</span><br><span class="line">coefs_lr</span><br><span class="line"></span><br><span class="line">lr.intercept_</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>world_rank              0.0<br>national_rank          -0.0<br>quality_of_education   -0.0<br>alumni_employment      -1.0<br>quality_of_faculty     -4.0<br>publications           -0.0<br>influence              -0.0<br>citations              -0.0<br>patents                -0.0<br>dtype: float64</p>
<p>47.83457386363636</p>
<p>模型得到的结果很低 说明拟合得不好<br>更换其他线性回归模型试试</p>
<div class="tabs" id="tab-线性回归模型"><ul class="nav-tabs"><li class="tab active"><a class="#线性回归模型-1">岭回归</a></li><li class="tab"><a class="#线性回归模型-2">lasso回归</a></li><li class="tab"><a class="#线性回归模型-3">弹性网回归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="线性回归模型-1"><p><strong>岭回归</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ridge= linear_model.Ridge(alpha=0.05)</span><br><span class="line">ridge.fit(X_train,y_train)</span><br><span class="line">Y_hat = ridge.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>, ridge.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, ridge.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p> 输出结果为:<br> 截距为： 63.60601382257282<br>回归系数为： [ 0.00116895 -0.00608447 -0.00380894 -0.00592045 -0.06344228 -0.00045937<br> -0.0009899  -0.00046924 -0.00164281]<br> RMSE: 5.369301120766853</p></div><div class="tab-pane" id="线性回归模型-2"><p><strong>lasso回归</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lasso= linear_model.Lasso(alpha=0.05)</span><br><span class="line">lasso.fit(X_train,y_train)</span><br><span class="line">Y_hat=lasso.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>,lasso.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, lasso.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>截距为： 63.602800047243974<br>回归系数为： [ 0.00115484 -0.00606551 -0.00381082 -0.00591616 -0.06342471 -0.00045677<br> -0.00098495 -0.00046729 -0.00164163]<br> RMSE: 5.369181579518303</p></div><div class="tab-pane" id="线性回归模型-3"><p><strong>弹性网回归</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">elastic= linear_model.ElasticNet(alpha=0.1,l1_ratio=0.4)</span><br><span class="line">elastic.fit(X_train,y_train)</span><br><span class="line">y_hat = elastic.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>,elastic.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, elastic.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>截距为： 63.60327653271375<br>回归系数为： [ 0.00115777 -0.0060693  -0.00381124 -0.00591707 -0.06342543 -0.00045734<br> -0.00098603 -0.00046779 -0.00164194]<br> RMSE: 5.369181579518303</p></div></div></div>

<p>可以看到这些回归得到的结果都不好<br>说明这个不是呈线性关系</p>
<p>我们使用随机森林进行尝试</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rf = RandomForestRegressor()</span><br><span class="line">rf.fit(X_train, y_train)</span><br><span class="line">rf_train_pred = rf.predict(X_train)</span><br><span class="line">rf_test_pred = rf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;训练集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(rf_train_pred,y_train), r2_score(rf_train_pred,y_train))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;测试集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(rf_test_pred,y_test), r2_score(rf_test_pred,y_test))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>训练集上的均方根误差和决定系数分别为: 0.396126717281446 0.9974538720434839<br>测试集上的均方根误差和决定系数分别为: 1.0185613846393418 0.9808937922886296</p>
<p>可以看到 决定系数为0.99 0.98以上 说明模型拟合得很好</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>连续特征离散化的处理方法及其python实现</title>
    <url>/zhihaojiang.github.io/2025/03/29/20250329%E8%BF%9E%E7%BB%AD%E7%89%B9%E5%BE%81%E7%A6%BB%E6%95%A3%E5%8C%96%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="等距离散法"><a href="#等距离散法" class="headerlink" title="等距离散法"></a>等距离散法</h2><p>将连续数据的范围划分为几个宽度相等的区间。每个区间内的数值都有相同的范围。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分为 5 个等宽区间</span></span><br><span class="line">bins = pd.cut(data, bins=5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分箱结果</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="等频离散法"><a href="#等频离散法" class="headerlink" title="等频离散法"></a>等频离散法</h2><p>将数据分成几个区间，使得每个区间内的数据量相同。这样可以避免某些区间的数据过于集中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分为 5 个等频区间</span></span><br><span class="line">bins = pd.qcut(data, q=5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分箱结果</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="K-means-模型离散法"><a href="#K-means-模型离散法" class="headerlink" title="K-means 模型离散法"></a>K-means 模型离散法</h2><p>先从样本集中随机选取 k个样本作为簇中心，并计算所有样本与这 k个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.cluster import KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000).reshape(-1, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 K-means 聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=5)</span><br><span class="line">labels = kmeans.fit_predict(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看聚类标签</span></span><br><span class="line"><span class="built_in">print</span>(pd.Series(labels).value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="基于决策树的离散化"><a href="#基于决策树的离散化" class="headerlink" title="基于决策树的离散化"></a>基于决策树的离散化</h2><p>基于决策树的方法利用决策树的分割规则进行离散化，将连续特征分割成多个区间，通常用于有监督学习中的离散化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line">target = np.random.randint(0, 2, size=1000)  <span class="comment"># 假设目标变量是二分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将连续数据转化为二维数组</span></span><br><span class="line">X = data.reshape(-1, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用决策树进行离散化</span></span><br><span class="line">clf = DecisionTreeClassifier(max_leaf_nodes=5)</span><br><span class="line">clf.fit(X, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每个样本所属的区间</span></span><br><span class="line">labels = clf.apply(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看离散化结果</span></span><br><span class="line"><span class="built_in">print</span>(pd.Series(labels).value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="分位数离散法"><a href="#分位数离散法" class="headerlink" title="分位数离散法"></a>分位数离散法</h2><p>分位数离散化的核心思想是：<br>按照数据的累积分布函数 (CDF) 计算分位点。<br>根据分位数（如四分位数 (quartiles)、十分位数 (deciles)）划分数据，使得每个区间的样本数接近相等。<br>由于基于数据的分布进行划分，适用于非均匀分布的数据。</p>
<p>以下是不同的方法进行实现</p>
<div class="tabs" id="tab-分位数离散法实现方法"><ul class="nav-tabs"><li class="tab active"><a class="#分位数离散法实现方法-1">方法一</a></li><li class="tab"><a class="#分位数离散法实现方法-2">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="分位数离散法实现方法-1"><p><strong>使用pandas.qcut()</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 1000 个随机数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 qcut 进行分位数离散化（四分位）</span></span><br><span class="line">bins = pd.qcut(data, q=4, labels=[<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个分箱的数据量</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="分位数离散法实现方法-2"><p><strong>使用numpy.percentile()</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 1000 个随机数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 10 分位数（十分位数）</span></span><br><span class="line">percentiles = np.percentile(data, q=[10, 20, 30, 40, 50, 60, 70, 80, 90])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 np.digitize 进行分箱</span></span><br><span class="line">bins = np.digitize(data, percentiles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个分箱的数据量</span></span><br><span class="line"><span class="built_in">print</span>(np.bincount(bins))</span><br></pre></td></tr></table></figure></div></div></div></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>分位数离散化的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>适用于非均匀分布数据，相比于等宽离散化更合理。<br>避免某些区间数据过多或过少，能够更好地均衡数据。<br>能够减少异常值的影响，因为分箱是基于数据分布，而不是固定范围。</p>
<p>❌ 缺点<br>对极端值敏感，如果数据中有极端值，可能会影响分位数计算结果。<br>区间边界难以解释，不像等宽分箱那样有固定的区间宽度。<br>对新数据可能需要重新计算分位点，导致难以适用于流式数据。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用分位数离散化？</p>

    </div>
    <div class="notel-content">
      <p>数据分布不均匀（例如数据集中在某些范围）。<br>避免某些区间样本过多或过少，如在决策树、统计建模等场景中使用。<br>希望减少异常值的影响，避免极端值导致不均匀的划分。</p>

    </div>
  </div>

<h2 id="基于卡方分裂的离散法"><a href="#基于卡方分裂的离散法" class="headerlink" title="基于卡方分裂的离散法"></a>基于卡方分裂的离散法</h2><p>该分裂算法是把整个属性的取值区间当做一个离散的属性值，然后对该区间进行划分，一般是一分为二，即把一个区间分为两个相邻的区间，每个区间对应一个离散的属性值，该划分可以一直进行下去，直到满足某种停止条件，其关键是划分点的选取。</p>
<p><strong>方法一</strong><br><strong>手动实现</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy.stats import chi2_contingency</span><br><span class="line"></span><br><span class="line">def chi2_value(freq_table):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;计算卡方值&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    chi2, p, _, _ = chi2_contingency(freq_table)</span><br><span class="line">    <span class="built_in">return</span> chi2</span><br><span class="line"></span><br><span class="line">def chimerge(data, target, max_bins=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    基于卡方分裂的离散化方法（ChiMerge）</span></span><br><span class="line"><span class="string">    :param data: 连续特征（NumPy 数组或 Pandas Series）</span></span><br><span class="line"><span class="string">    :param target: 目标变量（分类变量）</span></span><br><span class="line"><span class="string">    :param max_bins: 期望的最大分箱数</span></span><br><span class="line"><span class="string">    :return: 分箱边界</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">df</span> = pd.DataFrame(&#123;<span class="string">&#x27;feature&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;)</span><br><span class="line">    <span class="built_in">df</span> = df.sort_values(by=<span class="string">&#x27;feature&#x27;</span>).reset_index(drop=True)  <span class="comment"># 按特征值排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每个特征值下的类别频次</span></span><br><span class="line">    freq_table = df.groupby(<span class="string">&#x27;feature&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].value_counts().unstack().fillna(0)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始边界（每个值单独作为一个区间）</span></span><br><span class="line">    bins = list(freq_table.index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(bins) &gt; max_bins:  <span class="comment"># 直到达到最大分箱数</span></span><br><span class="line">        min_chi2 = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        min_index = -1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有相邻区间，找到卡方值最小的区间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bins) - 1):</span><br><span class="line">            merged_table = freq_table.loc[[bins[i], bins[i + 1]]].<span class="built_in">sum</span>(axis=0).values.reshape(2, -1)</span><br><span class="line">            chi2 = chi2_value(merged_table)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> chi2 &lt; min_chi2:  <span class="comment"># 找到最小的卡方值</span></span><br><span class="line">                min_chi2 = chi2</span><br><span class="line">                min_index = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并卡方值最小的区间</span></span><br><span class="line">        bins[min_index] = (bins[min_index] + bins[min_index + 1]) / 2</span><br><span class="line">        bins.pop(min_index + 1)  <span class="comment"># 删除合并的区间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50  <span class="comment"># 生成随机数</span></span><br><span class="line">target = np.random.choice([0, 1], size=100)  <span class="comment"># 二分类目标变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分箱边界</span></span><br><span class="line">bin_edges = chimerge(data, target, max_bins=4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方分裂后的分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二</strong><br><strong>使用optbinning库</strong></p>
<p>如果不想手动实现，可以使用 optbinning 库，它可以进行最优分箱（Optimal Binning），内部使用 ChiMerge 或者 Decision Tree 进行离散化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from optbinning import OptimalBinning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50</span><br><span class="line">target = np.random.choice([0, 1], size=100)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 OptimalBinning 进行卡方离散化</span></span><br><span class="line">optb = OptimalBinning(name=<span class="string">&quot;feature&quot;</span>, dtype=<span class="string">&quot;numerical&quot;</span>, solver=<span class="string">&quot;cp&quot;</span>)</span><br><span class="line">optb.fit(data, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取分箱边界</span></span><br><span class="line">bin_edges = optb.splits</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;自动计算的分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>ChiMerge的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>保持类别信息：确保离散化后不同类别仍然可以区分，提高模型效果。<br>自动确定最优分箱：基于卡方值合并区间，减少信息损失。<br>避免过度离散化：不像等宽分箱或等频分箱可能导致信息丢失。</p>
<p>❌ 缺点<br>计算量较大：随着样本数增加，计算卡方统计量的复杂度会增加。<br>依赖类别变量：只能用于分类任务，如果目标变量是连续值，需要先离散化。<br>需要调整超参数：最大分箱数 max_bins 需要根据数据调优。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用ChiMerge</p>

    </div>
    <div class="notel-content">
      <p>分类任务：目标变量是离散类别（如二分类、多分类）。<br>决策树模型：离散化后可以提升决策树模型的可解释性。<br>数据量较大：对于大规模数据，可通过 optbinning 等库加速处理。</p>

    </div>
  </div>

<p>ChiMerge 离散化适用于分类任务，可以在决策树、朴素贝叶斯等模型中提升效果。对于回归任务，可以考虑 KMeans 或 等宽&#x2F;等频分箱。</p>
<h2 id="1R离散法"><a href="#1R离散法" class="headerlink" title="1R离散法"></a>1R离散法</h2><p>1R 就是 1-rule，称为1 规则，也就是产生一层的决策树，用一个规则集的形式，只在某个特定的属性上进行测试。1R是一个简单廉价的方法，但却常常能得到令人吃惊的准确率。<br>它的核心思想是：<br>将连续特征划分为多个区间，然后<br>寻找能够最好地预测目标变量（类别）的区间划分。</p>
<p>1R 方法的基本步骤如下：<br>对特征值排序。<br>尝试不同的分箱方法（等宽、等频、信息增益等），并计算分类错误率。<br>选择错误率最低的分箱方式作为最终的离散化方式。</p>
<p><strong>方法一</strong><br><strong>手动实现</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">def one_r_discretization(data, target, max_bins=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    基于 1R 规则的离散化方法</span></span><br><span class="line"><span class="string">    :param data: 连续特征 (NumPy 数组或 Pandas Series)</span></span><br><span class="line"><span class="string">    :param target: 目标变量 (分类变量)</span></span><br><span class="line"><span class="string">    :param max_bins: 期望的最大分箱数</span></span><br><span class="line"><span class="string">    :return: 最优分箱边界</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">df</span> = pd.DataFrame(&#123;<span class="string">&#x27;feature&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;)</span><br><span class="line">    <span class="built_in">df</span> = df.sort_values(by=<span class="string">&#x27;feature&#x27;</span>).reset_index(drop=True)  <span class="comment"># 按特征值排序</span></span><br><span class="line"></span><br><span class="line">    best_bins = None</span><br><span class="line">    best_error = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试不同分箱方式</span></span><br><span class="line">    <span class="keyword">for</span> bins <span class="keyword">in</span> range(2, max_bins + 1):</span><br><span class="line">        <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>] = pd.cut(<span class="built_in">df</span>[<span class="string">&#x27;feature&#x27;</span>], bins=bins, labels=False)  <span class="comment"># 进行分箱</span></span><br><span class="line">        bin_stats = df.groupby(<span class="string">&#x27;bin&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].agg(lambda x: x.value_counts().index[0])  <span class="comment"># 每个分箱内占比最高的类别</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算错误率</span></span><br><span class="line">        <span class="built_in">df</span>[<span class="string">&#x27;pred&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>].map(bin_stats)</span><br><span class="line">        error_rate = (<span class="built_in">df</span>[<span class="string">&#x27;pred&#x27;</span>] != <span class="built_in">df</span>[<span class="string">&#x27;target&#x27;</span>]).mean()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择错误率最低的分箱方案</span></span><br><span class="line">        <span class="keyword">if</span> error_rate &lt; best_error:</span><br><span class="line">            best_error = error_rate</span><br><span class="line">            best_bins = <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> best_bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50  <span class="comment"># 生成随机数</span></span><br><span class="line">target = np.random.choice([0, 1], size=100)  <span class="comment"># 目标变量（0 或 1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分箱边界</span></span><br><span class="line">bin_edges = one_r_discretization(data, target, max_bins=4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1R 规则下的最佳分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二</strong><br><strong>使用KBinsDiscretizer</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import KBinsDiscretizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">data = data.reshape(-1, 1)  <span class="comment"># 需要转换为 2D 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用监督式分箱</span></span><br><span class="line">discretizer = KBinsDiscretizer(n_bins=4, encode=<span class="string">&#x27;ordinal&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">binned_data = discretizer.fit_transform(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1R 近似分箱结果:&quot;</span>, np.unique(binned_data))</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>1R方法的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>监督式分箱：保留目标变量信息，减少信息损失。<br>简单易懂：规则明确，适合初步数据探索。<br>适用于分类任务：尤其适用于决策树、朴素贝叶斯等分类模型。</p>
<p>❌ 缺点<br>计算复杂度较高：需要尝试多个分箱方案，计算错误率。<br>可能过拟合：如果 max_bins 过大，可能导致分箱过多，导致模型过拟合。<br>仅适用于分类任务：如果目标变量是连续值，需要先进行离散化。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用1R离散化？</p>

    </div>
    <div class="notel-content">
      <p>分类任务（目标变量是离散类别，如 0&#x2F;1 或 A&#x2F;B&#x2F;C）。<br>数据探索：快速找到能够划分类别的最优分箱方式。<br>决策树建模：如 CART、ID3、C4.5 等模型。</p>

    </div>
  </div>

<h2 id="二值化离散法"><a href="#二值化离散法" class="headerlink" title="二值化离散法"></a>二值化离散法</h2><p>二值化离散法是一种简单且常用的离散化方法，它的基本思想是 将连续变量转换为两个类别（0 和 1），即：<br>小于某个阈值的设为 0<br>大于等于某个阈值的设为 1</p>
<p>这种方法特别适用于需要转换成 布尔值（Boolean） 的场景，如 信用评分、风险预测 或 神经网络中的二元特征输入。</p>
<p><strong>方法一</strong><br><strong>手动二值化</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(10) * 10 + 50  <span class="comment"># 生成 10 个均值为 50 的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定阈值（如50）</span></span><br><span class="line">threshold = 50</span><br><span class="line">binarized_data_fixed = (data &gt;= threshold).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值二值化</span></span><br><span class="line">threshold_mean = np.mean(data)</span><br><span class="line">binarized_data_mean = (data &gt;= threshold_mean).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中位数二值化</span></span><br><span class="line">threshold_median = np.median(data)</span><br><span class="line">binarized_data_median = (data &gt;= threshold_median).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 75% 分位数二值化</span></span><br><span class="line">threshold_percentile = np.percentile(data, 75)</span><br><span class="line">binarized_data_percentile = (data &gt;= threshold_percentile).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;Original Data&#x27;</span>: data,</span><br><span class="line">    <span class="string">&#x27;Fixed Threshold&#x27;</span>: binarized_data_fixed,</span><br><span class="line">    <span class="string">&#x27;Mean Threshold&#x27;</span>: binarized_data_mean,</span><br><span class="line">    <span class="string">&#x27;Median Threshold&#x27;</span>: binarized_data_median,</span><br><span class="line">    <span class="string">&#x27;Percentile Threshold&#x27;</span>: binarized_data_percentile</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>
<p><strong>方法二</strong><br><strong>使用 sklearn 进行二值化</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import Binarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定固定阈值</span></span><br><span class="line">binarizer = Binarizer(threshold=50)  <span class="comment"># 以50为阈值</span></span><br><span class="line">binarized_data = binarizer.fit_transform(data.reshape(-1, 1))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二值化后的数据:\n&quot;</span>, binarized_data.flatten())</span><br></pre></td></tr></table></figure></div>

<p><strong>方法三</strong><br><strong>监督式二值化（基于决策树）</strong></p>
<p>如果有分类标签 Y，可以使用决策树来学习最佳的二值化阈值：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设目标变量 Y</span></span><br><span class="line">target = np.random.choice([0, 1], size=len(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练决策树</span></span><br><span class="line">tree = DecisionTreeClassifier(max_depth=1)  <span class="comment"># 只允许一层分裂</span></span><br><span class="line">tree.fit(data.reshape(-1, 1), target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最优的分裂阈值</span></span><br><span class="line">optimal_threshold = tree.tree_.threshold[0]</span><br><span class="line">binarized_data_tree = (data &gt;= optimal_threshold).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;决策树选择的最优二值化阈值: &#123;optimal_threshold&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基于决策树的二值化结果:&quot;</span>, binarized_data_tree)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用二值化？</p>

    </div>
    <div class="notel-content">
      <p>✅ 适用场景<br>逻辑回归或朴素贝叶斯模型（需要布尔特征）。<br>信用评分、欺诈检测（例如：收入是否高于某个值？）。<br>生物信息学（例如：基因表达水平是否超过某个阈值？）。<br>特征筛选（减少噪声，提高模型可解释性）。<br>规则挖掘（如 Apriori 算法）（将数据转换为 0&#x2F;1 格式）。</p>
<p>❌ 不适用场景<br>信息损失严重：如果数据本身具有重要的连续性信息（如温度、房价），二值化可能会损失过多信息。<br>非布尔场景：如果数据有多个类别，建议使用多级离散化（如分箱）。</p>

    </div>
  </div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP介绍及其创建使用</title>
    <url>/zhihaojiang.github.io/2025/03/30/20250330MCP%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MCP是什么"><a href="#MCP是什么" class="headerlink" title="MCP是什么"></a>MCP是什么</h2><p>MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 于 2024 年 11 月推出的一种开放标准协议，旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信方式。​<br><strong>Model Context Protocol (MCP)</strong><br>MCP 是一个标准协议，就像给 AI 大模型装了一个 “万能接口”，让 AI 模型能够与不同的数据源和工具进行无缝交互。它就像 USB-C 接口一样，提供了一种标准化的方法，将 AI 模型连接到各种数据源和工具。<br>MCP 旨在替换碎片化的 Agent 代码集成，从而使 AI 系统更可靠，更有效。通过建立通用标准，服务商可以基于协议来推出它们自己服务的 AI 能力，从而支持开发者更快的构建更强大的 AI 应用。开发者也不需要重复造轮子，通过开源项目可以建立强大的 AI Agent 生态。<br>MCP 的核心概念包括：</p>
<ol>
<li>上下文共享：​应用程序可以通过 MCP 向模型提供所需的上下文信息，如文件内容、数据库记录等，增强模型的理解和生成能力。</li>
<li>工具暴露：​MCP 允许应用程序将功能（如文件读写、API 调用）暴露给模型，模型可以调用这些工具完成复杂任务。​</li>
<li>可组合的工作流：​开发者可以利用 MCP 集成多个服务和组件，构建灵活、可扩展的 AI 工作流。​</li>
<li>安全性：​通过本地服务器运行，MCP 避免将敏感数据上传至第三方平台，确保数据隐私。 ​</li>
</ol>
<p>MCP 的架构主要由以下组件组成：</p>
<ol>
<li>MCP 主机（Host）：​如 Claude Desktop、IDE 或其他 AI 工具，即大模型的应用。​</li>
<li>MCP 客户端（Client）：​在主机应用内的连接器，负责与 MCP 服务器建立连接。​</li>
<li>MCP 服务器（Server）：​实现 MCP 协议的程序，提供特定功能或数据资源，供客户端访问。​</li>
<li>远程服务：​如 Slack、GitHub API 等，MCP 服务器可以连接的外部服务。 ​</li>
</ol>
<p>通过 MCP，AI 模型可以直接与数据源建立标准化的连接，避免了为每个新数据源定制对接方案的繁琐过程，从而实现真正的互联互通。</p>
<p>MCP（Model Context Protocol）允许你定义和暴露自定义的函数（工具），让大模型调用这些工具来完成特定任务。例如，你可以构建一个函数，让模型查询数据库、读取文件、调用 API，甚至执行本地计算。</p>
<h2 id="MCP-让模型调用工具的方式"><a href="#MCP-让模型调用工具的方式" class="headerlink" title="MCP 让模型调用工具的方式"></a>MCP 让模型调用工具的方式</h2><p><strong>定义一个工具（函数）</strong><br>在本地或远程服务器上编写一个 API 或函数，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def get_weather(city):</span><br><span class="line">    <span class="comment"># 这里可以调用真实的天气 API</span></span><br><span class="line">    <span class="built_in">return</span> f<span class="string">&quot;&#123;city&#125; 当前气温 25°C，晴天&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>通过 MCP 暴露该工具</strong><br>通过 MCP 让大模型知道这个工具的存在，并允许它调用。例如，在 Claude 或其他支持 MCP 的环境中，模型可以动态调用你的 get_weather(city) 函数。<br><strong>模型调用工具</strong><br>当用户询问「北京的天气如何？」时，模型可以自动调用 get_weather(“北京”)，并将结果返回给用户，而不是依赖自身训练的数据。</p>
<h2 id="创建并使用的流程"><a href="#创建并使用的流程" class="headerlink" title="创建并使用的流程"></a>创建并使用的流程</h2><p>以get_weather为例<br>我们首先创建一个.py文件叫weather<br>在文件中输入下述代码</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from mcp import MCPServer, tool</span><br><span class="line"></span><br><span class="line">class WeatherServer(MCPServer):</span><br><span class="line">    @tool</span><br><span class="line">    def get_weather(self, city: str) -&gt; str:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取指定城市的天气信息。</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 调用天气 API 获取数据</span></span><br><span class="line">        api_key = <span class="string">&#x27;您的API密钥&#x27;</span></span><br><span class="line">        response = requests.get(f<span class="string">&#x27;http://api.weatherapi.com/v1/current.json?key=&#123;api_key&#125;&amp;q=&#123;city&#125;&amp;lang=zh&#x27;</span>)</span><br><span class="line">        data = response.json()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;error&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">            <span class="built_in">return</span> f<span class="string">&quot;无法获取&#123;city&#125;的天气信息。&quot;</span></span><br><span class="line">        weather = data[<span class="string">&#x27;current&#x27;</span>][<span class="string">&#x27;condition&#x27;</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">        temp_c = data[<span class="string">&#x27;current&#x27;</span>][<span class="string">&#x27;temp_c&#x27;</span>]</span><br><span class="line">        <span class="built_in">return</span> f<span class="string">&quot;&#123;city&#125;当前天气：&#123;weather&#125;，气温：&#123;temp_c&#125;°C。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    server = WeatherServer()</span><br><span class="line">    server.run()</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>记得安装必要的库</p>

    </div>
    <div class="notel-content">
      <p>pip install mcp-server</p>

    </div>
  </div>
<p>这样，MCP工具就做好了</p>
<p>之后，我们要将这个工具告诉AI<br>打开一个支持MCP的AI软件或网站 这里我使用vs code中的cline插件<br>在插件设置中找到MCP Servers -&gt; installed -&gt; Configure MCP Server 点击<br>会进入到一个叫cline_mcp_settings.json的文档<br>里面应该是这样的</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在mcpServers中插入你写的工具</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;weather&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;command&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;--directory&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/Volumes/HIKSEMI/mcp_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;run&quot;</span>,</span><br><span class="line">        <span class="string">&quot;weather.py&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>记得安装必要的库</p>

    </div>
    <div class="notel-content">
      <p>“weather”: { -&gt; 这个是你的MCP工具的名字 可以自己随便取</p>
<p>“command”: “python” -&gt;这个是告诉他使用 python 命令来运行 Python 解释器 启动服务器</p>
<p>“args”: [<br>        “–directory”, -&gt;这个选项通常用来告诉服务器在哪个路径下查找需要的资源 或者在该目录下运行服务器<br>        “&#x2F;Volumes&#x2F;HIKSEMI&#x2F;mcp_server”, -&gt;这是指定你weather.py的路径<br>        “run”, -&gt; 这个是告诉程序去执行接下来的操作 即运行指定的Python脚本<br>        “weather.py” -&gt; 这是要执行的 Python 脚本的名称</p>

    </div>
  </div>

<p>保存好后会在下面看见你的MCP工具已经启用了 在向大模型询问天气时 他会优先查询是否有可用的MCP工具 并按照对应的格式给出答复</p>
]]></content>
      <categories>
        <category>科技</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MCP</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>字母在字符串中的百分比</title>
    <url>/zhihaojiang.github.io/2025/03/31/20250331%E5%AD%97%E6%AF%8D%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “foobar”, letter &#x3D; “o”<br>输出：33<br>解释：<br>等于字母 ‘o’ 的字符在 s 中占到的百分比是 2 &#x2F; 6 * 100% &#x3D; 33% ，向下取整，所以返回 33 。<br>示例 2：</p>
<p>输入：s &#x3D; “jjjj”, letter &#x3D; “k”<br>输出：0<br>解释：<br>等于字母 ‘k’ 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 由小写英文字母组成<br>letter 是一个小写英文字母</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">方法一</a></li><li class="tab"><a class="#first-unique-name-2">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>正常思路</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def percentageLetter(self, s, letter):</span><br><span class="line">        n = len(s)  <span class="comment">#把长度赋值给n</span></span><br><span class="line">        count = 0   <span class="comment">#初始化统计个数变量</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> s: <span class="comment">#从字符串第一个字符开始循环</span></span><br><span class="line">            <span class="keyword">if</span> index == letter: <span class="comment">#如果s的下标index和我们要找的字符letter相同</span></span><br><span class="line">                count += 1  <span class="comment">#+1</span></span><br><span class="line">        <span class="built_in">return</span> 100 * count // n <span class="comment">#个数比总数在乘以100%就得到了其百分比</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-unique-name-2"><p><strong>python库实现</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> class Solution:</span><br><span class="line">    def percentageLetter(self, s: str, letter: str) -&gt; int:</span><br><span class="line">        <span class="built_in">return</span> s.count(letter) * 100 // len(s)  <span class="comment">#主要用到了count()函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#作者：灵茶山艾府</span></span><br><span class="line"><span class="comment">#链接：https://leetcode.cn/problems/percentage-of-letter-in-string/solutions/#1510439/ku-han-shu-mo-ni-by-endlesscheng-fqad/</span></span><br><span class="line"><span class="comment">#来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">#著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure></div></div></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>λ演算</title>
    <url>/zhihaojiang.github.io/2025/04/01/20250401%CE%BB%E6%BC%94%E7%AE%97/</url>
    <content><![CDATA[<p>在B站看到了有人讲解λ演算 很感兴趣 于是去了解了一下<br>原视频：<a class="link"   href="https://www.youtube.com/watch?v=RcVA8Nj6HEo&t=44s" >https://www.youtube.com/watch?v=RcVA8Nj6HEo&amp;t=44s<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>原视频很精彩 图文描述 我也是看了这个视频写的 推荐观看</p>
<h2 id="什么是λ演算"><a href="#什么是λ演算" class="headerlink" title="什么是λ演算"></a>什么是λ演算</h2><p>λ演算（Lambda Calculus）是一种用于研究函数定义、函数应用和递归的数学逻辑系统 由阿隆佐·丘奇（Alonzo Church）在 1930 年代提出。它是计算理论的基础之一 并在编程语言的设计中发挥了重要作用 特别是对函数式编程语言（如 Haskell、Lisp 和 ML）有深远的影响 </p>
<p>诶 这里学过python的人肯定想到了 python中有个lambda表达式 是不是和这个λ演算相关呢<br>没错 Python 中的 lambda 表达式确实与 λ（Lambda）演算有关系 但它只是 λ演算的一个简单应用 并没有完全实现 λ演算的全部概念 这里不过多叙述 只是告诉大家他们之间确实有关系</p>
<h2 id="λ演算的基本概念"><a href="#λ演算的基本概念" class="headerlink" title="λ演算的基本概念"></a>λ演算的基本概念</h2><p>λ演算由三种基本表达式组成：</p>
<ul>
<li>变量：例如 x、y，代表某个值。</li>
<li>λ抽象（Lambda Abstraction）：用于定义匿名函数，例如 λx.x+1 表示“输入 x，返回 x+1”</li>
<li>函数应用（Function Application）：用于调用函数，例如 (λx.x+1) 2，表示将 2 代入 λx.x+1，结果为 3</li>
</ul>
<h3 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h3><p>在λ演算中 主要有三类样式：</p>
<ul>
<li>括号：()</li>
<li>变量：x, y, z…</li>
<li>“λ”和”.”:λ和.总是成对出现</li>
</ul>
<p>这样 我们就有了三个模版：</p>
<ul>
<li>(_ _)</li>
<li>a</li>
<li>(λa._)</li>
</ul>
<p>这里的下划线可以填入上述任意模块 a是一个变量 我们可以像搭积木一样进行构造<br>例如：<br>((λa.y)(λx.(λc.e)))<br>并且 这些变量也可以是一个函数</p>
<h3 id="结合代码理解"><a href="#结合代码理解" class="headerlink" title="结合代码理解"></a>结合代码理解</h3><p>上述的a其实就是一个变量 并且他也可以看成一个函数<br>现在我们重点看看( _ _ ) 和 ( λa._ )</p>
<p>(_ _)可以理解为</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以(ab)为例</span></span><br><span class="line"><span class="comment">#将左边的a看成一个函数</span></span><br><span class="line"><span class="comment">#右边的b就是这个函数a的输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了方便理解 我们定义一个函数 叫a</span></span><br><span class="line">def a(x):</span><br><span class="line">    <span class="built_in">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment">#先别管变量output 右边的a(b)等价于λ演算中的(ab)</span></span><br><span class="line">output = a(b)</span><br></pre></td></tr></table></figure></div>

<p>(λa._)可以理解为</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以(λx.y)为例</span></span><br><span class="line">def fun(x):</span><br><span class="line">    <span class="built_in">return</span> y</span><br></pre></td></tr></table></figure></div>

<p>这些就是λ表达式的内容</p>
<h2 id="λ图"><a href="#λ图" class="headerlink" title="λ图"></a>λ图</h2><p>有很多种可视化λ图</p>
<ol>
<li>Tromp图表：<a class="link"   href="https://tromp.github.io/cl/diagrams.html" >https://tromp.github.io/cl/diagrams.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>David C Keenan的λ演算图形符号：<a class="link"   href="https://dkeenan.com/Lambda/" >https://dkeenan.com/Lambda/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>de Bruijn索引：<a class="link"   href="https://en.wikipedia.org/wiki/De_Bruijn_index" >https://en.wikipedia.org/wiki/De_Bruijn_index<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </li>
<li>Vex（Wayne Citrin，Richard Hall，Benjamin Zorn）：<a class="link"   href="https://www.researchgate.net/publication/2726047_Programming_with_Visual_Expressions" >https://www.researchgate.net/publication/2726047_Programming_with_Visual_Expressions<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </li>
<li>视觉λ演算（Viktor Massalõgin）：<a class="link"   href="https://github.com/bntre/visual-lambda" >https://github.com/bntre/visual-lambda<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
<h2 id="λ演算的计算规则"><a href="#λ演算的计算规则" class="headerlink" title="λ演算的计算规则"></a>λ演算的计算规则</h2><p>λ演算主要有三个计算规则：</p>
<ol>
<li>α-变换（Alpha Conversion）</li>
<li>β-规约（Beta Reduction）</li>
<li>η-变换（Eta Conversion）</li>
</ol>
<h3 id="α-变换（Alpha-Conversion）"><a href="#α-变换（Alpha-Conversion）" class="headerlink" title="α-变换（Alpha Conversion）"></a>α-变换（Alpha Conversion）</h3><p>简单来说就是变量重命名</p>
<blockquote>
<p>λx.x &#x3D; λy.y</p>
</blockquote>
<p>只要不影响表达式的意义 就可以更改变量名称 就像你可以随意地取变量名</p>
<h3 id="β-规约"><a href="#β-规约" class="headerlink" title="β-规约"></a>β-规约</h3><p>函数应用的计算<br>我们来看这样的一个式子：</p>
<blockquote>
<p>((λx.x+2)3)</p>
</blockquote>
<p>根据前文的理解<br>我们逐步进行分析<br>首先来看内层的(λx.x+2)<br>这个意思相当于是 我们定义个一个函数叫x 函数的返回值是x + 2</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#(λx.x+2)</span></span><br><span class="line">def x(x):</span><br><span class="line">    <span class="built_in">return</span> x + 2</span><br></pre></td></tr></table></figure></div>

<p>接下来我们看外层 还记得前面说的</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>引用</p>

    </div>
    <div class="notel-content">
      <p>以(ab)为例<br>将左边的a看成一个函数<br>右边的b就是这个函数a的输入</p>

    </div>
  </div>
<p>现在把刚才的(λx.x+2)看成a 把3看成b</p>
<p>于是 ((λx.x+2)3)就可以用python写成</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def x(x):</span><br><span class="line">    <span class="built_in">return</span> x + 2</span><br><span class="line">    </span><br><span class="line">output = x(3)</span><br></pre></td></tr></table></figure></div>
<p>其用数学符号就是</p>
<blockquote>
<p>3 + 2</p>
</blockquote>
<p>综上 ((λx.x+2)3)等价于 3 + 2</p>
<h3 id="η-变换"><a href="#η-变换" class="headerlink" title="η-变换"></a>η-变换</h3><p>函数等价转换<br>先给出定义</p>
<blockquote>
<p>λx.fx 等价于 f</p>
</blockquote>
<p>只要 f 在所有输入 x 上都保持不变 那么 λx. f x 和 f 是等价的<br>什么意思呢<br>以f(x) &#x3D; x + 3为例</p>
<p>假设有f(x) &#x3D; x + 3<br>在 λ 形式下 他可以表示为</p>
<blockquote>
<p>f &#x3D; λx. x + 1</p>
</blockquote>
<p>那么 λx.fx 等价于 f 即</p>
<blockquote>
<p>λx. (λx. x + 1) x  ≡  λx. x + 1</p>
</blockquote>
<h2 id="自由变量与束缚变量"><a href="#自由变量与束缚变量" class="headerlink" title="自由变量与束缚变量"></a>自由变量与束缚变量</h2><p>定义</p>
<ul>
<li><p>束缚变量（Bound Variable）<br>如果一个变量 x 出现在 λx.M 这样的函数定义中 并且 x 是由 λx 绑定的 则 x 是束缚变量<br>简单理解：变量被 λ 绑定 就称为束缚变量 </p>
</li>
<li><p>自由变量（Free Variable）<br>如果一个变量 x 在 λ 表达式中出现 但没有被任何 λ 绑定 则 x 是自由变量<br>简单理解：变量没有被 λ 绑定 它就是自由变量</p>
</li>
</ul>
<h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">λx. y  // 变量 y 是自由变量</span><br></pre></td></tr></table></figure></div>

<h3 id="束缚变量"><a href="#束缚变量" class="headerlink" title="束缚变量"></a>束缚变量</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">λx. x  // 变量 x 是束缚变量</span><br></pre></td></tr></table></figure></div>

<h2 id="组合子"><a href="#组合子" class="headerlink" title="组合子"></a>组合子</h2><p>在λ演算中，组合子（Combinator） 是指 没有自由变量 的 λ 表达式 也就是说 组合子是 只包含束缚变量 的 λ 表达式 它们是纯粹的函数抽象 不依赖于外部环境 因此它们可以被认为是“自给自足”的函数 </p>
<p>组合子 之所以叫这个名字 是因为它们不依赖外部的变量或环境 只能依赖自己定义的参数 并且可以通过组合多个组合子来构建复杂的计算 组合子本质上是 λ 演算中的基础构建模块 类似于函数式编程中的高阶函数</p>
<h3 id="恒等组合子"><a href="#恒等组合子" class="headerlink" title="恒等组合子"></a>恒等组合子</h3><p>恒等组合子就是一个接受一个参数并返回这个参数的组合子 它的定义非常简单：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">I = λx. x</span><br></pre></td></tr></table></figure></div>
<p>作用：恒等组合子返回输入参数本身 不做任何改变</p>
<blockquote>
<p>I 5 → 5</p>
</blockquote>
<h3 id="K-组合子"><a href="#K-组合子" class="headerlink" title="K 组合子"></a>K 组合子</h3><p>K 组合子（又叫 K 函数或常量函数）接受两个参数 但只返回第一个参数 它的定义是：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">K = λx. λy. x</span><br></pre></td></tr></table></figure></div>
<p>作用：返回第一个参数 忽略第二个参数</p>
<blockquote>
<p>K 5 10 → 5</p>
</blockquote>
<p>在这个例子中 K 5 返回的是一个函数 λy. 5 再与任何第二个参数（比如 10）结合时 结果依然是 5</p>
<h3 id="S-组合子"><a href="#S-组合子" class="headerlink" title="S 组合子"></a>S 组合子</h3><p>S 组合子（又叫 S 函数）比较复杂 接受三个参数 并执行一些组合操作 它的定义如下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">S = λx. λy. λz. (x z) (y z)</span><br></pre></td></tr></table></figure></div>
<p>作用：S 组合子将输入的两个函数 x 和 y 应用于相同的参数 z 并将结果作为两个函数的输出</p>
<blockquote>
<p>S (λx. x + 1) (λx. x * 2) 3 → (λx. x + 1) 3  (λx. x * 2) 3<br>                              → 3 + 1    3 * 2<br>                              → 4        6</p>
</blockquote>
<p>S 组合子可以用于组合多个函数，使得它们的输入可以共享。</p>
<h3 id="组合子的性质"><a href="#组合子的性质" class="headerlink" title="组合子的性质"></a>组合子的性质</h3><p>组合子通常具有一些有用的性质 它们可以与其他组合子进行组合 以实现更加复杂的计算 几个重要的性质包括：</p>
<ol>
<li><p>函数应用<br>组合子是纯粹的 λ 演算表达式 它们的行为仅依赖于传入的参数 可以通过函数应用来将它们的计算结果传递给其他组合子 进一步构建复杂的计算</p>
</li>
<li><p>无外部依赖<br>组合子是完全自足的 它们的定义仅依赖于它们自己内部的参数 不需要从外部环境引入其他变量 这使得它们在编程语言和计算机科学中非常重要 尤其是在函数式编程中</p>
</li>
<li><p>高阶函数<br>组合子本质上是高阶函数（Higher-Order Function）它们可以作为输入传递给其他函数 或者返回作为结果 例如，S 组合子通过两个输入函数生成新的函数 具有高度的抽象能力</p>
</li>
</ol>
<h2 id="λ演算的作用"><a href="#λ演算的作用" class="headerlink" title="λ演算的作用"></a>λ演算的作用</h2><p>说了这么多 大家应该会进行一些关于λ演算的计算了 可λ演算有什么用呢 感觉就是换个抽象的形式进行计算<br>其实λ演算本质上是换了一种抽象的方式来进行计算 但它的意义远不止于此</p>
<h3 id="计算理论的基础"><a href="#计算理论的基础" class="headerlink" title="计算理论的基础"></a>计算理论的基础</h3><p>λ演算与图灵机（Turing Machine）一样 是计算理论的两大核心模型之一 它们都能表达可计算函数 但λ演算采用的是纯粹的函数变换 而图灵机基于状态和存储</p>
<ul>
<li>通过 λ演算 可以定义所有可计算的函数 因此它是图灵完备的</li>
<li>计算机科学家用它来研究可计算性、算法复杂度等问题</li>
</ul>
<h3 id="影响现代编程语言"><a href="#影响现代编程语言" class="headerlink" title="影响现代编程语言"></a>影响现代编程语言</h3><p>λ演算是函数式编程的理论基础 影响了 Haskell、Lisp、ML、Scala、JavaScript（匿名函数、箭头函数）、Python（Lambda 表达式）等编程语言 例如</p>
<ul>
<li>匿名函数（Lambda 表达式）</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">add = lambda x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(2, 3))  <span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>高阶函数（函数可以作为参数传递）</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def apply_func(f, x):</span><br><span class="line">    <span class="built_in">return</span> f(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(apply_func(lambda x: x * 2, 10))  <span class="comment"># 输出 20</span></span><br></pre></td></tr></table></figure></div>

<p>现代语言的 闭包（Closure）、惰性求值、纯函数 等概念都源于 λ演算</p>
<h3 id="形式化数学-逻辑推理"><a href="#形式化数学-逻辑推理" class="headerlink" title="形式化数学 &amp; 逻辑推理"></a>形式化数学 &amp; 逻辑推理</h3><p>λ演算被用作数学逻辑的基础，特别是在构造主义数学和类型理论中。例如：</p>
<ul>
<li>Curry-Howard 对应：λ演算中的函数和逻辑推理中的证明之间存在对应关系 程序可以被视为数学证明</li>
<li>依赖类型（Dependent Types）：Coq、Agda 这些数学证明工具都基于λ演算的扩展形式</li>
</ul>
<h3 id="递归与无变量编程"><a href="#递归与无变量编程" class="headerlink" title="递归与无变量编程"></a>递归与无变量编程</h3><p>λ演算能够表示 递归，即使它本身没有显式的循环结构。例如，阶乘可以用 Y 组合子（Y Combinator）来实现：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">factorial = \f. \n. <span class="keyword">if</span> n == 0 <span class="keyword">then</span> 1 <span class="keyword">else</span> n * (f (n - 1))</span><br><span class="line">Y factorial 5   -- 计算 5!</span><br></pre></td></tr></table></figure></div>

<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p>λ演算提供了转换和简化代码的规则 例如：</p>
<ul>
<li>β-规约（函数应用） 可以减少计算步骤 优化执行效率</li>
<li>α-变换（变量重命名） 可避免变量名冲突</li>
<li>η-变换（函数简化） 可以减少不必要的函数包装 提高性能</li>
</ul>
<p>许多编译器（如 GHC Haskell、Scala、Lisp 解释器）都会用 λ演算作为中间表示（IR）帮助优化代码</p>
<h3 id="并发-分布式计算"><a href="#并发-分布式计算" class="headerlink" title="并发 &amp; 分布式计算"></a>并发 &amp; 分布式计算</h3><p>λ演算的无状态特性使其非常适用于并发计算和分布式系统 例如：</p>
<ul>
<li>MapReduce（Google 的大规模数据处理模型）依赖于 λ演算的映射与归约思想</li>
<li>Actor Model（Erlang、Akka）与函数式编程紧密相关 受λ演算启发</li>
</ul>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>解决智力问题</title>
    <url>/zhihaojiang.github.io/2025/04/01/20250401%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] &#x3D; [pointsi, brainpoweri] 。</p>
<p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p>
<p>比方说，给你 questions &#x3D; [[3, 2], [4, 3], [4, 4], [2, 5]] ：</p>
<ul>
<li>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</li>
<li>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。</li>
<li>请你返回这场考试里你能获得的 最高 分数。</li>
</ul>
<p>示例 1：</p>
<p>输入：questions &#x3D; [[3,2],[4,3],[4,4],[2,5]]<br>输出：5<br>解释：解决问题 0 和 3 得到最高分。</p>
<ul>
<li>解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</li>
<li>不能解决问题 1 和 2</li>
<li>解决问题 3 ：获得 2 分<br>总得分为：3 + 2 &#x3D; 5 。没有别的办法获得 5 分或者多于 5 分。<br>示例 2：</li>
</ul>
<p>输入：questions &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]]<br>输出：7<br>解释：解决问题 1 和 4 得到最高分。</p>
<ul>
<li>跳过问题 0</li>
<li>解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</li>
<li>不能解决问题 2 和 3</li>
<li>解决问题 4 ：获得 5 分<br>总得分为：2 + 5 &#x3D; 7 。没有别的办法获得 7 分或者多于 7 分。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这题需要决定在每个问题上是“解决”还是“跳过” 如果选择解决问题 i 我们将会获得 pointsi 的分数 但接下来的 brainpoweri 个问题会被跳过 如果我们选择跳过问题 i 则直接考虑下一个问题<br>目标是找到能获得的最高分数</p>
<p>使用动态规划<br>设dp[i]是从第i个问题开始 能获得最高分<br>对于每个问题 i 有两种选择</p>
<div class="tabs" id="tab-choice"><ul class="nav-tabs"><li class="tab active"><a class="#choice-1">选择一</a></li><li class="tab"><a class="#choice-2">选择二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="choice-1"><p><strong>解决问题i</strong></p>
<p>可以获得 pointsi 的分数 但需要跳过接下来的 brainpoweri 个问题 因此，总分数为：</p>
<blockquote>
<p>pointsi + dp[i + brainpoweri + 1]</p>
</blockquote>
<p>其中  i + brainpoweri + 1 是下一个可以解决的问题索引 如果其超出了数组范围 则 dp[i + brainpoweri + 1] &#x3D; 0</p></div><div class="tab-pane" id="choice-2"><p><strong>跳过问题i</strong></p>
<p> 不解决问题 i 直接考虑下一个问题 i+1 总分数为：<br> dp[i + 1]</p></div></div></div>

<p>因此 我们要选择两者的最大值</p>
<blockquote>
<p>dp[i] &#x3D; max(pointsi + dp[i + brainpoweri + 1],  dp[i + 1])</p>
</blockquote>
<p>当 i &gt;&#x3D; n（超出数组范围时）dp[i] &#x3D; 0<br>当 i + brainpoweri + 1 &gt;&#x3D; n dp[i + brainpoweri + 1] &#x3D; 0<br>因此最终结果为dp[0] 我们永远要从第一个问题开始才能能获得最高分</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def mostPoints(questions):</span><br><span class="line">    n = len(questions)</span><br><span class="line">    dp = [0] * (n + 1)  <span class="comment"># 初始化 dp 数组，长度为 n+1，dp[n] = 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从后往前填充 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - 1, -1, -1):</span><br><span class="line">        points, brainpower = questions[i]</span><br><span class="line">        j = i + brainpower + 1  <span class="comment"># 下一个可以解决的问题索引</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; n:</span><br><span class="line">            solved = points + dp[j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            solved = points  <span class="comment"># 如果 j 超出范围，则没有后续问题</span></span><br><span class="line">        </span><br><span class="line">        skipped = dp[i + 1]  <span class="comment"># 跳过当前问题的分数</span></span><br><span class="line">        </span><br><span class="line">        dp[i] = max(solved, skipped)  <span class="comment"># 取最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> dp[0]  <span class="comment"># 返回从第一个问题开始的最大分数</span></span><br></pre></td></tr></table></figure></div>

<p>怎么样 解决了你的智力问题吗^_^</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>有序三元组中的最大值 I</title>
    <url>/zhihaojiang.github.io/2025/04/02/20250402%E6%9C%89%E5%BA%8F%E4%B8%89%E5%85%83%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的整数数组 nums 。</p>
<p>请你从所有满足 i &lt; j &lt; k 的下标三元组 (i, j, k) 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 0 。</p>
<p>下标三元组 (i, j, k) 的值等于 (nums[i] - nums[j]) * nums[k] 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums &#x3D; [12,6,1,2,7]<br>输出：77<br>解释：下标三元组 (0, 2, 4) 的值是 (nums[0] - nums[2]) * nums[4] &#x3D; 77 。<br>可以证明不存在值大于 77 的有序下标三元组。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums &#x3D; [1,10,3,4,19]<br>输出：133<br>解释：下标三元组 (1, 2, 4) 的值是 (nums[1] - nums[2]) * nums[4] &#x3D; 133 。<br>可以证明不存在值大于 133 的有序下标三元组。 </p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums &#x3D; [1,2,3]<br>输出：0<br>解释：唯一的下标三元组 (0, 1, 2) 的值是一个负数，(nums[0] - nums[1]) * nums[2] &#x3D; -3 。因此，答案是 0 。</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">方法一</a></li><li class="tab"><a class="#first-unique-name-2">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>暴力枚举</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maximumTripletValue(self, nums):</span><br><span class="line">        n = len(nums)   <span class="comment">#把数组长度赋值给n</span></span><br><span class="line">        result = 0  <span class="comment">#初始化result</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment">#暴力枚举 3层for循环</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + 1,n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j + 1,n):</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] - nums[j]) * nums[k] &gt; result:</span><br><span class="line">                        result = (nums[i] - nums[j]) * nums[k]  <span class="comment">#找出最大值</span></span><br><span class="line">        <span class="keyword">if</span> result &lt; 0:  <span class="comment">#判断结果是否都为负数</span></span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> result</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-unique-name-2"><p><strong>贪心</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximumTripletValue(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res, imax, dmax = 0, 0, 0</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(res, dmax * nums[k])</span><br><span class="line">            dmax = max(dmax, imax - nums[k])</span><br><span class="line">            imax = max(imax, nums[k])</span><br><span class="line">        <span class="built_in">return</span> res</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/solutions/3610891/you-xu-san-yuan-zu-zhong-de-zui-da-zhi-i-y6zb/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></div></div></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
</search>
