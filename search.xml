<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/zhihaojiang.github.io/2025/01/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>广州旅游</title>
    <url>/zhihaojiang.github.io/2024/07/31/20240731%E5%B9%BF%E5%B7%9E%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/super-213/hexo-images/blob/main/articles/2024/07/31/2024-05811.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05829.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05837.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05840.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05883.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05884.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/2024-05904.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/07/31/001.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>嘉兴大学演出</title>
    <url>/zhihaojiang.github.io/2024/10/17/20241017%E5%98%89%E5%85%B4%E5%A4%A7%E5%AD%A6%E6%BC%94%E5%87%BA/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07355.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07363.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07436.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07465.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07470.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07494.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07495.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2024/10/17/2024-07496.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语句</title>
    <url>/zhihaojiang.github.io/2025/01/06/20250106MySQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>本位与2025-01-06在CSDN上发布 现将其转移至自己的博客</p>
<h2 id="引擎相关"><a href="#引擎相关" class="headerlink" title="引擎相关"></a>引擎相关</h2><h3 id="查看存储引擎："><a href="#查看存储引擎：" class="headerlink" title="查看存储引擎："></a>查看存储引擎：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure></div>
<h3 id="查看显示支持的存储引擎信息："><a href="#查看显示支持的存储引擎信息：" class="headerlink" title="查看显示支持的存储引擎信息："></a>查看显示支持的存储引擎信息：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;have%&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="查看默认的存储引擎："><a href="#查看默认的存储引擎：" class="headerlink" title="查看默认的存储引擎："></a>查看默认的存储引擎：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;storage_engine&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数据库相关操作-增-删-改"><a href="#数据库相关操作-增-删-改" class="headerlink" title="数据库相关操作(增 删 改)"></a>数据库相关操作(增 删 改)</h2><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create datbase [<span class="keyword">if</span> not exists] db_name</span><br><span class="line">[[DEFAULT] CHARACTER SET charset_name]</span><br><span class="line">[[DEFALUT] COLLATE collation_name]</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>“[ ]”中的是可选项 可写可不写<br>将db_name替换成你想给数据库取的名字</p>

    </div>
  </div>

<h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></div>

<h3 id="查看数据库的详细信息"><a href="#查看数据库的详细信息" class="headerlink" title="查看数据库的详细信息"></a>查看数据库的详细信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show create database db_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用某个数据库"><a href="#使用某个数据库" class="headerlink" title="使用某个数据库"></a>使用某个数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">use db_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter database [db_name]</span><br><span class="line">[DEFAULT CHARACTER SET charset_name]| [[DEFAULT]COLLATE collation_name]</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>例1：将schoolDB的编码方式有GBK修改为UTF8。</p>
<p>法1:ALTER DATABASE schoolDB CHARACTER SET UTF8;</p>
<p>法2:ALTER DATABASE schoolDB collate utf8_general_ci;</p>

    </div>
  </div>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop database [<span class="keyword">if</span> exists] db_name;</span><br></pre></td></tr></table></figure></div>
<h2 id="表的相关操作（增删改查）"><a href="#表的相关操作（增删改查）" class="headerlink" title="表的相关操作（增删改查）"></a>表的相关操作（增删改查）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table [<span class="keyword">if</span> exists] t_name(</span><br><span class="line">    name_1 int [primary key],</span><br><span class="line">    name_2 varchar(10)[...],</span><br><span class="line">    name_3 <span class="built_in">float</span>(5, 3)[...]</span><br><span class="line">)[engine = INNODB charset = UTF-8];</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>这里t_name是表名</p>
<p>name_1 name_2 name_3 是字段名</p>
<p>字段名后面[ ]中的是完整性约束(可选填)</p>
<p> 完整性约束条件：<br> PRIMARY KEY主键（唯一来标识的，每一个表都一个，自动非空）<br> AUTO_INCREMENT自增长<br> FOREIGN KEY外键<br> NOT NULL非空<br> UNIQUE KEY唯一<br> DEFAULT默认值<br>最下面的[ ] 中的是引擎和编码方式的选择</p>

    </div>
  </div>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="在name-3的（前面-后面）-增加新列name-4"><a href="#在name-3的（前面-后面）-增加新列name-4" class="headerlink" title="[在name_3的（前面|后面）] 增加新列name_4"></a>[在name_3的（前面|后面）] 增加新列name_4</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    add name_4 [first|after name_3];</span><br></pre></td></tr></table></figure></div>

<h4 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h4><p>将name_2的数据类型修改成float(4,3)</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    modify name_2 <span class="built_in">float</span>(4,3)</span><br></pre></td></tr></table></figure></div>

<h4 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h4><p>将表t_name中的name_1列的名字修改成new_name_1</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    change name_1 new_name_1;</span><br></pre></td></tr></table></figure></div>

<h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><p>将表t_name的名字修改成new_t_name</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    rename [to] new_t_name;</span><br></pre></td></tr></table></figure></div>

<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p>将表t_name中的name_1列删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">drop column name_1；</span><br></pre></td></tr></table></figure></div>

<h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">delete from t_name</span><br><span class="line"><span class="built_in">where</span> 条件表达式；</span><br></pre></td></tr></table></figure></div>

<h4 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h4><p>将表t_name的存储引擎修改成INNODB</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">alter table t_name</span><br><span class="line">    engine = INNODB;</span><br></pre></td></tr></table></figure></div>

<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><p>查看表名</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></div>

<p>查看表的结构</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#法1</span></span><br><span class="line">show create table t_name；</span><br><span class="line"> </span><br><span class="line"><span class="comment">#法2</span></span><br><span class="line">describe t_name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#法3</span></span><br><span class="line">desc t_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table [<span class="keyword">if</span> not existe] t_name</span><br><span class="line">[like t_name_2]</span><br><span class="line">[as 表信息]</span><br><span class="line"> </span><br><span class="line"><span class="comment">#like可以复制表的结构 表中的信息不会被复制 复制出来的是个空表</span></span><br><span class="line"><span class="comment">#as 可以复制表中的信息 相当于CV大法</span></span><br></pre></td></tr></table></figure></div>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>将表t_name删除</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop table t_name；</span><br></pre></td></tr></table></figure></div>

<h2 id="数据相关操作"><a href="#数据相关操作" class="headerlink" title="数据相关操作"></a>数据相关操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">insert [into]</span><br><span class="line">    t_name(name_1, name_2, name_3)</span><br><span class="line">    values(12,<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;2025-01-04&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="查看插入信息"><a href="#查看插入信息" class="headerlink" title="查看插入信息"></a>查看插入信息</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from t_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">update t_name</span><br><span class="line"><span class="built_in">set</span> name_1 = x,</span><br><span class="line">    name_2 = y,</span><br><span class="line">    name_3 = z</span><br><span class="line">[<span class="built_in">where</span> 条件表达式];</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>若where不写<br>则更新全部记录</p>

    </div>
  </div>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">delate from t_name</span><br><span class="line">[<span class="built_in">where</span> 条件表达式];</span><br></pre></td></tr></table></figure></div>

<p>完全清除某个表<br>完全清除表t_name：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">truncate</span> [table] t_name;</span><br></pre></td></tr></table></figure></div>

<h2 id="单表查询（重点）"><a href="#单表查询（重点）" class="headerlink" title="单表查询（重点）"></a>单表查询（重点）</h2><p>先给出语法：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [distinct] name_1 [as new_name],</span><br><span class="line">       [distinct] name_2 [as new_name],</span><br><span class="line">from t_name</span><br><span class="line">[<span class="built_in">where</span> 条件表达式,]</span><br><span class="line">[group by name [ASC|DESC],]</span><br><span class="line">[order by name [ASC|DESC],]</span><br><span class="line">[<span class="built_in">limit</span> 条数]；</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>SELECT子句：<br>指定要查询的列名称，列与列之间用逗号隔开。<br>还可以为列指定新的别名，显示在输出的结果中。<br>ALL关键字表示显示所有的行，包括重复行，是系统默认的<br>DISTINCT表示显示的结果要消除重复的行。<br>FROM子句：指定要查询的表，可以指定两个以上的表，表与表之间用逗号隔开。<br>WHERE子句：指定要查询的条件。<br>如果有WHERE子句，就按照“条件表达式”指定的条件进行查询；<br>如果没有WHERE子句，就查询所有记录。</p>
<p>GROUP BY ：<br>子句用于对查询结构进行分组。<br>按照“列名1”指定的字段进行分组；<br>如果GROUP BY子句后带着HAVING关键字，那么只有满足“条件表达式2”中指定的条件的才能够输出。<br>GROUP BY子句通常和COUNT()、SUM()等聚合函数一起使用。</p>
<p>HAVING子句：<br>指定分组的条件，通常放Group by字句之后</p>
<p>ORDER BY子句：用于对查询结果的进行排序。<br>排序方式由ASC和DESC两个参数指出；<br>ASC参数表示按升序进行排序。默认情况下是ASC。<br>DESC参数表示按降序的顺序进行排序。升序表示值按从小到大的顺序排列。</p>
<p>LIMIT 子句：限制查询的输出结果的行数。</p>

    </div>
  </div>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>等值连接</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> x_name_1,</span><br><span class="line">       y_name_2</span><br><span class="line">from t_x </span><br><span class="line">inner <span class="built_in">join</span> t_y on t_x.id = t_y.id</span><br><span class="line"><span class="built_in">where</span>...;</span><br></pre></td></tr></table></figure></div>
<p>左连接、右连接和联合查询不过多赘述</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>带in关键词的子查询</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">from t_name_1</span><br><span class="line"><span class="built_in">where</span> name_1 <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> name_2 from t_name_2</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>带比较运算符的子查询</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">from t_name_1</span><br><span class="line"><span class="built_in">where</span> name = (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">id</span></span><br><span class="line">    from t_name_2</span><br><span class="line">    <span class="built_in">where</span> <span class="built_in">id</span> = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>引:<br>    面试题：select id,name,age from sd where name&#x3D;’张飞’<br>    怎么优化？最佳方案是什么？<br>    答：在name上创建索引：<br>    create index in name on sd(name);</p>
<h3 id="语法（已存在的表）："><a href="#语法（已存在的表）：" class="headerlink" title="语法（已存在的表）："></a>语法（已存在的表）：</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create index in_id</span><br><span class="line">on t_name(<span class="built_in">id</span>);</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>in_id:索引名 （自己取）<br>t_name:表名<br>id:列名</p>

    </div>
  </div>

<h3 id="在创建表的时候创建索引"><a href="#在创建表的时候创建索引" class="headerlink" title="在创建表的时候创建索引"></a>在创建表的时候创建索引</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create table t_name(</span><br><span class="line">...</span><br><span class="line">[unique|fulltext|spatial] index|key [in_id](name[长度])[ASC|DESC]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create view view_name as</span><br><span class="line"><span class="comment">#查询语句:</span></span><br><span class="line"><span class="keyword">select</span>...</span><br><span class="line">[with [cascaded|<span class="built_in">local</span>] check option];</span><br></pre></td></tr></table></figure></div>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">drop view view_name;</span><br></pre></td></tr></table></figure></div>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">create user <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identifiednby <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from mysql.user;</span><br></pre></td></tr></table></figure></div>

<h3 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grant 权限 on 库.表 to <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#触发器设置</span></span><br><span class="line">CREATE TRIGGER before_position_update</span><br><span class="line">BEFORE UPDATE ON staff</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    IF OLD.position != NEW.position THEN</span><br><span class="line">        CASE NEW.position</span><br><span class="line">            WHEN <span class="string">&#x27;董事长&#x27;</span> THEN</span><br><span class="line">                SET NEW.role = 9;</span><br><span class="line">            WHEN <span class="string">&#x27;经理&#x27;</span> THEN</span><br><span class="line">                SET NEW.role = 6;</span><br><span class="line">            ELSE</span><br><span class="line">                SET NEW.role = 2;</span><br><span class="line">        END CASE;</span><br><span class="line">    END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>PS</p>

    </div>
    <div class="notel-content">
      <p>这里是当position设置为经理或董事长时 自动更改权限等级</p>

    </div>
  </div>

<h3 id="显示设置的触发器"><a href="#显示设置的触发器" class="headerlink" title="显示设置的触发器"></a>显示设置的触发器</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示设置的触发器</span></span><br><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure></div>

<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>备份数据库到文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p db_name &gt; backup.sql</span><br></pre></td></tr></table></figure></div>

<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>从文件恢复数据库。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u username -p db_name &lt; backup.sql</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>澳洲旅游</title>
    <url>/zhihaojiang.github.io/2025/01/25/20250125%E6%BE%B3%E6%B4%B2%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09682.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09718.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09763.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09941.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09945.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09946.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09958.jpg"
                      alt="photo"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/01/25/2025-09967.jpg"
                      alt="photo"
                ></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习作业笔记</title>
    <url>/zhihaojiang.github.io/2025/03/28/20250328%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>我们需要利用回归分析预测世界大学综合得分</p>
<p>#Jupyter notebook代码<br>基本库导入</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line">from sklearn.metrics import mean_squared_error,r2_score</span><br><span class="line">from scipy import stats</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.metrics import root_mean_squared_error</span><br><span class="line">from sklearn import linear_model</span><br><span class="line">from sklearn import metrics</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university = pd.read_csv(<span class="string">&#x27;cwurData.csv&#x27;</span>)</span><br><span class="line">university.head()</span><br></pre></td></tr></table></figure></div>
<p>此时可能会出现报错</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>报错信息</p>

    </div>
    <div class="notel-content">
      <p>File parsers.pyx:574, in pandas._libs.parsers.TextReader.<strong>cinit</strong>()</p>
<p>File parsers.pyx:663, in pandas._libs.parsers.TextReader._get_header()</p>
<p>File parsers.pyx:874, in pandas._libs.parsers.TextReader._tokenize_rows()</p>
<p>File parsers.pyx:891, in pandas._libs.parsers.TextReader._check_tokenize_status()</p>
<p>File parsers.pyx:2053, in pandas._libs.parsers.raise_parser_error()</p>
<p>File <frozen codecs>:322, in decode(self, input, final)</p>
<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode bytes in position 3864-3865: invalid continuation byte</p>

    </div>
  </div>
<p>不用担心，这是因为pd.read_csv()在不指明encoding时默认使用utf-8编码<br>这段报错是因为该文件不是使用utf-8进行编码。<br>我们可以写一段代码判断文件的编码格式</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import chardet</span><br><span class="line"></span><br><span class="line">with open(<span class="string">&#x27;cwurData.csv&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) as f:</span><br><span class="line">    university = f.read()</span><br><span class="line">    encoding = chardet.detect(university)</span><br><span class="line">    <span class="built_in">print</span>(encoding)</span><br></pre></td></tr></table></figure></div>
<p>之后将其输出的encoding写入pd.read_csv()即可</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university = pd.read_csv(<span class="string">&#x27;cwurData.csv&#x27;</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">university.head()</span><br></pre></td></tr></table></figure></div>
<p>输出结果为<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/001.png"
                      alt="photo"
                ><br>通过该数据可知其数字应该是越小越好<br>因此相关性应该是负数 且越小越好</p>
<p>之后我们查看文件的维度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university.shape</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:(2200, 14)<br>说明该文件总共有2200行数据，14个特征</p>
<p>接下来我们分析下文件是否有异常</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">university.describe()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/002.png"
                      alt="photo"
                ><br>从第一行(count)看到 broad_impact数据与其他数据不同<br>上述从head()函数我猜测broad_impact列全是NA<br>仔细查看文件后可知:2012年和2013年的broad_impact存在缺失<br>其他数据看起来没什么问题 数据质量基本完整</p>
<p>先用相关性矩阵看看各个数据之间的关系</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = university[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">X = university.drop([<span class="string">&quot;score&quot;</span>,<span class="string">&quot;institution&quot;</span>,<span class="string">&quot;country&quot;</span>, <span class="string">&quot;year&quot;</span>,<span class="string">&quot;broad_impact&quot;</span>],axis=1)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">correlation_matrix = pd.concat([X_train, y_train], axis=1).corr()</span><br><span class="line"></span><br><span class="line">sns.heatmap(correlation_matrix, annot=True, cmap=<span class="string">&#x27;coolwarm&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/003.png"
                      alt="photo"
                ><br>通过上图可以看到world_rank与publications、influence、citations有强相关性<br>我们用matplotlib.pyplot库做出这些图</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;publications&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;publications&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/004.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;influence&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;influence&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/005.png"
                      alt="photo"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;citations&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;world_rank&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;world_rank&amp;citations&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/006.png"
                      alt="photo"
                ></p>
<p>从上述三幅图可以看到world_rank与publications、influence有强相关性<br>world_rank与citations也有一定的相关性 但不是很明显<br>再继续做几张图看看其他数据之间的关系怎么样</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;publications&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;influence&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;influence&amp;publications&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/007.png"
                      alt="photo"
                ><br>从图中可以看出点近似集中在一条直线上<br>说明出版物与影响力成正比</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;broad_impact&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;score&quot;</span>]</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;score&amp;broad_impact&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/super-213/hexo-images/main/articles/2025/03/28/008.png"
                      alt="photo"
                ><br>从图中可以看出broad_impact与score成非线性关系 broad_impact的大小与score无关<br><br>用相关性进行检测</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">x = university[<span class="string">&quot;broad_impact&quot;</span>]</span><br><span class="line">y = university[<span class="string">&quot;score&quot;</span>]</span><br><span class="line">correlation = x.corr(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r:&quot;</span>, correlation)</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:r: -0.5315904271503679</p>
<p>呈现负相关 因此确定 broad_impact的大小与score无关<br>并且broad_impact中存在缺失值<br>缺失值的处理一般会使用用众数填充、前或后一个数填充、删除缺失列来处理<br>这里broad_impact的大小与score无关<br>因此可以将此列删去<br>同时也可以降低维度</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">y = university[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">X = university.drop([<span class="string">&quot;score&quot;</span>,<span class="string">&quot;institution&quot;</span>,<span class="string">&quot;country&quot;</span>, <span class="string">&quot;year&quot;</span>,<span class="string">&quot;broad_impact&quot;</span>],axis=1)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">lr.intercept_</span><br><span class="line"></span><br><span class="line">coefs_lr = pd.Series(lr.coef_).round()</span><br><span class="line">coefs_lr.index = X_train.columns</span><br><span class="line">coefs_lr</span><br></pre></td></tr></table></figure></div>

<p>其结果为:<br>63.60601390140695</p>
<p>world_rank              0.0<br>national_rank          -0.0<br>quality_of_education   -0.0<br>alumni_employment      -0.0<br>quality_of_faculty     -0.0<br>publications           -0.0<br>influence              -0.0<br>citations              -0.0<br>patents                -0.0<br>dtype: float64</p>
<p>说明模型拟合得不好<br>查看其均方根误差和决定系数</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lr_train_pred = lr.predict(X_train)</span><br><span class="line">lr_test_pred = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;训练集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(lr_train_pred,y_train), r2_score(lr_train_pred,y_train))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;测试集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(lr_test_pred,y_test), r2_score(lr_test_pred,y_test))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>训练集上的均方根误差和决定系数分别为: 5.441831802594455 0.079429595738992<br>测试集上的均方根误差和决定系数分别为: 5.369301125131177 0.06344204755145388</p>
<p>上述系数过小可能是数值之间差别过大导致拟合得不好<br>将其进行标准化</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train_scaled, y_train)</span><br><span class="line">coefs_lr = pd.Series(lr.coef_).round()</span><br><span class="line">coefs_lr.index = X_train.columns</span><br><span class="line">coefs_lr</span><br><span class="line"></span><br><span class="line">lr.intercept_</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>world_rank              0.0<br>national_rank          -0.0<br>quality_of_education   -0.0<br>alumni_employment      -1.0<br>quality_of_faculty     -4.0<br>publications           -0.0<br>influence              -0.0<br>citations              -0.0<br>patents                -0.0<br>dtype: float64</p>
<p>47.83457386363636</p>
<p>模型得到的结果很低 说明拟合得不好<br>更换其他线性回归模型试试</p>
<div class="tabs" id="tab-线性回归模型"><ul class="nav-tabs"><li class="tab active"><a class="#线性回归模型-1">岭回归</a></li><li class="tab"><a class="#线性回归模型-2">lasso回归</a></li><li class="tab"><a class="#线性回归模型-3">弹性网回归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="线性回归模型-1"><p><strong>岭回归</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ridge= linear_model.Ridge(alpha=0.05)</span><br><span class="line">ridge.fit(X_train,y_train)</span><br><span class="line">Y_hat = ridge.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>, ridge.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, ridge.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p> 输出结果为:<br> 截距为： 63.60601382257282<br>回归系数为： [ 0.00116895 -0.00608447 -0.00380894 -0.00592045 -0.06344228 -0.00045937<br> -0.0009899  -0.00046924 -0.00164281]<br> RMSE: 5.369301120766853</p></div><div class="tab-pane" id="线性回归模型-2"><p><strong>lasso回归</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">lasso= linear_model.Lasso(alpha=0.05)</span><br><span class="line">lasso.fit(X_train,y_train)</span><br><span class="line">Y_hat=lasso.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>,lasso.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, lasso.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>截距为： 63.602800047243974<br>回归系数为： [ 0.00115484 -0.00606551 -0.00381082 -0.00591616 -0.06342471 -0.00045677<br> -0.00098495 -0.00046729 -0.00164163]<br> RMSE: 5.369181579518303</p></div><div class="tab-pane" id="线性回归模型-3"><p><strong>弹性网回归</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">elastic= linear_model.ElasticNet(alpha=0.1,l1_ratio=0.4)</span><br><span class="line">elastic.fit(X_train,y_train)</span><br><span class="line">y_hat = elastic.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;截距为：&quot;</span>,elastic.intercept_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;回归系数为：&quot;</span>, elastic.coef_)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;RMSE:&quot;</span>, np.sqrt(metrics.mean_squared_error(y_test, Y_hat)))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>截距为： 63.60327653271375<br>回归系数为： [ 0.00115777 -0.0060693  -0.00381124 -0.00591707 -0.06342543 -0.00045734<br> -0.00098603 -0.00046779 -0.00164194]<br> RMSE: 5.369181579518303</p></div></div></div>

<p>可以看到这些回归得到的结果都不好<br>说明这个不是呈线性关系</p>
<p>我们使用随机森林进行尝试</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rf = RandomForestRegressor()</span><br><span class="line">rf.fit(X_train, y_train)</span><br><span class="line">rf_train_pred = rf.predict(X_train)</span><br><span class="line">rf_test_pred = rf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;训练集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(rf_train_pred,y_train), r2_score(rf_train_pred,y_train))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;测试集上的均方根误差和决定系数分别为:&quot;</span>, root_mean_squared_error(rf_test_pred,y_test), r2_score(rf_test_pred,y_test))</span><br></pre></td></tr></table></figure></div>
<p>输出结果为:<br>训练集上的均方根误差和决定系数分别为: 0.396126717281446 0.9974538720434839<br>测试集上的均方根误差和决定系数分别为: 1.0185613846393418 0.9808937922886296</p>
<p>可以看到 决定系数为0.99 0.98以上 说明模型拟合得很好</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>连续特征离散化的处理方法及其python实现</title>
    <url>/zhihaojiang.github.io/2025/03/29/20250329%E8%BF%9E%E7%BB%AD%E7%89%B9%E5%BE%81%E7%A6%BB%E6%95%A3%E5%8C%96%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="等距离散法"><a href="#等距离散法" class="headerlink" title="等距离散法"></a>等距离散法</h2><p>将连续数据的范围划分为几个宽度相等的区间。每个区间内的数值都有相同的范围。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分为 5 个等宽区间</span></span><br><span class="line">bins = pd.cut(data, bins=5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分箱结果</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="等频离散法"><a href="#等频离散法" class="headerlink" title="等频离散法"></a>等频离散法</h2><p>将数据分成几个区间，使得每个区间内的数据量相同。这样可以避免某些区间的数据过于集中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据分为 5 个等频区间</span></span><br><span class="line">bins = pd.qcut(data, q=5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分箱结果</span></span><br><span class="line"><span class="built_in">print</span>(bins.value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="K-means-模型离散法"><a href="#K-means-模型离散法" class="headerlink" title="K-means 模型离散法"></a>K-means 模型离散法</h2><p>先从样本集中随机选取 k个样本作为簇中心，并计算所有样本与这 k个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.cluster import KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000).reshape(-1, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 K-means 聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=5)</span><br><span class="line">labels = kmeans.fit_predict(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看聚类标签</span></span><br><span class="line"><span class="built_in">print</span>(pd.Series(labels).value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="基于决策树的离散化"><a href="#基于决策树的离散化" class="headerlink" title="基于决策树的离散化"></a>基于决策树的离散化</h2><p>基于决策树的方法利用决策树的分割规则进行离散化，将连续特征分割成多个区间，通常用于有监督学习中的离散化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成连续数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line">target = np.random.randint(0, 2, size=1000)  <span class="comment"># 假设目标变量是二分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将连续数据转化为二维数组</span></span><br><span class="line">X = data.reshape(-1, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用决策树进行离散化</span></span><br><span class="line">clf = DecisionTreeClassifier(max_leaf_nodes=5)</span><br><span class="line">clf.fit(X, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每个样本所属的区间</span></span><br><span class="line">labels = clf.apply(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看离散化结果</span></span><br><span class="line"><span class="built_in">print</span>(pd.Series(labels).value_counts())</span><br></pre></td></tr></table></figure></div>

<h2 id="分位数离散法"><a href="#分位数离散法" class="headerlink" title="分位数离散法"></a>分位数离散法</h2><p>分位数离散化的核心思想是：<br>按照数据的累积分布函数 (CDF) 计算分位点。<br>根据分位数（如四分位数 (quartiles)、十分位数 (deciles)）划分数据，使得每个区间的样本数接近相等。<br>由于基于数据的分布进行划分，适用于非均匀分布的数据。</p>
<p>以下是不同的方法进行实现</p>
<div class="tabs" id="tab-分位数离散法实现方法"><ul class="nav-tabs"><li class="tab active"><a class="#分位数离散法实现方法-1">方法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="分位数离散法实现方法-1"><p><strong>使用numpy.percentile()</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 1000 个随机数据</span></span><br><span class="line">data = np.random.randn(1000)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 10 分位数（十分位数）</span></span><br><span class="line">percentiles = np.percentile(data, q=[10, 20, 30, 40, 50, 60, 70, 80, 90])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 np.digitize 进行分箱</span></span><br><span class="line">bins = np.digitize(data, percentiles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个分箱的数据量</span></span><br><span class="line"><span class="built_in">print</span>(np.bincount(bins))</span><br></pre></td></tr></table></figure></div></div></div></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>分位数离散化的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>适用于非均匀分布数据，相比于等宽离散化更合理。<br>避免某些区间数据过多或过少，能够更好地均衡数据。<br>能够减少异常值的影响，因为分箱是基于数据分布，而不是固定范围。</p>
<p>❌ 缺点<br>对极端值敏感，如果数据中有极端值，可能会影响分位数计算结果。<br>区间边界难以解释，不像等宽分箱那样有固定的区间宽度。<br>对新数据可能需要重新计算分位点，导致难以适用于流式数据。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用分位数离散化？</p>

    </div>
    <div class="notel-content">
      <p>数据分布不均匀（例如数据集中在某些范围）。<br>避免某些区间样本过多或过少，如在决策树、统计建模等场景中使用。<br>希望减少异常值的影响，避免极端值导致不均匀的划分。</p>

    </div>
  </div>

<h2 id="基于卡方分裂的离散法"><a href="#基于卡方分裂的离散法" class="headerlink" title="基于卡方分裂的离散法"></a>基于卡方分裂的离散法</h2><p>该分裂算法是把整个属性的取值区间当做一个离散的属性值，然后对该区间进行划分，一般是一分为二，即把一个区间分为两个相邻的区间，每个区间对应一个离散的属性值，该划分可以一直进行下去，直到满足某种停止条件，其关键是划分点的选取。</p>
<p><strong>方法一</strong><br><strong>手动实现</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy.stats import chi2_contingency</span><br><span class="line"></span><br><span class="line">def chi2_value(freq_table):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;计算卡方值&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    chi2, p, _, _ = chi2_contingency(freq_table)</span><br><span class="line">    <span class="built_in">return</span> chi2</span><br><span class="line"></span><br><span class="line">def chimerge(data, target, max_bins=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    基于卡方分裂的离散化方法（ChiMerge）</span></span><br><span class="line"><span class="string">    :param data: 连续特征（NumPy 数组或 Pandas Series）</span></span><br><span class="line"><span class="string">    :param target: 目标变量（分类变量）</span></span><br><span class="line"><span class="string">    :param max_bins: 期望的最大分箱数</span></span><br><span class="line"><span class="string">    :return: 分箱边界</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">df</span> = pd.DataFrame(&#123;<span class="string">&#x27;feature&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;)</span><br><span class="line">    <span class="built_in">df</span> = df.sort_values(by=<span class="string">&#x27;feature&#x27;</span>).reset_index(drop=True)  <span class="comment"># 按特征值排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每个特征值下的类别频次</span></span><br><span class="line">    freq_table = df.groupby(<span class="string">&#x27;feature&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].value_counts().unstack().fillna(0)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始边界（每个值单独作为一个区间）</span></span><br><span class="line">    bins = list(freq_table.index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(bins) &gt; max_bins:  <span class="comment"># 直到达到最大分箱数</span></span><br><span class="line">        min_chi2 = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        min_index = -1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有相邻区间，找到卡方值最小的区间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bins) - 1):</span><br><span class="line">            merged_table = freq_table.loc[[bins[i], bins[i + 1]]].<span class="built_in">sum</span>(axis=0).values.reshape(2, -1)</span><br><span class="line">            chi2 = chi2_value(merged_table)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> chi2 &lt; min_chi2:  <span class="comment"># 找到最小的卡方值</span></span><br><span class="line">                min_chi2 = chi2</span><br><span class="line">                min_index = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并卡方值最小的区间</span></span><br><span class="line">        bins[min_index] = (bins[min_index] + bins[min_index + 1]) / 2</span><br><span class="line">        bins.pop(min_index + 1)  <span class="comment"># 删除合并的区间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50  <span class="comment"># 生成随机数</span></span><br><span class="line">target = np.random.choice([0, 1], size=100)  <span class="comment"># 二分类目标变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分箱边界</span></span><br><span class="line">bin_edges = chimerge(data, target, max_bins=4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方分裂后的分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二</strong><br><strong>使用optbinning库</strong></p>
<p>如果不想手动实现，可以使用 optbinning 库，它可以进行最优分箱（Optimal Binning），内部使用 ChiMerge 或者 Decision Tree 进行离散化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from optbinning import OptimalBinning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50</span><br><span class="line">target = np.random.choice([0, 1], size=100)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 OptimalBinning 进行卡方离散化</span></span><br><span class="line">optb = OptimalBinning(name=<span class="string">&quot;feature&quot;</span>, dtype=<span class="string">&quot;numerical&quot;</span>, solver=<span class="string">&quot;cp&quot;</span>)</span><br><span class="line">optb.fit(data, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取分箱边界</span></span><br><span class="line">bin_edges = optb.splits</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;自动计算的分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>ChiMerge的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>保持类别信息：确保离散化后不同类别仍然可以区分，提高模型效果。<br>自动确定最优分箱：基于卡方值合并区间，减少信息损失。<br>避免过度离散化：不像等宽分箱或等频分箱可能导致信息丢失。</p>
<p>❌ 缺点<br>计算量较大：随着样本数增加，计算卡方统计量的复杂度会增加。<br>依赖类别变量：只能用于分类任务，如果目标变量是连续值，需要先离散化。<br>需要调整超参数：最大分箱数 max_bins 需要根据数据调优。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用ChiMerge</p>

    </div>
    <div class="notel-content">
      <p>分类任务：目标变量是离散类别（如二分类、多分类）。<br>决策树模型：离散化后可以提升决策树模型的可解释性。<br>数据量较大：对于大规模数据，可通过 optbinning 等库加速处理。</p>

    </div>
  </div>

<p>ChiMerge 离散化适用于分类任务，可以在决策树、朴素贝叶斯等模型中提升效果。对于回归任务，可以考虑 KMeans 或 等宽&#x2F;等频分箱。</p>
<h2 id="1R离散法"><a href="#1R离散法" class="headerlink" title="1R离散法"></a>1R离散法</h2><p>1R 就是 1-rule，称为1 规则，也就是产生一层的决策树，用一个规则集的形式，只在某个特定的属性上进行测试。1R是一个简单廉价的方法，但却常常能得到令人吃惊的准确率。<br>它的核心思想是：<br>将连续特征划分为多个区间，然后<br>寻找能够最好地预测目标变量（类别）的区间划分。</p>
<p>1R 方法的基本步骤如下：<br>对特征值排序。<br>尝试不同的分箱方法（等宽、等频、信息增益等），并计算分类错误率。<br>选择错误率最低的分箱方式作为最终的离散化方式。</p>
<p><strong>方法一</strong><br><strong>手动实现</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">def one_r_discretization(data, target, max_bins=5):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    基于 1R 规则的离散化方法</span></span><br><span class="line"><span class="string">    :param data: 连续特征 (NumPy 数组或 Pandas Series)</span></span><br><span class="line"><span class="string">    :param target: 目标变量 (分类变量)</span></span><br><span class="line"><span class="string">    :param max_bins: 期望的最大分箱数</span></span><br><span class="line"><span class="string">    :return: 最优分箱边界</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">df</span> = pd.DataFrame(&#123;<span class="string">&#x27;feature&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;)</span><br><span class="line">    <span class="built_in">df</span> = df.sort_values(by=<span class="string">&#x27;feature&#x27;</span>).reset_index(drop=True)  <span class="comment"># 按特征值排序</span></span><br><span class="line"></span><br><span class="line">    best_bins = None</span><br><span class="line">    best_error = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试不同分箱方式</span></span><br><span class="line">    <span class="keyword">for</span> bins <span class="keyword">in</span> range(2, max_bins + 1):</span><br><span class="line">        <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>] = pd.cut(<span class="built_in">df</span>[<span class="string">&#x27;feature&#x27;</span>], bins=bins, labels=False)  <span class="comment"># 进行分箱</span></span><br><span class="line">        bin_stats = df.groupby(<span class="string">&#x27;bin&#x27;</span>)[<span class="string">&#x27;target&#x27;</span>].agg(lambda x: x.value_counts().index[0])  <span class="comment"># 每个分箱内占比最高的类别</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算错误率</span></span><br><span class="line">        <span class="built_in">df</span>[<span class="string">&#x27;pred&#x27;</span>] = <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>].map(bin_stats)</span><br><span class="line">        error_rate = (<span class="built_in">df</span>[<span class="string">&#x27;pred&#x27;</span>] != <span class="built_in">df</span>[<span class="string">&#x27;target&#x27;</span>]).mean()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择错误率最低的分箱方案</span></span><br><span class="line">        <span class="keyword">if</span> error_rate &lt; best_error:</span><br><span class="line">            best_error = error_rate</span><br><span class="line">            best_bins = <span class="built_in">df</span>[<span class="string">&#x27;bin&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> best_bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(100) * 10 + 50  <span class="comment"># 生成随机数</span></span><br><span class="line">target = np.random.choice([0, 1], size=100)  <span class="comment"># 目标变量（0 或 1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分箱边界</span></span><br><span class="line">bin_edges = one_r_discretization(data, target, max_bins=4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1R 规则下的最佳分箱边界:&quot;</span>, bin_edges)</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二</strong><br><strong>使用KBinsDiscretizer</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import KBinsDiscretizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">data = data.reshape(-1, 1)  <span class="comment"># 需要转换为 2D 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用监督式分箱</span></span><br><span class="line">discretizer = KBinsDiscretizer(n_bins=4, encode=<span class="string">&#x27;ordinal&#x27;</span>, strategy=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">binned_data = discretizer.fit_transform(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1R 近似分箱结果:&quot;</span>, np.unique(binned_data))</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>1R方法的优缺点</p>

    </div>
    <div class="notel-content">
      <p>✅ 优点<br>监督式分箱：保留目标变量信息，减少信息损失。<br>简单易懂：规则明确，适合初步数据探索。<br>适用于分类任务：尤其适用于决策树、朴素贝叶斯等分类模型。</p>
<p>❌ 缺点<br>计算复杂度较高：需要尝试多个分箱方案，计算错误率。<br>可能过拟合：如果 max_bins 过大，可能导致分箱过多，导致模型过拟合。<br>仅适用于分类任务：如果目标变量是连续值，需要先进行离散化。</p>

    </div>
  </div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用1R离散化？</p>

    </div>
    <div class="notel-content">
      <p>分类任务（目标变量是离散类别，如 0&#x2F;1 或 A&#x2F;B&#x2F;C）。<br>数据探索：快速找到能够划分类别的最优分箱方式。<br>决策树建模：如 CART、ID3、C4.5 等模型。</p>

    </div>
  </div>

<h2 id="二值化离散法"><a href="#二值化离散法" class="headerlink" title="二值化离散法"></a>二值化离散法</h2><p>二值化离散法是一种简单且常用的离散化方法，它的基本思想是 将连续变量转换为两个类别（0 和 1），即：<br>小于某个阈值的设为 0<br>大于等于某个阈值的设为 1</p>
<p>这种方法特别适用于需要转换成 布尔值（Boolean） 的场景，如 信用评分、风险预测 或 神经网络中的二元特征输入。</p>
<p><strong>方法一</strong><br><strong>手动二值化</strong></p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(42)</span><br><span class="line">data = np.random.randn(10) * 10 + 50  <span class="comment"># 生成 10 个均值为 50 的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定阈值（如50）</span></span><br><span class="line">threshold = 50</span><br><span class="line">binarized_data_fixed = (data &gt;= threshold).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值二值化</span></span><br><span class="line">threshold_mean = np.mean(data)</span><br><span class="line">binarized_data_mean = (data &gt;= threshold_mean).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中位数二值化</span></span><br><span class="line">threshold_median = np.median(data)</span><br><span class="line">binarized_data_median = (data &gt;= threshold_median).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 75% 分位数二值化</span></span><br><span class="line">threshold_percentile = np.percentile(data, 75)</span><br><span class="line">binarized_data_percentile = (data &gt;= threshold_percentile).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">df</span> = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;Original Data&#x27;</span>: data,</span><br><span class="line">    <span class="string">&#x27;Fixed Threshold&#x27;</span>: binarized_data_fixed,</span><br><span class="line">    <span class="string">&#x27;Mean Threshold&#x27;</span>: binarized_data_mean,</span><br><span class="line">    <span class="string">&#x27;Median Threshold&#x27;</span>: binarized_data_median,</span><br><span class="line">    <span class="string">&#x27;Percentile Threshold&#x27;</span>: binarized_data_percentile</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">df</span>)</span><br></pre></td></tr></table></figure></div>
<p><strong>方法二</strong><br><strong>使用 sklearn 进行二值化</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.preprocessing import Binarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定固定阈值</span></span><br><span class="line">binarizer = Binarizer(threshold=50)  <span class="comment"># 以50为阈值</span></span><br><span class="line">binarized_data = binarizer.fit_transform(data.reshape(-1, 1))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二值化后的数据:\n&quot;</span>, binarized_data.flatten())</span><br></pre></td></tr></table></figure></div>

<p><strong>方法三</strong><br><strong>监督式二值化（基于决策树）</strong></p>
<p>如果有分类标签 Y，可以使用决策树来学习最佳的二值化阈值：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设目标变量 Y</span></span><br><span class="line">target = np.random.choice([0, 1], size=len(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练决策树</span></span><br><span class="line">tree = DecisionTreeClassifier(max_depth=1)  <span class="comment"># 只允许一层分裂</span></span><br><span class="line">tree.fit(data.reshape(-1, 1), target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最优的分裂阈值</span></span><br><span class="line">optimal_threshold = tree.tree_.threshold[0]</span><br><span class="line">binarized_data_tree = (data &gt;= optimal_threshold).astype(int)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;决策树选择的最优二值化阈值: &#123;optimal_threshold&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基于决策树的二值化结果:&quot;</span>, binarized_data_tree)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>何时使用二值化？</p>

    </div>
    <div class="notel-content">
      <p>✅ 适用场景<br>逻辑回归或朴素贝叶斯模型（需要布尔特征）。<br>信用评分、欺诈检测（例如：收入是否高于某个值？）。<br>生物信息学（例如：基因表达水平是否超过某个阈值？）。<br>特征筛选（减少噪声，提高模型可解释性）。<br>规则挖掘（如 Apriori 算法）（将数据转换为 0&#x2F;1 格式）。</p>
<p>❌ 不适用场景<br>信息损失严重：如果数据本身具有重要的连续性信息（如温度、房价），二值化可能会损失过多信息。<br>非布尔场景：如果数据有多个类别，建议使用多级离散化（如分箱）。</p>

    </div>
  </div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP介绍及其创建使用</title>
    <url>/zhihaojiang.github.io/2025/03/30/20250330MCP%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MCP是什么"><a href="#MCP是什么" class="headerlink" title="MCP是什么"></a>MCP是什么</h2><p>MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 于 2024 年 11 月推出的一种开放标准协议，旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信方式。​<br><strong>Model Context Protocol (MCP)</strong><br>MCP 是一个标准协议，就像给 AI 大模型装了一个 “万能接口”，让 AI 模型能够与不同的数据源和工具进行无缝交互。它就像 USB-C 接口一样，提供了一种标准化的方法，将 AI 模型连接到各种数据源和工具。<br>MCP 旨在替换碎片化的 Agent 代码集成，从而使 AI 系统更可靠，更有效。通过建立通用标准，服务商可以基于协议来推出它们自己服务的 AI 能力，从而支持开发者更快的构建更强大的 AI 应用。开发者也不需要重复造轮子，通过开源项目可以建立强大的 AI Agent 生态。<br>MCP 的核心概念包括：</p>
<ol>
<li>上下文共享：​应用程序可以通过 MCP 向模型提供所需的上下文信息，如文件内容、数据库记录等，增强模型的理解和生成能力。</li>
<li>工具暴露：​MCP 允许应用程序将功能（如文件读写、API 调用）暴露给模型，模型可以调用这些工具完成复杂任务。​</li>
<li>可组合的工作流：​开发者可以利用 MCP 集成多个服务和组件，构建灵活、可扩展的 AI 工作流。​</li>
<li>安全性：​通过本地服务器运行，MCP 避免将敏感数据上传至第三方平台，确保数据隐私。 ​</li>
</ol>
<p>MCP 的架构主要由以下组件组成：</p>
<ol>
<li>MCP 主机（Host）：​如 Claude Desktop、IDE 或其他 AI 工具，即大模型的应用。​</li>
<li>MCP 客户端（Client）：​在主机应用内的连接器，负责与 MCP 服务器建立连接。​</li>
<li>MCP 服务器（Server）：​实现 MCP 协议的程序，提供特定功能或数据资源，供客户端访问。​</li>
<li>远程服务：​如 Slack、GitHub API 等，MCP 服务器可以连接的外部服务。 ​</li>
</ol>
<p>通过 MCP，AI 模型可以直接与数据源建立标准化的连接，避免了为每个新数据源定制对接方案的繁琐过程，从而实现真正的互联互通。</p>
<p>MCP（Model Context Protocol）允许你定义和暴露自定义的函数（工具），让大模型调用这些工具来完成特定任务。例如，你可以构建一个函数，让模型查询数据库、读取文件、调用 API，甚至执行本地计算。</p>
<h2 id="MCP-让模型调用工具的方式"><a href="#MCP-让模型调用工具的方式" class="headerlink" title="MCP 让模型调用工具的方式"></a>MCP 让模型调用工具的方式</h2><p><strong>定义一个工具（函数）</strong><br>在本地或远程服务器上编写一个 API 或函数，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">def get_weather(city):</span><br><span class="line">    <span class="comment"># 这里可以调用真实的天气 API</span></span><br><span class="line">    <span class="built_in">return</span> f<span class="string">&quot;&#123;city&#125; 当前气温 25°C，晴天&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>通过 MCP 暴露该工具</strong><br>通过 MCP 让大模型知道这个工具的存在，并允许它调用。例如，在 Claude 或其他支持 MCP 的环境中，模型可以动态调用你的 get_weather(city) 函数。<br><strong>模型调用工具</strong><br>当用户询问「北京的天气如何？」时，模型可以自动调用 get_weather(“北京”)，并将结果返回给用户，而不是依赖自身训练的数据。</p>
<h2 id="创建并使用的流程"><a href="#创建并使用的流程" class="headerlink" title="创建并使用的流程"></a>创建并使用的流程</h2><p>以get_weather为例<br>我们首先创建一个.py文件叫weather<br>在文件中输入下述代码</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from mcp import MCPServer, tool</span><br><span class="line"></span><br><span class="line">class WeatherServer(MCPServer):</span><br><span class="line">    @tool</span><br><span class="line">    def get_weather(self, city: str) -&gt; str:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        获取指定城市的天气信息。</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 调用天气 API 获取数据</span></span><br><span class="line">        api_key = <span class="string">&#x27;您的API密钥&#x27;</span></span><br><span class="line">        response = requests.get(f<span class="string">&#x27;http://api.weatherapi.com/v1/current.json?key=&#123;api_key&#125;&amp;q=&#123;city&#125;&amp;lang=zh&#x27;</span>)</span><br><span class="line">        data = response.json()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;error&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">            <span class="built_in">return</span> f<span class="string">&quot;无法获取&#123;city&#125;的天气信息。&quot;</span></span><br><span class="line">        weather = data[<span class="string">&#x27;current&#x27;</span>][<span class="string">&#x27;condition&#x27;</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">        temp_c = data[<span class="string">&#x27;current&#x27;</span>][<span class="string">&#x27;temp_c&#x27;</span>]</span><br><span class="line">        <span class="built_in">return</span> f<span class="string">&quot;&#123;city&#125;当前天气：&#123;weather&#125;，气温：&#123;temp_c&#125;°C。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    server = WeatherServer()</span><br><span class="line">    server.run()</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>记得安装必要的库</p>

    </div>
    <div class="notel-content">
      <p>pip install mcp-server</p>

    </div>
  </div>
<p>这样，MCP工具就做好了</p>
<p>之后，我们要将这个工具告诉AI<br>打开一个支持MCP的AI软件或网站 这里我使用vs code中的cline插件<br>在插件设置中找到MCP Servers -&gt; installed -&gt; Configure MCP Server 点击<br>会进入到一个叫cline_mcp_settings.json的文档<br>里面应该是这样的</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在mcpServers中插入你写的工具</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mcpServers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;weather&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;command&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;--directory&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/Volumes/HIKSEMI/mcp_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;run&quot;</span>,</span><br><span class="line">        <span class="string">&quot;weather.py&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>记得安装必要的库</p>

    </div>
    <div class="notel-content">
      <p>“weather”: { -&gt; 这个是你的MCP工具的名字 可以自己随便取</p>
<p>“command”: “python” -&gt;这个是告诉他使用 python 命令来运行 Python 解释器 启动服务器</p>
<p>“args”: [<br>        “–directory”, -&gt;这个选项通常用来告诉服务器在哪个路径下查找需要的资源 或者在该目录下运行服务器<br>        “&#x2F;Volumes&#x2F;HIKSEMI&#x2F;mcp_server”, -&gt;这是指定你weather.py的路径<br>        “run”, -&gt; 这个是告诉程序去执行接下来的操作 即运行指定的Python脚本<br>        “weather.py” -&gt; 这是要执行的 Python 脚本的名称</p>

    </div>
  </div>

<p>保存好后会在下面看见你的MCP工具已经启用了 在向大模型询问天气时 他会优先查询是否有可用的MCP工具 并按照对应的格式给出答复</p>
]]></content>
      <categories>
        <category>科技</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>MCP</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>字母在字符串中的百分比</title>
    <url>/zhihaojiang.github.io/2025/03/31/20250331%E5%AD%97%E6%AF%8D%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “foobar”, letter &#x3D; “o”<br>输出：33<br>解释：<br>等于字母 ‘o’ 的字符在 s 中占到的百分比是 2 &#x2F; 6 * 100% &#x3D; 33% ，向下取整，所以返回 33 。<br>示例 2：</p>
<p>输入：s &#x3D; “jjjj”, letter &#x3D; “k”<br>输出：0<br>解释：<br>等于字母 ‘k’ 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 由小写英文字母组成<br>letter 是一个小写英文字母</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"></ul><div class="tab-content"></div></div>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
</search>
